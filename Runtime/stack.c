#include "tag.h"
#include "queue.h"
#include "stack.h"
#include "thread.h"
#include "hash.h"
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <values.h>
#include "general.h"
#include "stats.h"
#include "memobj.h"
#include "client.h"
#include "forward.h"
#include "global.h"

int GCTableEntryIDFlag = 0;  /* let the user code set it if it thinks it's on */
int save_rate = 70;
int use_stack_gen = 0;


static mem_t GCTABLE_BEGIN_ADDR = &GCTABLE_BEGIN_VAL;
static mem_t GCTABLE_END_ADDR = &GCTABLE_END_VAL;
static mem_t GLOBALS_BEGIN_ADDR = &GLOBALS_BEGIN_VAL;
static mem_t GLOBALS_END_ADDR = &GLOBALS_END_VAL;
static mem_t TRACE_GLOBALS_BEGIN_ADDR = &TRACE_GLOBALS_BEGIN_VAL;
static mem_t TRACE_GLOBALS_END_ADDR = &TRACE_GLOBALS_END_VAL;

int debugStack = 0;
long MaxStackDepth = 0;
long TotalStackDepth = 0;
long TotalNewStackDepth = 0;
long TotalStackSize  = 0;

extern mem_t start_client_retadd_val;

/* This structure must match the GC table entry format generated by the compiler */
struct Callinfo
{
  val_t   retadd;            /* not mem_t as we use only 4 bytes */
#ifdef GCTABLE_HASENTRYID
  int     entryid;
#endif
  int     sizes;             /* low   9 bits = entry size in words; 
                                next  9 bits = frame size in words;
                                next  9 bits = byte section size in words 
				upper 5 bits = quad_offset of return address
			     */
  int     regtrace_a;       /* ab=10: YES      ab=00:NO  */
  int     regtrace_b;       /* ab=11 CALLEE    ab=01:SPEC */
  char    __rawdata[4];      /* must be word aligned;
				for the stack status: 00 -> TRACE_NO; 01-> TRACE_YES;
				                      02 -> TRACE_CALLEE ?; 03 -> TRACE_?
				then comes byte data and then special data */
  /* Note that ONLY the BYTE DATA follows the natural endian-ness.
    The other fields use ints/4 bytes when laid out.  If the the other fields,
    like the regtrace or stacktrace are read fom memory in smaller sizes for
    optimization purposes, the runtime must dispatch at compile-time on endian-ness. 
    The pairs of bits in stacktrace/regtrace are laid out starting from the lsb
    to the most significant bit.  Note that this is biased towards little-endian,
    the one true endian!!!*/
};


typedef struct Callinfo Callinfo_t;
typedef unsigned int bot;



typedef void (voidfun_t)();
#define stub_decl(m,n) \
m##n##0, m##n##1, m##n##2, m##n##3, m##n##4, m##n##5, m##n##6, m##n##7, m##n##8, m##n##9

voidfun_t stub_decl(stack_stub_,00);
voidfun_t stub_decl(stack_stub_,01);
voidfun_t stub_decl(stack_stub_,02);
voidfun_t stub_decl(stack_stub_,03);
voidfun_t stub_decl(stack_stub_,04);
voidfun_t stub_decl(stack_stub_,05);
voidfun_t stub_decl(stack_stub_,06);
voidfun_t stub_decl(stack_stub_,07);
voidfun_t stub_decl(stack_stub_,08);
voidfun_t stub_decl(stack_stub_,09);
voidfun_t stub_decl(stack_stub_,10);
voidfun_t stub_decl(stack_stub_,11);
voidfun_t stub_decl(stack_stub_,12);
voidfun_t stub_decl(stack_stub_,13);
voidfun_t stub_decl(stack_stub_,14);
voidfun_t stub_decl(stack_stub_,15);
voidfun_t stub_decl(stack_stub_,16);
voidfun_t stub_decl(stack_stub_,17);
voidfun_t stub_decl(stack_stub_,18);
voidfun_t stub_decl(stack_stub_,19);

voidfun_t *stack_stubs[NUM_STACK_STUB] = { 
  stub_decl(stack_stub_,00),  stub_decl(stack_stub_,01),
  stub_decl(stack_stub_,02),  stub_decl(stack_stub_,03),
  stub_decl(stack_stub_,04),  stub_decl(stack_stub_,05),
  stub_decl(stack_stub_,06),  stub_decl(stack_stub_,07),
  stub_decl(stack_stub_,08),  stub_decl(stack_stub_,09),
  stub_decl(stack_stub_,10),  stub_decl(stack_stub_,11),
  stub_decl(stack_stub_,12),  stub_decl(stack_stub_,13),
  stub_decl(stack_stub_,14),  stub_decl(stack_stub_,15),
  stub_decl(stack_stub_,16),  stub_decl(stack_stub_,17),
  stub_decl(stack_stub_,18),  stub_decl(stack_stub_,19)
};


extern val_t global_exnrec; /* C/asm convention has asm label be the Lvalue in C */


void stub_error()
{
  printf("stub_error: should be a dead ra");
  assert(0);
}


bot LookupStackBot(Callinfo_t *callinfo, int pos)
{
  unsigned int v = ((int*)(callinfo->__rawdata))[pos >> 4];
  int whichbot = pos & 15;
  return (v >> (2 * whichbot)) & 3;
}


#define GET_ENTRYSIZE(x)      ( x        & 511)
#define GET_FRAMESIZE(x)      ((x >> 9)  & 511)
#define GET_BYTESTUFFSIZE(x)  ((x >> 18) & 511)
#define GET_QUAD_RA_OFFSET(x) ((x >> 27) & 31)

int LookupSpecialByte(Callinfo_t *callinfo, int pos)
{
  int framesize = GET_FRAMESIZE(callinfo->sizes);
  int stacktrace_rawbytesize = framesize >> 2;
  int stacktrace_bytesize = (stacktrace_rawbytesize + 3) & (~3);
  char *special_byte = callinfo->__rawdata + stacktrace_bytesize;
  return special_byte[pos];
}

void LookupSpecialWordPair(Callinfo_t *callinfo, int pos, int *a, int *b)
{
  int framesize = GET_FRAMESIZE(callinfo->sizes);
  int stacktrace_rawbytesize = framesize >> 2;
  int stacktrace_bytesize = (stacktrace_rawbytesize + 3) & (~3);
  char *special_byte = callinfo->__rawdata + stacktrace_bytesize;

  int bytedata_bytesize = GET_BYTESTUFFSIZE(callinfo->sizes) << 2;
  int *special_word_stuff = (int *) (special_byte + bytedata_bytesize);
  *a = special_word_stuff[2*pos];
  *b = special_word_stuff[2*pos+1];
  if ((val_t)(&(special_word_stuff[2*pos+1])) >= 
      ((val_t)callinfo) + (GET_ENTRYSIZE(callinfo->sizes) << 2))
    {
      printf("ERROR in lookupspecialwordpair\n");
      printf("stacktrace_bytesize = %d\n",stacktrace_bytesize);
      printf("bytedata_bytesize = %d\n",bytedata_bytesize);
      printf("framesize (words) = %d\n",framesize);
      printf("pos = %d\n",pos);
    }
}



HashTable_t *CallinfoHashTable = NULL;
long GCTableSize = 0;
long SMLGlobalSize = 0;
long GlobalTableSize = 0;
long MutableTableSize = 0;



val_t GetStackStub(unsigned int n)
{
  if (n < NUM_STACK_STUB)
    return (val_t) (stack_stubs[n]);
  assert(0);
}

void stack_init()
{
  struct HashEntry e;
  unsigned int mi = 0, count=NUM_STACK_STUB, i,j;

#ifdef GCTABLE_HASENTRYID
  assert(GCTableEntryIDFlag == 1);
#else
  assert(GCTableEntryIDFlag == 0);
#endif

  for (mi=0; mi<module_count; mi++) {
    int *startpos = (int *)(GCTABLE_BEGIN_ADDR[mi]);
    int *endpos = (int *)(GCTABLE_END_ADDR[mi]);
    int *curpos = startpos; 
    if (debugStack) 
      printf("Scanning GC tables of module %d: %d to %d\n", mi, startpos, endpos);
    while (curpos < endpos) {
      int entrySize = GET_ENTRYSIZE(((Callinfo_t *)curpos)->sizes);
      count++;
      if (debugStack) {
	printf("curpos=%d sizes=%d, entrysize=%d\n",
	       curpos, ((Callinfo_t *)curpos)->sizes, GET_ENTRYSIZE(((Callinfo_t *)curpos)->sizes));
      }
      assert(entrySize != 0);
      curpos += entrySize;
    }
    GCTableSize += (long)endpos - (long)startpos;
    SMLGlobalSize += (long)(GLOBALS_END_ADDR[mi]) - 
      (long)(GLOBALS_BEGIN_ADDR[mi]);
    MutableTableSize += (long)(TRACE_GLOBALS_END_ADDR[mi]) - 
      (long)(TRACE_GLOBALS_BEGIN_ADDR[mi]);
/*
       GlobalTableSize += (long)(GLOBAL_TABLE_END_ADDR[mi]) - 
	           (long)(GLOBAL_TABLE_BEGIN_ADDR[mi]);
                   
*/
    }
  CallinfoHashTable = CreateHashTable(2*count);
  for (mi=0; mi<module_count; mi++) {
    int *startpos = (int *)(GCTABLE_BEGIN_ADDR[mi]);
    int *endpos = (int *)(GCTABLE_END_ADDR[mi]);
    int *curpos = startpos; 
    while (curpos <  endpos) {
      e.key = (unsigned long)(*curpos);
      e.data = (void *)curpos;
      if (debugStack) 
	printf("key %d -> data %d\n", e.key, e.data);
      assert(IsText((ptr_t) e.key));
      /*	  printf("mi=%d, %d < %d, e.key = %d\n",mi, curpos, endpos, e.key); */
      HashTableInsert(CallinfoHashTable,&e);
      curpos += GET_ENTRYSIZE(((Callinfo_t *)curpos)->sizes);
    }
  }
  for (mi=0; mi<NUM_STACK_STUB; mi++) {
    e.key = (unsigned long)(GetStackStub(mi));
    e.data = (void *)mi;
    HashTableInsert(CallinfoHashTable,&e);
  }
}


Callinfo_t *LookupCallinfo(mem_t ret_add)
{
  unsigned int i;
  struct HashEntry *e;
  e = HashTableLookup(CallinfoHashTable,(unsigned long)ret_add,0);
  if (e && ((val_t)(e->data) < NUM_STACK_STUB))
    { printf("stack_stub_%d lookup in stack trace\n",e->data); return NULL; }
  if (e)
    return (Callinfo_t *)(e->data);
  fprintf(stderr,"FATAL ERROR: ret_add = %d not found in table during stack trace\n",ret_add);
  assert(0);
}


/* *sp_ptr initially points to the bottom of a frame with *cur_retadd_ptr as the retadd
   we walk stack frames until we have scanned frame_to_trace frames
        or we have examined all frames which lie below top
        or we hit a stub routine return address
   the resulting return addresses are deposited in q
   *sp_ptr will return pointing to the top of the last processed frame
   *cur_retadd_ptr will correspond to the last process frame 
*/
int findretadd(mem_t *sp_ptr, mem_t *cur_retadd_ptr, mem_t top, 
	       Queue_t *q, int frame_to_trace)
{
  int overflowed = 0;
  int count = 0, done = 0;
  mem_t sp = *sp_ptr;
  mem_t cur_retadd = *cur_retadd_ptr;
  QueueClear(q);
  while ((frame_to_trace--)>0)
    {
      Callinfo_t *callinfo = 0;
      int quad_offset = 0;
      callinfo = LookupCallinfo(cur_retadd);
      if (callinfo == NULL) /* hit a stub routine */
	break;
      if (sp > top) {
	static int first = 1;
	if (first)
	  printf("findretadd overflowed: sp=%d > top=%d CONTINUING\n",sp,top);
	first = 0;
	overflowed = 1;
      }
      Enqueue(q,(void *)cur_retadd);
      quad_offset = GET_QUAD_RA_OFFSET((val_t) callinfo->sizes);
      if (quad_offset == 31)
	quad_offset = LookupSpecialByte(callinfo,0);
      if (debugStack)
	printf("%d: cur_retadd %12d  sp/top %d %d\n",
	       count++,cur_retadd,sp,top);

#ifdef alpha_osf
      cur_retadd = (mem_t)sp[quad_offset];
#else
#ifdef solaris
      cur_retadd = ((mem_t)sp[quad_offset]) + 2; /* We add 2 words because the link value is
						    the address of the calling instruction
						    AND there is a delay slot. */
#else
      error platform not defined
#endif
#endif
      { 
	int framesize = GET_FRAMESIZE(callinfo->sizes)<<2;
	if (framesize >= 8192)
	  printf("framesize = %d too big\n", framesize);
	sp += framesize / (sizeof (unsigned int));
      }
      if (cur_retadd == (mem_t)(&start_client_retadd_val) || (sp == top)) {
	done = 1;
	if (debugStack && sp == top) printf("******* sp==top\n");
	break;
      }
    }
  *sp_ptr = sp;
  *cur_retadd_ptr = cur_retadd;

  if (overflowed) {
    printf("findretadd overflowed: sp=%d > top=%d\n",sp,top);
    assert(0);
  }
  return done;
}


int should_trace_special(unsigned long trace, 
			 Callinfo_t *callinfo, mem_t cur_sp, int regstate,
			 unsigned int *byte_offset, unsigned int *word_offset,
			 loc_t data_add, int i)
{
  val_t data = *data_add;
  if (IS_TRACE_SPECIAL(trace))
    {
      /* res is the type of the value */
      ptr_t res = 0;
      int special_type, special_data;
      LookupSpecialWordPair(callinfo,*(word_offset++),
			    &special_type,&special_data);
      if (debugStack)
	printf("TRACE_SPECIAL: data %d at %d, "
	       "trType = %d%s, trData = %d\n",
	       *data_add, data_add,
	       special_type, (IS_SPECIAL_UNSET(special_type)) ? "(UNSET)" : "",
	       special_data);
      if (IS_SPECIAL_STACK(special_type))
	res = (ptr_t) cur_sp[special_data/4];
      else if (IS_SPECIAL_UNSET(special_type)) {
	printf("Registers/Stack locatiobs of type UNSET is not supported\n");
	assert(0);
      }
      else if (IS_SPECIAL_GLOBAL(special_type))
	res = (ptr_t) (*((loc_t)special_data));
      else if (IS_SPECIAL_STACK_REC(special_type)) {
	int rec_pos = GET_SPECIAL_STACK_REC_POS(special_type);
	int rec_pos2 = GET_SPECIAL_STACK_REC_POS2(special_type);
	int rec_pos3 = GET_SPECIAL_STACK_REC_POS3(special_type);
	int rec_pos4 = GET_SPECIAL_STACK_REC_POS4(special_type);
	res = (ptr_t)(cur_sp[special_data/4]);
	if (debugStack)
	  printf("  cur_sp[trData/4] = %d\n", res);
	res = (ptr_t)(res[rec_pos]);   /* First projection must exist and is not offset by 1 */
	if (debugStack)
	  printf("  res[rec_pos] = %d\n", res);
	if (rec_pos2 > 0) res = (ptr_t) res[rec_pos2-1];
	if (rec_pos3 > 0) res = (ptr_t) res[rec_pos3-1];
	if (rec_pos4 > 0) res = (ptr_t) res[rec_pos4-1];
	if (debugStack)
	  printf("  final res = %d\n", res);
      }
      else if (IS_SPECIAL_GLOBAL_REC(special_type)) {
	int rec_pos = GET_SPECIAL_STACK_GLOBAL_POS(special_type);
	int rec_pos2 = GET_SPECIAL_STACK_GLOBAL_POS2(special_type);
	int rec_pos3 = GET_SPECIAL_STACK_GLOBAL_POS3(special_type);
	int rec_pos4 = GET_SPECIAL_STACK_GLOBAL_POS4(special_type);
	res = (ptr_t) special_data; 
	res = (ptr_t) res[rec_pos]; /* First projection must exist and is not offset by 1 */
	if (rec_pos2 > 0) res = (ptr_t) res[rec_pos2-1];
	if (rec_pos3 > 0) res = (ptr_t) res[rec_pos3-1];
	if (rec_pos4 > 0) res = (ptr_t) res[rec_pos4-1];
      }
      else
	printf("impossible trace_special wordpair entry: %d %d\n",
	       special_type,special_data);
      /* Types 0 to 3 represent integral/non-pointer types */
      return (((val_t) res) > 3);
    }
  
  printf("Impossible GC table entry: stackdata\n");
  assert(0);
}


#ifdef alpha_osf
static 
#else
static inline 
#endif 
int should_trace(unsigned long trace, 
		 Callinfo_t *callinfo, mem_t cur_sp, int regstate,
		 unsigned int *byte_offset, unsigned int *word_offset,
		 val_t *data_add,
		 int i)
{
  val_t data = *data_add;
  if (IS_TRACE_YES(trace)) {
    if (SHOW_GCDEBUG)
      printf("yes: stack trace value %d at loc %d val=%d\n",
	     data_add,i*4,data);
    return 1;
  }
  else if (IS_TRACE_NO(trace)) {
    if (SHOW_GCDEBUG)
      printf("no: stack trace value %d at loc %d val=%d\n",
	     data_add,i*4,data);
    return 0;
  }
  else if (IS_TRACE_CALLEE(trace)) {
    int pos = LookupSpecialByte(callinfo,*(byte_offset++));
    int shouldTrace = regstate & (1 << pos);
    if (shouldTrace && SHOW_GCDEBUG)
      printf("callee trace: add=%d stackpos=%d"
	     " val=%d trace/pos=%d/%d\n",
	     data_add,4*i,data,trace,pos);
    return shouldTrace;
  }
  else 
    return should_trace_special(trace, callinfo, cur_sp, regstate,
				byte_offset, word_offset, data_add, i);
}



/* 
The return address in the queue identifies the frame
which is pointed to by bot_sp at the moment.  Note that
bot_sp points to the top of this frame.  Thus, when we are
done, bot_sp will point to the bottom of the last processed frame.  
Returns number of frames left. 
*/
int trace_stack_step(Thread_t *th, unsigned long *saveregs,
		     mem_t *bot_sp, Queue_t *retadd_queue,
		     mem_t top,
		     Queue_t *roots, unsigned int *regstate_ptr, 
		     unsigned int frame_to_trace,
		     Heap_t *fromspace)
{
  unsigned int mi;
  mem_t cur_sp = *bot_sp;
  unsigned int regstate = *regstate_ptr;

  while (!QueueIsEmpty(retadd_queue) && ((frame_to_trace--)>0))
    {
      mem_t     retadd    = (mem_t)(QueuePop(retadd_queue));
      Callinfo_t *callinfo  = LookupCallinfo(retadd);
      unsigned int temp_regstate = 0;
      unsigned int byte_offset = 0, word_offset = 0;
      unsigned int framesize_word = GET_FRAMESIZE(callinfo->sizes);

      int stacktrace_rawbytesize = framesize_word >> 2;
      int stacktrace_bytesize = (stacktrace_rawbytesize + 3) & (~3);
      char *special_byte = callinfo->__rawdata + stacktrace_bytesize;

      unsigned int quad_offset = GET_QUAD_RA_OFFSET((val_t) callinfo->sizes);
      assert((((int)cur_sp) & 15) == 0);  /* frames are multiples of 16 bytes */
      cur_sp -= framesize_word;
      if (quad_offset == 31) {
	quad_offset = LookupSpecialByte(callinfo,0);
	byte_offset = 1;
      }
      if (debugStack) {
	printf("==========================================================\n");
	printf("SP = %d   RA = %d  regstate is %d  framesize = %d\n",
	       cur_sp,retadd,regstate,framesize_word<<2);
	printf("   regtrace_a is %x   regtrace_b is %x\n\n",
	       callinfo->regtrace_a, callinfo->regtrace_b);
      }

      /* read one byte at a time for short-circuiting to work 
        CAREFUL with endian-ness */
      /*      printf("\n*** framesize_word = %d\n",framesize_word+3); */
      for (mi=0; mi<(framesize_word+3)>>2; mi++)
	{
#ifdef little_endian
	  unsigned long v = (long)(((char*)(callinfo->__rawdata))[mi]);	
#ifdef big_endian
#error big and little endian both defined
#endif
#endif
#ifdef big_endian
	  unsigned mi_bigendian = (mi & (~3)) | (3 - (mi & 3));
	  unsigned long v = (long)(((char*)(callinfo->__rawdata))[mi_bigendian]);
#endif
	  int mj;
	  

	  if (!v) continue; /* short-circuit on TRACE_NO of 4 slots */
	  for (mj=3; mj>=0; mj--)
	    {
	      unsigned long trace =  v & 3;
	      int i = mi * 4 + (3 - mj);
	      mem_t slot = cur_sp + i;
	      v >>= 2;
	      if (should_trace(trace,callinfo,cur_sp, regstate,
			       &byte_offset, &word_offset,
			       slot,i)) {
		ptr_t data = (ptr_t) *slot;
		if (!IsTagData(data) && !IsGlobalData(data)) {
		  if (debugStack)
		    printf("!!! Enqueueing stack slot %d with value %d\n", slot, data);
		  Enqueue(roots,(void *)slot);
		}
	      }
	    }
	}

      temp_regstate = 0;
      {
	unsigned int ra = callinfo->regtrace_a;
	unsigned int rb = callinfo->regtrace_b;
	unsigned int yes_bits    = ra & ~rb;
	unsigned int callee_mask = ra & rb;
	unsigned int needspecial = ~ra & rb;
	temp_regstate = yes_bits | (callee_mask & regstate);
	/*	printf("initial temp_regstate is %d\n",temp_regstate); */
	if (needspecial)
	  {
	    for (mi=0; mi<32; mi++) {
	      mem_t data_add = (mem_t) &(saveregs[mi]);
	      if (!(needspecial & (1U << mi)))
		continue;
	      if (should_trace(TRACE_SPECIAL,callinfo,cur_sp, regstate,
			       &byte_offset, &word_offset,
			       data_add,-1))
		temp_regstate |= 1 << mi;
	    }
	  }
      }
      regstate = temp_regstate;

    }
    *bot_sp = cur_sp;
    *regstate_ptr = regstate;

  if (debugStack)
    printf("findretadd: retadd_queue length =  %d\n",
	   QueueLength(retadd_queue));

    return QueueLength(retadd_queue);
}

unsigned int trace_stack_normal(Thread_t *th, unsigned long *saveregs,
				mem_t bot_sp, mem_t cur_retadd, mem_t top,
				Queue_t *root_lists, Heap_t *fromspace)
{
  Queue_t *retadd_queue = th->retadd_queue;
  Queue_t *roots = th->snapshots[0].roots;
  mem_t cur_sp = bot_sp;
  unsigned int regstate = 0;
  int not_done = 1;
  
  (void) findretadd(&cur_sp,&cur_retadd,top,retadd_queue,MAXINT);
  TotalStackDepth += QueueLength(retadd_queue);
  if (MaxStackDepth < QueueLength(retadd_queue))
    MaxStackDepth = QueueLength(retadd_queue);
  TotalStackSize += top - bot_sp;

  QueueClear(roots);
  while (not_done)
    not_done = trace_stack_step(th, saveregs,&cur_sp, retadd_queue, top,
				roots, &regstate, MAXINT, fromspace);

  Enqueue(root_lists,roots);
  return regstate;
}



/* lastexptr is the value of exnptr after the last garbage collection */
unsigned int trace_stack_gen(Thread_t *th, unsigned long *saveregs,
			     mem_t bot_sp, mem_t cur_retadd, mem_t top,
			     Queue_t *root_lists, ptr_t last_exnptr, ptr_t this_exnptr,
			     Heap_t *fromspace)
{
  SysThread_t *sth = th->sysThread;
  Queue_t *retadd_queue = th->retadd_queue;
  mem_t cur_sp;
  mem_t max_sp = (mem_t) th->maxSP;
  unsigned int regstate = 0;
  int i, j, not_done = 1;

  TotalStackSize += top - bot_sp;

  {
    int temp = -1;
    while (((temp+1) <= th->last_snapshot) &&
	   (th->snapshots[temp+1].saved_ra != 0) &&
	   ((mem_t)th->snapshots[temp+1].saved_sp > max_sp))
      temp++;
    th->last_snapshot = temp;
  }


  if (debugStack)
    printf("th->last_snapshot=%d,  top=%d  max_sp = %d\n",th->last_snapshot,top,max_sp);

  if (th->last_snapshot >= 0)
    {
      for (i=0; i<=th->last_snapshot; i++) {
	  Queue_t *r = th->snapshots[i].roots;
	  Enqueue(root_lists,r);
	}
      regstate = th->snapshots[th->last_snapshot].saved_regstate;
      top = (mem_t) th->snapshots[th->last_snapshot].saved_sp;
    }


  assert(top > bot_sp);
  { 
    int predone = save_rate * (th->last_snapshot+1);
    int retadd_qlen, curstack_depth;

    (void) findretadd(&bot_sp,&cur_retadd,top,retadd_queue,MAXINT);
    retadd_qlen = QueueLength(retadd_queue);
    TotalNewStackDepth += retadd_qlen;
    curstack_depth = retadd_qlen + predone;
    TotalStackDepth += curstack_depth;
    if (MaxStackDepth < curstack_depth) 
      MaxStackDepth = curstack_depth;
    if (debugStack)
      printf("predone/total  %d/%d/%d\n",predone,curstack_depth);
  }


  while (not_done)
    {
      unsigned int inner_save_rate = save_rate;
      Queue_t *r = th->snapshots[th->last_snapshot+1].roots;
      if (th->last_snapshot + 2 >= NUM_STACK_STUB)
	inner_save_rate = MAXINT;
      if (r == NULL)
	r = QueueCreate(0,50);

      QueueClear(r);
      not_done = trace_stack_step(th, saveregs, &bot_sp, retadd_queue, top,
				  r, &regstate, inner_save_rate,fromspace);
      Enqueue(root_lists,r);

      if (not_done)
	{
	  StackSnapshot_t *snapshots = th->snapshots;
	  mem_t next_retaddid = (mem_t)QueuePopPeek(retadd_queue);
	  Callinfo_t *callinfo  = LookupCallinfo(next_retaddid);
	  mem_t next_ra_add = bot_sp - (GET_FRAMESIZE(callinfo->sizes)<<2);
	  unsigned int quad_offset = GET_QUAD_RA_OFFSET(callinfo->sizes);
	  if (quad_offset == 31)
	    quad_offset = LookupSpecialByte(callinfo,0);
	  next_ra_add += quad_offset << 2;

	  th->last_snapshot++; 
	  snapshots[th->last_snapshot].roots = r;
	  snapshots[th->last_snapshot].saved_regstate = regstate;
	  snapshots[th->last_snapshot].saved_sp = (unsigned long) bot_sp;
	  snapshots[th->last_snapshot].saved_ra = *next_ra_add;
	  if (debugStack) {
	    printf("snapshots = %d, snapshots[th->last_snapshot]=%d"
		   "s[c]->saved_ra=%d, s[c]->saved_sp=%d\n",
		   snapshots,snapshots[th->last_snapshot],
		   snapshots[th->last_snapshot].saved_ra,
		   snapshots[th->last_snapshot].saved_sp);
	    printf("saving(%d): sp,ra %d,%d regstate=%d\n",
		   th->last_snapshot,
		 bot_sp,*next_ra_add,regstate);
	  }
	  *next_ra_add = GetStackStub(th->last_snapshot);
	}

    }

  if (debugStack)
    printf("stack_trace_gen: th->last_snapshot=%d\n",th->last_snapshot);

  return regstate;
}


unsigned int trace_stack(Thread_t *th, unsigned long *saveregs,
			 mem_t top, Queue_t *root_lists, Heap_t *fromspace)
{
  unsigned int regstate = 0;
  static ptr_t last_exnptr = 0; 
  ptr_t this_exnptr = (ptr_t) saveregs[EXNPTR];
  mem_t sp = (mem_t) saveregs[SP];
#ifdef solaris
  mem_t ret_add = (mem_t) (saveregs[LINK] + 8);  /* 2 instructions added - 
						    one since PC saved at call, 
						    another for delay slot */
#else
  mem_t ret_add = (mem_t) saveregs[RA];
#endif

  if (!last_exnptr)
    last_exnptr = &global_exnrec;

  if (use_stack_gen)
    regstate = trace_stack_gen( th, saveregs, sp,  ret_add, top, 
				root_lists, last_exnptr, this_exnptr, fromspace);
  else
    regstate = trace_stack_normal( th, saveregs, sp,  ret_add, top, root_lists, fromspace);

  last_exnptr = this_exnptr;

  if (debugStack) {
    int i, j, count=0;
    val_t sum = 0;
    for (j=0; j<QueueLength(root_lists); j++) {
      Queue_t *roots = QueueAccess(root_lists,j);
      for (i=0; i<QueueLength(roots); i++) {
	mem_t root = (mem_t) QueueAccess(roots,i);
	sum += (val_t) root;
	printf("  root %d: *%d = %d\n",count,root,*root);
	count++; 
      }
    }
    printf("Number of roots = %d,  cksum=%d, regstate is 0x%x or %d\n",
	   count,sum,regstate,regstate);
  }

  return regstate;
}



void debug_after_rootscan(unsigned long *saveregs, int regmask, 
			  Queue_t *root_lists)
{
  int allocptr = saveregs[ALLOCPTR];
  if (!debugStack)
    return;
  if (SHOW_GCDEBUG && NumGC > LEAST_GC_TO_CHECK) {
    long i,j;
    printf("\n--------------- ROOT INFORMATION ---------------\n");
    for (i=0; i<32; i++)
      if (regmask & (1 << i))
	printf("LIVE REGISTER VALUE %d: %d\n",i,saveregs[i]);
    
    for (j=0; j<QueueLength(root_lists); j++)
      {
	Queue_t *roots = QueueAccess(root_lists,j);
	for (i=0; i<QueueLength(roots); i++)
	  printf("ROOT #%d: %d(%d)\n",
		 i,QueueAccess(roots,i),*((int *)QueueAccess(roots,i)));
      }
  }
}

void local_root_scan(SysThread_t *sth, Thread_t *th, Heap_t *fromspace)
{
  Queue_t *root_lists = sth->root_lists;
  Queue_t *reg_roots = th->reg_roots;
  unsigned long *saveregs = (unsigned long *)(th->saveregs);
  unsigned long i;
  int regmask = 0;

  start_timer(&sth->stacktime);
  QueueClear(reg_roots);

  for (i=th->nextThunk; i<th->numThunk; i++) {
    mem_t thunkAddr = &(((ptr_t)th->thunks)[i]);
    ptr_t thunk = (ptr_t) *thunkAddr;
    if (!IsTagData(thunk) && !IsGlobalData(thunk)) {
      if (debugStack)
	printf("!!! Enqueueing thunk - position %d with value %d\n", thunkAddr, thunk);
      Enqueue(reg_roots,thunkAddr);
    }
  }

  if (th->nextThunk != 0) {  /* thread has started */
    mem_t sp = (mem_t) saveregs[SP];
    Stack_t *stack = GetStack(sp);
    regmask = trace_stack(th, saveregs, stack->top, root_lists, fromspace);
    regmask |= 1 << EXNPTR;
    for (i=0; i<32; i++)
      if ((regmask & (1 << i)) && (!(IsTagData((ptr_t)(saveregs[i])))) && (!(IsGlobalData((ptr_t)(saveregs[i]))))) {
	if (debugStack)
	  printf("!!! Enqueueing register %d - position %d with value %d\n",
		 i, (int *)(&(saveregs[i])),
		 saveregs[i]);
	Enqueue(reg_roots,(int *)(&(saveregs[i])));
      }
  }
  Enqueue(root_lists,reg_roots);

  if (debugStack)
    debug_after_rootscan(saveregs,regmask,root_lists);

  stop_timer(&sth->stacktime);

}

static Queue_t *potentialTemp = NULL;      /* temporary queue used for promotion */
static Queue_t *potentialGlobal = NULL;    /* all globals start here */
static Queue_t *promotedGlobalLoc = NULL;  /* check each potential global to see if
					      it has been initialized;  if so,
					      remove the global from potentialGlobal
					      and move all its pointers fields 
					      into promotedGlobalLoc */
static Queue_t *tenuredGlobalLoc = NULL;   /* accumulates the contents of promotedGlobalLoc
					      across all previous minor scans */


void minor_global_scan(SysThread_t *sth)
{
  /* First time, get all the globalsinto the potential list */
  if (potentialGlobal == NULL) {
    unsigned long mi;
    int estimatedGlobal = 0;  /* Estimate based on one ptr loc per global */
    for (mi=0; mi<module_count; mi++) {
      mem_t start = (mem_t)((&TRACE_GLOBALS_BEGIN_VAL)[mi]);
      mem_t stop = (mem_t)((&TRACE_GLOBALS_END_VAL)[mi]);
      estimatedGlobal += stop - start;
    }
    potentialGlobal   = QueueCreate(1, estimatedGlobal);
    potentialTemp     = QueueCreate(1, estimatedGlobal);
    promotedGlobalLoc = QueueCreate(1, estimatedGlobal);
    tenuredGlobalLoc  = QueueCreate(1, estimatedGlobal);
    for (mi=0; mi<module_count; mi++) {
      mem_t start = (mem_t)((&TRACE_GLOBALS_BEGIN_VAL)[mi]);
      mem_t stop = (mem_t)((&TRACE_GLOBALS_END_VAL)[mi]);
      for ( ; start < stop; start++) {
	mem_t global = (mem_t) (*start);
	Enqueue(potentialGlobal, global);
	if (debugStack)
	  printf("Unit %d: Enqueueing potential global %d\n", mi, global);
      }
    }
  }
  
  /* Transfer all the promotedGlobalLoc from the previous call to the tenuredGlobalLoc */
  while (!QueueIsEmpty(promotedGlobalLoc)) {
    loc_t globalLoc = Dequeue(promotedGlobalLoc);
    Enqueue(tenuredGlobalLoc, globalLoc);
  }

  /* For each root of potentialGlobal
       (1) move to potentialTemp if it is uninitialized 
       (2) move to promotedGlobalLoc all its pointer fields if it is initialized
     Swap potentialGlobal and potentialTemp
  */
  while (!QueueIsEmpty(potentialGlobal)) {
    ptr_t global = Dequeue(potentialGlobal);
    tag_t tag = global[-1];
    if (GET_TYPE(tag) == SKIP_TAG)
      Enqueue(potentialTemp, (void *)global);
    else 
      getNontagNonglobalPointerLocations(global, promotedGlobalLoc);
  }
  typed_swap(Queue_t *, potentialTemp, potentialGlobal);
  Enqueue(sth->root_lists, promotedGlobalLoc);
}

void major_global_scan(SysThread_t *sth)
{
  /* We need to transfer the contents of promotedGlobalLoc here again */
  minor_global_scan(sth);
  while (!QueueIsEmpty(promotedGlobalLoc)) {
    loc_t globalLoc = Dequeue(promotedGlobalLoc);
    Enqueue(tenuredGlobalLoc, globalLoc);
  }
  Enqueue(sth->root_lists, tenuredGlobalLoc);
}
