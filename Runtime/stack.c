#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <values.h>

#include "general.h"
#include "tag.h"
#include "queue.h"
#include "stack.h"
#include "thread.h"
#include "hash.h"
#include "stats.h"
#include "memobj.h"
#include "client.h"
#include "forward.h"
#include "global.h"

int GCTableEntryIDFlag = 0;  /* let the user code set it if it thinks it's on */
int save_rate = 70;
int useGenStack = 0;


static mem_t GCTABLE_BEGIN_ADDR = &GCTABLE_BEGIN_VAL;
static mem_t GCTABLE_END_ADDR = &GCTABLE_END_VAL;
static mem_t GLOBALS_BEGIN_ADDR = &GLOBALS_BEGIN_VAL;
static mem_t GLOBALS_END_ADDR = &GLOBALS_END_VAL;
static mem_t TRACE_GLOBALS_BEGIN_ADDR = &TRACE_GLOBALS_BEGIN_VAL;
static mem_t TRACE_GLOBALS_END_ADDR = &TRACE_GLOBALS_END_VAL;

int debugStack = 0;
long MaxStackDepth = 0;
long TotalStackDepth = 0;
long TotalNewStackDepth = 0;
long TotalStackSize  = 0;

extern mem_t start_client_retadd_val;

/* This structure must match the GC table entry format generated by the compiler */
typedef struct Callinfo__t
{
  val_t   retadd;      
#ifdef GCTABLE_HASENTRYID
  int     entryid;
#endif
  int     sizes;             /* low   9 bits = entry size in words; 
                                next  9 bits = frame size in words;
                                next  9 bits = byte section size in words 
				upper 5 bits = word offset of return address
			     */
  int     regtrace_a;        /* ab=10: YES      ab=00:NO  */
  int     regtrace_b;        /* ab=11 CALLEE    ab=01:SPEC */
  char    __rawdata[4];      /* must be word aligned;
				for the stack status: 00 -> TRACE_NO; 01-> TRACE_YES;
				                      02 -> TRACE_CALLEE ?; 03 -> TRACE_?
				then comes byte data and then special data */
  /* Note that ONLY the BYTE DATA follows the natural endian-ness.
    The other fields use ints/4 bytes when laid out.  If the the other fields,
    like the regtrace or stacktrace are read fom memory in smaller sizes for
    optimization purposes, the runtime must dispatch at compile-time on endian-ness. 
    The pairs of bits in stacktrace/regtrace are laid out starting from the lsb
    to the most significant bit.  Note that this is biased towards little-endian,
    the one true endian!!!*/
} Callinfo_t;

typedef struct CallinfoCursor__t
{
  int entrySize;
  int frameSize;
  int RAQuadOffset;
  int byteOffset;  /* cursors into the special sections */
  int wordOffset;
  Callinfo_t *callinfo;
} CallinfoCursor_t;


#define GET_ENTRYSIZE(x)      ( x        & 511)
#define GET_FRAMESIZE(x)      ((x >> 9)  & 511)
#define GET_BYTESTUFFSIZE(x)  ((x >> 18) & 511)
#define GET_QUAD_RA_OFFSET(x) ((x >> 27) & 31)


typedef unsigned int bot;

typedef void (voidfun_t)();
#define stub_decl(m,n) \
m##n##0, m##n##1, m##n##2, m##n##3, m##n##4, m##n##5, m##n##6, m##n##7, m##n##8, m##n##9

voidfun_t stub_decl(stack_stub_,00);
voidfun_t stub_decl(stack_stub_,01);
voidfun_t stub_decl(stack_stub_,02);
voidfun_t stub_decl(stack_stub_,03);
voidfun_t stub_decl(stack_stub_,04);
voidfun_t stub_decl(stack_stub_,05);
voidfun_t stub_decl(stack_stub_,06);
voidfun_t stub_decl(stack_stub_,07);
voidfun_t stub_decl(stack_stub_,08);
voidfun_t stub_decl(stack_stub_,09);
voidfun_t stub_decl(stack_stub_,10);
voidfun_t stub_decl(stack_stub_,11);
voidfun_t stub_decl(stack_stub_,12);
voidfun_t stub_decl(stack_stub_,13);
voidfun_t stub_decl(stack_stub_,14);
voidfun_t stub_decl(stack_stub_,15);
voidfun_t stub_decl(stack_stub_,16);
voidfun_t stub_decl(stack_stub_,17);
voidfun_t stub_decl(stack_stub_,18);
voidfun_t stub_decl(stack_stub_,19);

voidfun_t *stack_stubs[NUM_STACK_STUB] = { 
  stub_decl(stack_stub_,00),  stub_decl(stack_stub_,01),
  stub_decl(stack_stub_,02),  stub_decl(stack_stub_,03),
  stub_decl(stack_stub_,04),  stub_decl(stack_stub_,05),
  stub_decl(stack_stub_,06),  stub_decl(stack_stub_,07),
  stub_decl(stack_stub_,08),  stub_decl(stack_stub_,09),
  stub_decl(stack_stub_,10),  stub_decl(stack_stub_,11),
  stub_decl(stack_stub_,12),  stub_decl(stack_stub_,13),
  stub_decl(stack_stub_,14),  stub_decl(stack_stub_,15),
  stub_decl(stack_stub_,16),  stub_decl(stack_stub_,17),
  stub_decl(stack_stub_,18),  stub_decl(stack_stub_,19)
};


extern val_t global_exnrec; /* C/asm convention has asm label be the Lvalue in C */


void stub_error()
{
  printf("stub_error: should be a dead ra");
  assert(0);
}

static bot LookupStackBot(CallinfoCursor_t *cursor, int pos)
{
  unsigned int v = ((int*)(cursor->callinfo->__rawdata))[pos >> 4];
  int whichbot = pos & 15;
  return (v >> (2 * whichbot)) & 3;
}

static int LookupSpecialByte(CallinfoCursor_t *cursor)
{
  int framesize = GET_FRAMESIZE(cursor->callinfo->sizes);
  int stacktrace_rawbytesize = framesize >> 2;
  int stacktrace_bytesize = (stacktrace_rawbytesize + 3) & (~3);
  char *special_byte = cursor->callinfo->__rawdata + stacktrace_bytesize;
  return special_byte[cursor->byteOffset++];
}

static void LookupSpecialWordPair(CallinfoCursor_t *cursor, int *a, int *b)
{
  int framesize = GET_FRAMESIZE(cursor->callinfo->sizes);
  int stacktrace_rawbytesize = framesize >> 2;
  int stacktrace_bytesize = (stacktrace_rawbytesize + 3) & (~3);
  char *special_byte = cursor->callinfo->__rawdata + stacktrace_bytesize;

  int bytedata_bytesize = GET_BYTESTUFFSIZE(cursor->callinfo->sizes) << 2;
  int *special_word_stuff = (int *) (special_byte + bytedata_bytesize);
  *a = special_word_stuff[cursor->wordOffset++];
  *b = special_word_stuff[cursor->wordOffset++];
  assert (&(special_word_stuff[cursor->wordOffset]) <=
	  (int *) cursor->callinfo + GET_ENTRYSIZE(cursor->callinfo->sizes));
}

HashTable_t *CallinfoHashTable = NULL;
long GCTableSize = 0;
long SMLGlobalSize = 0;
long GlobalTableSize = 0;
long MutableTableSize = 0;

mem_t GetStackStub(unsigned int n)
{
  if (n < NUM_STACK_STUB)
    return (mem_t) (stack_stubs[n]);
  assert(0);
}

void global_root_init();

void stack_init()
{
  struct HashEntry e;
  unsigned int mi = 0, count=NUM_STACK_STUB, i,j;

#ifdef GCTABLE_HASENTRYID
  assert(GCTableEntryIDFlag == 1);
#else
  assert(GCTableEntryIDFlag == 0);
#endif

  for (mi=0; mi<module_count; mi++) {
    int *startpos = (int *)(GCTABLE_BEGIN_ADDR[mi]);
    int *endpos = (int *)(GCTABLE_END_ADDR[mi]);
    int *curpos = startpos; 
    if (debugStack) 
      printf("Scanning GC tables of module %d: %d to %d\n", mi, startpos, endpos);
    while (curpos < endpos) {
      int entrySize = GET_ENTRYSIZE(((Callinfo_t *)curpos)->sizes);
      count++;
      assert(entrySize != 0);
      curpos += entrySize;
    }
    GCTableSize += (long)endpos - (long)startpos;
    SMLGlobalSize += (long)(GLOBALS_END_ADDR[mi]) - 
      (long)(GLOBALS_BEGIN_ADDR[mi]);
    MutableTableSize += (long)(TRACE_GLOBALS_END_ADDR[mi]) - 
      (long)(TRACE_GLOBALS_BEGIN_ADDR[mi]);
/*
       GlobalTableSize += (long)(GLOBAL_TABLE_END_ADDR[mi]) - 
	           (long)(GLOBAL_TABLE_BEGIN_ADDR[mi]);
                   
*/
    }
  CallinfoHashTable = CreateHashTable(2*count);
  for (mi=0; mi<module_count; mi++) {
    int *startpos = (int *)(GCTABLE_BEGIN_ADDR[mi]);
    int *endpos = (int *)(GCTABLE_END_ADDR[mi]);
    int *curpos = startpos; 
    while (curpos < endpos) {
      e.key = (unsigned long)(*curpos);
      e.data = (void *)curpos;
      assert(IsText((ptr_t) e.key));
      HashTableInsert(CallinfoHashTable,&e);
      curpos += GET_ENTRYSIZE(((Callinfo_t *)curpos)->sizes);
    }
  }
  for (mi=0; mi<NUM_STACK_STUB; mi++) {
    e.key = (unsigned long)(GetStackStub(mi));
    e.data = (void *)mi;
    HashTableInsert(CallinfoHashTable,&e);
  }
  global_root_init();
}


static Callinfo_t *LookupCallinfo(Thread_t *th, val_t ret_add)
{
  struct HashEntry *e;

  if ((val_t) th->lastHashKey == ret_add) 
    return th->lastHashData;

  e = HashTableLookup(CallinfoHashTable,(unsigned long)ret_add,0);
  if (e == NULL) {
    fprintf(stderr,"FATAL ERROR: ret_add = %d not found in table during stack trace\n",ret_add);
    assert(0);
  }
  if (((val_t)e->data) < NUM_STACK_STUB) {
    val_t ra = th->snapshots[(val_t)e->data].saved_ra;
    assert(0);
    return LookupCallinfo(th, ra);
  }
  th->lastHashKey = e->key;
  th->lastHashData = e->data;
  return (Callinfo_t *) e->data;
}


INLINE1(resetCursor)
INLINE2(resetCursor)
void resetCursor(CallinfoCursor_t *cursor, Callinfo_t *callinfo)
{
  cursor->callinfo = callinfo;
  cursor->entrySize = GET_ENTRYSIZE(callinfo->sizes);
  cursor->frameSize = GET_FRAMESIZE(callinfo->sizes);
  cursor->byteOffset = 0;
  cursor->wordOffset = 0;
  cursor->RAQuadOffset = GET_QUAD_RA_OFFSET(callinfo->sizes);
  if (cursor->RAQuadOffset == 31)
    cursor->RAQuadOffset = LookupSpecialByte(cursor);
}

/* *sp_ptr initially points to the bottom of a frame with *cur_retadd_ptr as the retadd
   we walk stack frames until we have scanned frame_to_trace frames
        or we have examined all frames which lie below top
        or we hit a stub routine return address
   the resulting return addresses are deposited in q
   *sp_ptr will return pointing to the top of the last processed frame
   *cur_retadd_ptr will correspond to the last process frame 
*/
static int findretadd(Thread_t *th, mem_t *sp_ptr, val_t *cur_retadd_ptr, mem_t top, 
		      Stack_t *callinfoStack, int frame_to_trace)
{
  int count = 0, done = 0;
  mem_t curSP = *sp_ptr, nextSP;
  val_t curRA = *cur_retadd_ptr, nextRA;
  resetStack(callinfoStack);
  assert(curSP <= top);
  for ( ; frame_to_trace > 0; frame_to_trace--) {
    Callinfo_t *callinfo = LookupCallinfo(th,curRA);
    CallinfoCursor_t localCursor, *cursor = &localCursor;

    pushStack(callinfoStack, (ptr_t) callinfo);
    resetCursor(cursor, callinfo);
    nextSP = curSP + cursor->frameSize;
#if defined(alpha_osf)
    nextRA = (val_t)curSP[cursor->RAQuadOffset];
#elif defined(solaris)
    nextRA = (val_t)(((mem_t)curSP[cursor->RAQuadOffset]) + 2); /* We add 2 words because 
								   (1) the link value is the address of the calling instruction
								   (2) there is a delay slot. */
#else
    error platform not defined
#endif
    if (debugStack)
      printf("%d: top = %d   curSP = %d  curRA = %d     nextSP = %d nextRA = %d\n",
	     count++,top,curSP,curRA,nextSP,nextRA);
    curSP = nextSP;
    curRA = nextRA;
    if (curRA == (val_t)(&start_client_retadd_val) || (curSP == top)) {
      done = 1;
      break;
    }
  }
  assert(nextSP <= top);
  *sp_ptr = curSP;
  *cur_retadd_ptr = curRA;
  return done;
}


int should_trace_special(CallinfoCursor_t *cursor, mem_t cur_sp, int regstate,
			 loc_t data_add, int i)
{
  val_t data = *data_add;
  ptr_t res = 0;  /* res is the type of the value */
  int special_type, special_data;
  int shouldTrace = 0;

  LookupSpecialWordPair(cursor, &special_type,&special_data);

  if (debugStack)
    printf("slot %4d: %12ud  TRACE_SPECIAL(%d, %d) ",
	   i,data,special_type,special_data);
  if (IS_SPECIAL_UNSET(special_type)) {
    printf(" - UNSET\n");
    printf("Registers/Stack locatiobs of type UNSET is not supported\n");
    assert(0);
  }
  else if (IS_SPECIAL_STACK(special_type)) {
    res = (ptr_t) cur_sp[special_data/4];
    if (debugStack)
      printf(" - SPECIAL_STACK(%d) = %d", special_data, res);
  }
  else if (IS_SPECIAL_GLOBAL(special_type)) {
    res = (ptr_t) (*((loc_t)special_data));
    if (debugStack)
      printf(" - SPECIAL_GLOBAL(%d) = %d", special_data, res);
  }
  else if (IS_SPECIAL_STACK_REC(special_type)) {
    int rec_pos = GET_SPECIAL_STACK_REC_POS(special_type);
    int rec_pos2 = GET_SPECIAL_STACK_REC_POS2(special_type);
    int rec_pos3 = GET_SPECIAL_STACK_REC_POS3(special_type);
    int rec_pos4 = GET_SPECIAL_STACK_REC_POS4(special_type);
    res = (ptr_t)(cur_sp[special_data/4]);
    res = (ptr_t)(res[rec_pos]);   /* First projection must exist and is not offset by 1 */
    if (rec_pos2 > 0) res = (ptr_t) res[rec_pos2-1];
    if (rec_pos3 > 0) res = (ptr_t) res[rec_pos3-1];
    if (rec_pos4 > 0) res = (ptr_t) res[rec_pos4-1];
    if (debugStack)
      printf(" - SPECIAL_STACK_REC(%d[%d,%d,%d,%d]) = %d", special_data, rec_pos, rec_pos2, rec_pos3, rec_pos4, res);
  }
  else if (IS_SPECIAL_GLOBAL_REC(special_type)) {
    int rec_pos = GET_SPECIAL_STACK_GLOBAL_POS(special_type);
    int rec_pos2 = GET_SPECIAL_STACK_GLOBAL_POS2(special_type);
    int rec_pos3 = GET_SPECIAL_STACK_GLOBAL_POS3(special_type);
    int rec_pos4 = GET_SPECIAL_STACK_GLOBAL_POS4(special_type);
    res = (ptr_t) special_data; 
    res = (ptr_t) res[rec_pos]; /* First projection must exist and is not offset by 1 */
    if (rec_pos2 > 0) res = (ptr_t) res[rec_pos2-1];
    if (rec_pos3 > 0) res = (ptr_t) res[rec_pos3-1];
    if (rec_pos4 > 0) res = (ptr_t) res[rec_pos4-1];
    if (debugStack)
      printf(" - SPECIAL_GLOBAL_REC(%d[%d,%d,%d,%d]) = %d", special_data, rec_pos, rec_pos2, rec_pos3, rec_pos4, res);
  }
  else
    assert(0);
  shouldTrace = (((val_t) res) > 3);   /* Types 0 to 3 represent integral/non-pointer types */
  if (debugStack)
    printf(" - %s\n", shouldTrace ? "YES" : "NO");
  return shouldTrace;
}


INLINE1(should_trace)
INLINE2(should_trace)
int should_trace(unsigned long trace, 
		 CallinfoCursor_t *cursor, mem_t cur_sp, int regstate,
		 val_t *data_add, int i)
{
  val_t data = *data_add;
  if (IS_TRACE_NO(trace)) {
    if (debugStack)
      printf("slot %4d: %12ud  TRACE_NO\n",i,data);
    return 0;
  }
  else if (IS_TRACE_YES(trace)) {
    if (debugStack)
      printf("slot %4d: %12ud  TRACE_YES\n",i,data);
    return 1;
  }
  else if (IS_TRACE_CALLEE(trace)) {
    int pos = LookupSpecialByte(cursor);
    int shouldTrace = regstate & (1 << pos);
    if (debugStack)
      printf("slot %4d: %12ud  TRACE_CALLEE %d - %s\n",
	     i,data,pos,shouldTrace ? "YES" : "NO");
    return shouldTrace;
  }
  else 
    return should_trace_special(cursor, cur_sp, regstate, data_add, i);
}



/* 
The return address in the queue identifies the frame
which is pointed to by bot_sp at the moment.  Note that
bot_sp points to the top of this frame.  Thus, when we are
done, bot_sp will point to the bottom of the last processed frame.  
Returns number of frames left. 
*/
int trace_stack_step(Thread_t *th, unsigned long *saveregs,
		     mem_t *bot_sp, Stack_t *callinfoStack,
		     mem_t top,
		     Stack_t *roots, unsigned int *regstate_ptr, 
		     unsigned int frame_to_trace)
{
  int i, j, k;
  mem_t cur_sp = *bot_sp;
  unsigned int regstate = *regstate_ptr;
  assert((((int)cur_sp) & 15) == 0);  /* frames are multiples of 16 bytes */

  while (!isEmptyStack(callinfoStack) && ((frame_to_trace--)>0)) { 
    Callinfo_t *callinfo = (Callinfo_t *) popStack(callinfoStack);
    CallinfoCursor_t acursor, *cursor = &acursor;
    int numChunks;
    resetCursor(cursor, callinfo);

    numChunks = (cursor->frameSize+15)>>4; /* A chunk is the number of slots for one word of info */
    cur_sp -= cursor->frameSize;
    if (debugStack) {
      printf("==========================================================\n");
      printf("SP = %d   RA = %d   FrameSize = %d words\n", cur_sp,cursor->callinfo->retadd,cursor->frameSize);
    }
    
    /* Process the stack slots - 16 slots per word of information.
       The stack may not have a multiple of 16 slots but that's fine
       as long as we don't access those slots since the information
       for non-existent slots will be TRACE_NO.  
       (1) Short-circuit if info is zero (23 bits at a time).
       (2) Otheriwse, break iterations into a double loop of 4 by 4 iterations
           so that we can short-circuit on blocks of 4 TRACE_NO's (8 bits at a time).
    */
    for (i=0; i < numChunks; i++) {
      unsigned long info = ((int *)cursor->callinfo->__rawdata)[i];
      if (info == 0)
	continue;
      for (j=0; j<4; j++) {
	if ((info & 0xff) == 0) {
	  info >>= 8;
	  continue;
	}
	for (k=0; k<4; k++, info >>= 2) {
	  unsigned long trace = info & 3;
	  int curSlot = 16 * i + 4 * j + k;  /* Faster to recompute this */
	  if (should_trace(trace,cursor,cur_sp,regstate,cur_sp+curSlot,curSlot)) {
	    ptr_t data = (ptr_t) cur_sp[curSlot];
	    if (IsTagData(data) || IsGlobalData(data))
	      continue;
	    pushStack(roots, (ptr_t) &cur_sp[curSlot]);
	  }
	}
      }
    }

    /* Compute the state of the registers */
    {
      unsigned int ra = cursor->callinfo->regtrace_a;
      unsigned int rb = cursor->callinfo->regtrace_b;
      unsigned int yesBits    = ra & ~rb;  /* unconditionally contain pointers */
      unsigned int calleeMask = ra & rb;   /* inherit register values from previous frame */
      unsigned int specialBits = ~ra & rb; /* contains pointers depending on additional information */
      unsigned int tempRegstate = yesBits | (calleeMask & regstate);
      if (specialBits) {
	  for (i=0; i<32; i++) {
	    mem_t data_add = (mem_t) &(saveregs[i]);
	    if (!(specialBits & (1U << i)))
	      continue;
	    if (should_trace_special(cursor, cur_sp, regstate, data_add, -1))
	      tempRegstate |= 1 << i;
	  }
      }
      regstate = tempRegstate;
    }
    
  }
  *bot_sp = cur_sp;
  *regstate_ptr = regstate;
  
   return lengthStack(callinfoStack);
}

unsigned int trace_stack_normal(Proc_t *proc, Thread_t *th, unsigned long *saveregs,
				mem_t bot_sp, val_t cur_retadd, mem_t top,
				Stack_t *allRoots)
{
  Stack_t *callinfoStack = th->callinfoStack;
  Stack_t *roots = th->snapshots[0].roots;
  mem_t cur_sp = bot_sp;
  unsigned int regstate = 0;
  int numFrames, notDone;

  (void) findretadd(th,&cur_sp,&cur_retadd,top,callinfoStack,MAXINT);
  numFrames = lengthStack(callinfoStack);
  TotalStackDepth += numFrames;
  MaxStackDepth = (numFrames < MaxStackDepth) ? MaxStackDepth : numFrames;
  TotalStackSize += top - bot_sp;

  resetStack(roots);
  notDone = trace_stack_step(th, saveregs,&cur_sp, callinfoStack, top,
			     roots, &regstate, MAXINT);
  assert(!notDone);
  copyStack(roots,allRoots);

  return regstate;
}



/* topStack  = the top of ths stack to be scanned = just above the oldest frame
   botStack  = the bottom of the stack to be scanned = address of most recent frame
   botRetAdd = the return address corresponding to and used to decode the most recent frame
*/
unsigned int trace_stack_gen(Thread_t *th, unsigned long *saveregs,
			     mem_t botStack, val_t botRetAdd, mem_t topStack, Stack_t *allRoots)
{
  Proc_t *proc = th->proc;
  Stack_t *callinfoStack = th->callinfoStack;
  unsigned int regstate = 0;
  int i, j, lastUnused, done;
  mem_t topModifiedStack;              /* Top of the modified part of the stack */
  mem_t topModifiedFrame;              /* Top frame of the modified part of the stack */
  mem_t curFrame;

  TotalStackSize += topStack - botStack;

  /* Starting from the top of the stack, find the last unmodified segment */
  for (lastUnused = -1; lastUnused < th->last_snapshot; lastUnused++) {
    if (th->snapshots[lastUnused+1].saved_ra == 0)             /* Segment was modified by function return */
      break;
    if (th->maxSP >= th->snapshots[lastUnused+1].saved_sp)     /* Segment modified due to exceptions */
      break;
  }
  th->maxSP = 0;
  th->last_snapshot = lastUnused;

  /* Add the previously recorded root lists of unmodified segments.  
     Use the register state and stack frame bottom of the last segment. */
  topModifiedStack = topStack;
  for (i=0; i<=th->last_snapshot; i++) {
    Stack_t *r = th->snapshots[i].roots;
    copyStack(r,allRoots);
    regstate = th->snapshots[th->last_snapshot].saved_regstate;
    topModifiedStack = (mem_t) th->snapshots[th->last_snapshot].saved_sp;
  }
  assert(botStack <= topModifiedStack);
  assert(topModifiedStack <= topStack);

  /* Find return addresses of the modified portion of the stack. Update statistics. */
  { 
    int predone = save_rate * (th->last_snapshot+1);
    int numNewFrames, curstack_depth;
    val_t curRA = botRetAdd;
    mem_t curFrame = botStack;

    (void) findretadd(th,&curFrame,&curRA,topModifiedStack,callinfoStack,MAXINT);
    topModifiedFrame = curFrame;
    numNewFrames = lengthStack(callinfoStack);
    TotalNewStackDepth += numNewFrames;
    curstack_depth = numNewFrames + predone;
    TotalStackDepth += curstack_depth;
    if (MaxStackDepth < curstack_depth) 
      MaxStackDepth = curstack_depth;
    if (debugStack)
      printf("predone/total  %d/%d/%d\n",predone,curstack_depth);
  }

  for (curFrame = topModifiedFrame, done = 0; !done; ) {
    unsigned int inner_save_rate = save_rate;
    Stack_t *r = th->snapshots[th->last_snapshot+1].roots;

    if (r == NULL) {
      r = createStack(50);
      th->snapshots[th->last_snapshot+1].roots = r;
    }
    resetStack(r);

    if (th->last_snapshot + 2 >= NUM_STACK_STUB)
      inner_save_rate = MAXINT;
    done = !trace_stack_step(th, saveregs, &curFrame, callinfoStack, topModifiedStack,
			     r, &regstate, inner_save_rate);
    copyStack(r,allRoots);
    
    if (!done) {
      StackSnapshot_t *snapshots = th->snapshots;
      Callinfo_t *callinfo = (Callinfo_t *) peekStack(callinfoStack);
      val_t next_retadd = callinfo->retadd;
      CallinfoCursor_t aCursor, *nextCursor = &aCursor;
      mem_t nextFrame, nextRAslot, stubAddr;

      resetCursor(nextCursor, callinfo);
      nextFrame = curFrame - nextCursor->frameSize;
      nextRAslot = nextFrame + nextCursor->RAQuadOffset;

      th->last_snapshot++; 
      snapshots[th->last_snapshot].roots = r;
      snapshots[th->last_snapshot].saved_regstate = regstate;
      snapshots[th->last_snapshot].saved_sp = (unsigned long) curFrame;
      snapshots[th->last_snapshot].saved_ra = *nextRAslot;
      if (debugStack) {
	printf("snapshots = %d, snapshots[th->last_snapshot]=%d,   "
	       "s[c]->saved_ra=%d,   s[c]->saved_sp=%d\n",
	       snapshots,snapshots[th->last_snapshot],
	       snapshots[th->last_snapshot].saved_ra,
	       snapshots[th->last_snapshot].saved_sp);
	printf("saving(%d): curFrame = %d   nextFrame = %d   nextRAslot = %d   *nextRAslot = %d   regstate=%d\n",
	       th->last_snapshot, curFrame, nextFrame, nextRAslot, *nextRAslot, regstate);
      }
      stubAddr = GetStackStub(th->last_snapshot);
#ifdef solaris
      *nextRAslot = (val_t) (stubAddr - 2);     /* 2 instructions removed so return works -
						    one since PC saved at call, another for delay slot */
#else
      *nextRAslot = stubAddr;
#endif
    }
  }
  
  if (debugStack)
    printf("stack_trace_gen: th->last_snapshot=%d\n",th->last_snapshot);

  return regstate;
}


void local_root_scan(Proc_t *proc, Thread_t *th)
{
  unsigned long *saveregs = (unsigned long *)(th->saveregs);
  unsigned long i;

  /* Include thunks that have not been used */
  for (i=th->nextThunk; i<th->numThunk; i++) {
    mem_t thunkAddr = &(((ptr_t)th->thunks)[i]);
    ptr_t thunk = (ptr_t) *thunkAddr;
    if (!IsTagData(thunk) && !IsGlobalData(thunk)) 
      pushStack(proc->roots,thunkAddr);
  }
  
  if (th->nextThunk != 0) {  /* thread has started */
    mem_t bottomFrame = (mem_t) saveregs[SP];
#ifdef solaris
    val_t bottomRA = ((val_t) saveregs[LINK] + 8);  /* 2 instructions added - 
						      one since PC saved at call, 
						      another for delay slot */
#else
    val_t bottomRA = saveregs[RA];
#endif
    unsigned int regMask = 0;
    mem_t topStack = GetStack(bottomFrame)->top;

    if (useGenStack)
      regMask = trace_stack_gen(th, saveregs, bottomFrame, bottomRA, topStack, proc->roots);
    else
      regMask = trace_stack_normal(proc, th, saveregs, bottomFrame, bottomRA, topStack, proc->roots);
    regMask |= 1 << EXNPTR;

    for (i=0; i<32; i++)
      if (regMask & (1 << i)) {
	ptr_t root = (ptr_t) saveregs[i];
	if (!(IsTagData(root)) && !(IsGlobalData(root))) {
	  if (debugStack)
	    printf("Register %d with value %d is a ROOT\n", i, root);
	  pushStack(proc->roots, (int *)(&(saveregs[i])));
	}
      }
  }

}

/* ----------------------------------------------------- 
   ---------------- GLOBAL STUFF ----------------------- */

static Stack_t *potentialGlobal;     
static Stack_t *potentialGlobalTemp;
static int lastModulePreprocessed;   /* last module whose globals have been entered into the potential list */
static Stack_t promotedGlobalLoc;    /* check each potential global to see if
					it has been initialized;  if so,
					remove the global from potentialGlobal
					and move all its pointers fields 
					into promotedGlobalLoc */
static Stack_t tenuredGlobalLoc;     /* accumulates the contents of promotedGlobalLoc
					across all previous calls to minor_global_promote */


void global_root_init()
{
  int mi, numGlobals = 0;  
  for (mi=0; mi<module_count; mi++) {
    mem_t start = (mem_t)((&TRACE_GLOBALS_BEGIN_VAL)[mi]);
    mem_t stop = (mem_t)((&TRACE_GLOBALS_END_VAL)[mi]);
    numGlobals += stop - start;
  }
  lastModulePreprocessed = 0;
  potentialGlobal = createStack(numGlobals);
  potentialGlobalTemp = createStack(numGlobals);
  allocStack(&promotedGlobalLoc, numGlobals);
  allocStack(&tenuredGlobalLoc, numGlobals);
}

void minor_global_scan(Proc_t *proc)
{  
  /* For each root of potentialGlobal
       (1) move to potentialTemp if it is uninitialized 
       (2) move to promotedGlobalLoc all its pointer fields if it is initialized
     Swap potentialGlobal and potentialTemp
  */
  int i, workDone = 0;
  int lastModuleStarted = (mainThread == NULL) ? module_count : mainThread->nextThunk;
  int origPromoted = lengthStack(&promotedGlobalLoc);
  
  /* Every global of a module is initialized before the next module's globlas are initialized */
  for ( ; lastModulePreprocessed<lastModuleStarted; lastModulePreprocessed++) {
    mem_t start = (mem_t)((&TRACE_GLOBALS_BEGIN_VAL)[lastModulePreprocessed]);
    mem_t stop = (mem_t)((&TRACE_GLOBALS_END_VAL)[lastModulePreprocessed]);
    workDone += stop-start;
    for ( ; start < stop; start++) {
      mem_t global = (mem_t) (*start);
      pushStack(potentialGlobal, global);
    }
  }
  workDone += lengthStack(potentialGlobal);
  while (!isEmptyStack(potentialGlobal)) {
    mem_t global = (mem_t) popStack(potentialGlobal);
    tag_t tag = global[-1];
    if (GET_TYPE(tag) == SKIP_TYPE)
      pushStack(potentialGlobalTemp, global);
    else 
      workDone += getNontagNonglobalPointerLocations(global, &promotedGlobalLoc);
  }
  typed_swap(Stack_t *, potentialGlobal, potentialGlobalTemp);
  copyStack(&promotedGlobalLoc, proc->roots);
  proc->segUsage.rootsProcessed += workDone;
}

/* Transfers items from promotedGlobalLoc to tenuredGlobalLoc */
void minor_global_promote()
{
  transferStack(&promotedGlobalLoc, &tenuredGlobalLoc);
}

void major_global_scan(Proc_t *proc)
{
  minor_global_scan(proc);
  minor_global_promote();
  assert(isEmptyStack(&promotedGlobalLoc));
  copyStack(&tenuredGlobalLoc, proc->roots);
}

