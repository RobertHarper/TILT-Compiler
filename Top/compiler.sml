(* Interface to the compiler. *)
(*
	The file cache raises Reject when magic numbers do not match
	up.  This happens, for example, when the user tries to use
	libraries generated by a different version of the compiler.

	N.B.  We reset the label counter to make the elaborator more
	deterministic.  Fresh labels must be chosen to account for SML
	shadowing and these sometimes make it into compilation unit
	interfaces.  We want to choose the same labels each time to
	ensure that if a unit's source code and evaluation context
	does not change, then the compiler will infer the same
	interface every time it elaborates the unit.
*)

structure Compiler :> COMPILER =
struct

    val error = fn s => Util.error "compiler.sml" s

    val CompilerDebug = Stats.ff "CompilerDebug"
    fun debugdo (f : unit -> 'a) : unit =
	if (!CompilerDebug) then (f(); ()) else ()

    val CompilerDiag = Stats.ff "CompilerDiag"
    fun msg str = if (!CompilerDiag) then print str else ()

    val LinkIlDiag = LinkIl.LinkIlDiag
    fun elab_msg str = if (!LinkIlDiag) then print str else ()

    exception Reject of string
    structure UE = UnitEnvironment

    structure FileCache =
    struct

	datatype name =
	    NAME_UE of string
	  | NAME_IFACE of string
	  | NAME_INFO of string

	fun filename (n : name) : string =
	    (case n
	       of NAME_UE s => s
		| NAME_IFACE s => s
		| NAME_INFO s => s)

	datatype internal =
	    UE of UE.ue
	  | IFACE of LinkIl.pinterface
	  | INFO of Info.info

	fun bad (file : string) : 'a =
	    raise Reject ("bad magic number in " ^ file)

	fun reader name : internal =
	    (case name
	       of NAME_UE file =>
		   UE (File.read UE.blastInUe file)
		| NAME_IFACE file =>
		   IFACE (File.read LinkIl.blastInPinterface file)
		| NAME_INFO file =>
		   INFO (File.read Info.blastInInfo file))
	    handle Blaster.BadMagicNumber => bad (filename name)

	fun writer (file : string, i : internal) : unit =
	    (case i
	       of UE ue => File.write UE.blastOutUe file ue
		| IFACE iface =>
		   File.write LinkIl.blastOutPinterface file iface
		| INFO info =>
		   File.write Info.blastOutInfo file info)
	    handle Blaster.BadMagicNumber => bad file

	structure Cache =
	FileCache (type name = name
		   type internal = internal
		   val filename = filename
		   val reader = reader
		   val writer = writer)

	fun mismatch (file : string) : 'a =
	    error ("file type mismatch with " ^ file)

	fun read_ue (file : string) : UE.ue =
	    (case Cache.read (NAME_UE file)
	       of UE ue => ue
		| _ => mismatch file)

	fun write_ue (file : string, ue : UE.ue) : unit =
	    Cache.write (file, UE ue)

	fun read_iface (file : string) : LinkIl.pinterface =
	    (case Cache.read (NAME_IFACE file)
	       of IFACE iface => iface
		| _ => mismatch file)

	fun write_iface (file : string,
			 iface : LinkIl.pinterface) : unit =
	    Cache.write (file, IFACE iface)

	fun read_info (file : string) : Info.info =
	    (case Cache.read (NAME_INFO file)
	       of INFO info => info
		| _ => mismatch file)

	fun write_info (file : string, info : Info.info) : unit =
	    Cache.write (file, INFO info)

	open Cache
    end

    structure LS = Name.LabelSet

    val timestamp = Timestamp.timestamp

    (*
	Invariant: If f : iface, then f names an up-to-date
	parameterized interface file.
    *)
    type file = string
    type iface = file
    type unitname = string
    type imports = unitname list
    (*
	Invariant: If L : precontext, then
	1. No two units have the same name.
	2. L is ordered so that each interface's parameters precede it.
    *)
    type precontext = (unitname * iface) list

    type pinterface = LinkIl.pinterface
    type interface = LinkIl.interface

    type context = LinkIl.context
    type il_module = LinkIl.module
    type nil_module = Nil.module
    type rtl_module = Rtl.module

    local
	fun parser (f : string * string -> 'a option)
		   (what : string, file : string) : 'a =
	    (case f (what,file)
	       of NONE => raise Reject ("could not parse " ^ file)
		| SOME r => r)
    in
	val parse_impl = parser LinkParse.parse_impl
	val parse_inter = parser LinkParse.parse_inter
    end

    fun instantiate (ctxt : context, iface : iface) : pinterface * interface =
	let val pi = FileCache.read_iface iface
	in  (case LinkIl.instantiate (ctxt,pi)
	       of SOME i => (pi,i)
		| NONE => error ("could not instantiate " ^ iface))
	end

    fun context' (precontext : precontext) : context =
	let
	    fun add_unit ((name,iface) : unitname * iface,
			  ctxt : context) : context =
		let val l = LinkIl.unitlabel name
		    val (_,i) = instantiate (ctxt,iface)
		in  LinkIl.add_unit (ctxt, l, i)
		end
	    val ctxt = foldl add_unit LinkIl.empty precontext
	    val _ = FileCache.tick()
	in  ctxt
	end

    fun context (precontext : precontext) : context =
	let val _ = elab_msg ("  Making elaboration context with " ^
			      Int.toString (length precontext) ^
			      " interfaces\n")
	    val ctxt = context' precontext
	in  ctxt
	end

    fun print_list (L : 'a list, what : string, f : 'a -> string) : unit =
	let val _ = print (what ^ " = ")
	    val _ = if null L then print "(empty)\n"
		    else print ("(" ^ Int.toString (length L) ^ " items)\n")
	in  app (fn x => print ("\t" ^ f x ^ "\n")) L
	end

    fun print_precontext precontext : unit =
	 print_list (precontext,"precontext",fn (u,i) => u ^ " : " ^ i )

    fun print_imports imports : unit =
	print_list (imports,"imports",fn i => i)

    fun eq (unit : unitname, precontext, i1 : iface, i2 : iface) : bool =
	let val _ = debugdo
		(fn () =>
		 (print "---- Compiler.eq called\n";
		  print ("iface1 = " ^ i1 ^ "\n");
		  print ("iface2 = " ^ i2 ^ "\n");
		  print_precontext precontext))
	    val ctxt = context precontext
	    val (_,i1) = instantiate (ctxt,i1)
	    val (_,i2) = instantiate (ctxt,i2)
	in  LinkIl.eq (ctxt,i1,i2)
	end

    fun writeUe (ueTarget : file, pctxt : precontext, ctxt : context,
		 parms : LS.set) : unit =
	let val slice = LinkIl.slice (ctxt, parms)
	    fun mapper (unitname, iface) : (string * Crc.crc) option =
		let val l = LinkIl.unitlabel unitname
		in  if LS.member(slice,l)
		    then SOME (unitname, FileCache.crc iface)
		    else NONE
		end
	    val unit_crcs = List.mapPartial mapper pctxt
	    fun add ((name,crc), ue) = UE.insert(ue,name,crc)
	    val ue = foldl add UE.empty unit_crcs
	in  FileCache.write_ue (ueTarget, ue)
	end

    (*
	Does not assume the file exists and can be instantiated.
    *)
    fun oldIfaceOk (ctxt : context, iface : file, i : pinterface) : bool =
	(FileCache.exists iface andalso
	 (case (LinkIl.instantiate (ctxt, FileCache.read_iface iface),
		LinkIl.instantiate (ctxt, i))
	    of (SOME i', SOME i) => LinkIl.eq (ctxt,i,i')
	     | (_, NONE) => error "new interface bad"
	     | _ => false))

    fun writeIface (pctxt : precontext, ctxt : context,
		    iface : file, ue : file, i : pinterface) : bool =
	let val write = not (oldIfaceOk (ctxt, iface, i))
	    val _ = if write then
			(elab_msg "  Writing interface\n";
			 FileCache.write_iface (iface, i);
			 writeUe (ue, pctxt, ctxt, LinkIl.parameters i))
		    else ()
	in  write
	end

    fun elaborate_srci {precontext : precontext,
			imports : imports,
			ifacename : string,
			source : file,
			ifaceTarget : file,
			ueTarget : file} : unit =
	let val _ = debugdo
		(fn () =>
		 (print "---- Compiler.elaborate_srci called\n";
		  print ("name = " ^ ifacename ^ "\n");
		  print ("source = " ^ source ^ "\n");
		  print ("iface = " ^ ifaceTarget ^ "\n");
		  print_precontext precontext;
		  print_imports imports))
	    val _ = timestamp()
	    val _ = Name.reset_label_counter()
	    val (fp,specs) = parse_inter (ifacename,source)
	    val _ = msg ("===== Elaborating interface: " ^ ifacename ^
			 " =====\n")
	    val ctxt = context precontext
	    val imports = map LinkIl.unitlabel imports
	    val pi = (case LinkIl.elab_specs (ctxt,imports,fp,specs)
			of NONE => raise Reject(source ^ " failed to elaborate")
			 | SOME pi => pi)
	in  ignore (writeIface (precontext, ctxt, ifaceTarget, ueTarget, pi))
	end

    fun elaborate_primu {precontext : precontext,
			 imports : imports,
			 unitname : unitname,
			 ifaceTarget : file,
			 ueTarget : file} : il_module * bool =
	let val _ = debugdo
		(fn () =>
		 (print "---- Compiler.elaborate_primu called\n";
		  print ("name = " ^ unitname ^ "\n");
		  print ("iface = " ^ ifaceTarget ^ "\n");
		  print ("ue = " ^ ueTarget ^ "\n");
		  print_precontext precontext;
		  print_imports imports))
	    val _ = timestamp()
	    val _ = Name.reset_label_counter()
	    val _ = msg ("===== Elaborating unit: " ^ unitname ^ " =====\n")
	    val ctxt = context precontext
	    val imports = map LinkIl.unitlabel imports
	    val unitname' = LinkIl.unitlabel unitname
	    val (m,pi) = LinkIl.tiltprim (ctxt,unitname',imports)
	    val written = writeIface (precontext, ctxt, ifaceTarget, ueTarget, pi)
	in  (m, written)
	end

    fun elaborate_srcu {precontext : precontext,
			imports : imports,
			unitname : unitname,
			source : file,
			ifaceTarget : file,
			ueTarget : file} : il_module * bool =
	let val _ = debugdo
		(fn () =>
		 (print "---- Compiler.elaborate_srcu called\n";
		  print ("name = " ^ unitname ^ "\n");
		  print ("source = " ^ source ^ "\n");
		  print ("iface = " ^ ifaceTarget ^ "\n");
		  print ("ue = " ^ ueTarget ^ "\n");
		  print_precontext precontext;
		  print_imports imports))
	    val _ = timestamp()
	    val _ = Name.reset_label_counter()
	    val (fp,dec) = parse_impl (unitname,source)
	    val _ = msg ("===== Elaborating unit: " ^ unitname ^ " =====\n")
	    val ctxt = context precontext
	    val imports = map LinkIl.unitlabel imports
	    val unitname' = LinkIl.unitlabel unitname
	    val (m,pi) = (case LinkIl.elab_dec (ctxt,unitname',imports,fp,dec)
			    of NONE =>
				raise Reject(source ^ " failed to elaborate")
			     | SOME r => r)
	    val written = writeIface (precontext, ctxt, ifaceTarget, ueTarget, pi)
	in  (m, written)
	end

    fun elaborate_srcu' {precontext : precontext,
			 imports : imports,
			 unitname : unitname,
			 source : file,
			 interface : iface} : il_module =
	let val _ = debugdo
		(fn () =>
		 (print "---- Compiler.elaborate_srcu' called\n";
		  print ("name = " ^ unitname ^ "\n");
		  print ("source = " ^ source ^ "\n");
		  print ("constraint = " ^ interface ^ "\n");
		  print_precontext precontext;
		  print_imports imports))
	    val _ = timestamp()
	    val _ = Name.reset_label_counter()
	    val (fp,dec) = parse_impl (unitname,source)
	    val _ = msg ("===== Elaborating unit: " ^ unitname ^ " =====\n")
	    val ctxt = context precontext
	    val imports = map LinkIl.unitlabel imports
	    val unitname' = LinkIl.unitlabel unitname
	    val (m,pi) = (case LinkIl.elab_dec (ctxt,unitname',imports,fp,dec)
			    of NONE =>
				raise Reject(source ^ " failed to elaborate")
			     | SOME r => r)
	    val (pi,i) = instantiate (ctxt,interface)
	in  (case LinkIl.seal (ctxt, m, i)
	       of NONE =>
		   raise Reject (source ^ " does not match " ^ interface)
		| SOME m => m)
	end

    val il_to_nil : unitname * il_module -> nil_module
	= Linknil.il_to_nil

    fun nil_to_rtl (arg : unitname * nil_module) : rtl_module =
	(timestamp(); Linkrtl.nil_to_rtl arg)

    (*
	RTL parameters are more specific than unit names.
    *)
    fun unitnames (pctxt : precontext, parms : LS.set) : LS.set =
	let
	    fun mapper (unitname, _) : Il.label option =
		let val l = LinkIl.unitlabel unitname
		    val (c,r) = Name.make_cr_labels l
		in  if (LS.member(parms,l) orelse
			LS.member(parms,c) orelse
			LS.member(parms,r))
		    then SOME l
		    else NONE
		end
	in  LS.addList (LS.empty,List.mapPartial mapper pctxt)
	end

    fun rtl_to_asm {precontext : precontext,
		    asmTarget : file,
		    ueTarget : file,
		    rtl_module : rtl_module} : unit =
	let val _ = debugdo
		(fn () =>
		 (print "---- Compiler.rtl_to_asm called\n";
		  print ("asm = " ^ asmTarget ^ "\n");
		  print ("ue = " ^ ueTarget ^ "\n");
		  print_precontext precontext))
	    val _ = timestamp()
	    val toasm = (case Target.getTargetPlatform ()
			   of Target.TIL_ALPHA => Linkalpha.rtl_to_asm
			    | Target.TIL_SPARC => Linksparc.rtl_to_asm)
	    val Rtl.MODULE {parms, ...} = rtl_module
	    val ctxt = context precontext
	    val parms = unitnames (precontext,parms)
	    val _ = writeUe (ueTarget, precontext, ctxt, parms)
	    fun writer asm = toasm(asm, rtl_module)
	in  File.write' writer asmTarget
	end

    fun link {asmTarget : file, unitnames : unitname list} : unit =
	let val _ = timestamp()
	    val link = (case Target.getTargetPlatform()
			  of Target.TIL_ALPHA => Linkalpha.link
			   | Target.TIL_SPARC => Linksparc.link)
	    fun writer asm = link {asmFile=asm, units=unitnames}
	in  File.write' writer asmTarget
	end

end
