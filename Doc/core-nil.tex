%% This LaTeX-file was created by <leaf> Mon Oct  5 17:43:36 1998
%% LyX 0.12 (C) 1995-1998 by Matthias Ettrich and the LyX Team

%% Do not edit this file unless you know what you are doing.
\documentclass{article}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\newcommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\spacefactor1000}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
  {\begin{list}{}
    {\settowidth{\labelwidth}{#1}
     \setlength{\leftmargin}{\labelwidth}
     \addtolength{\leftmargin}{\labelsep}
     \renewcommand{\makelabel}[1]{##1 \hfill}}}
  {\end{list}}

\makeatother

\begin{document}


\newcommand{\Lam}[3]{\lambda #1 ::#2 .#3 }
 
\newcommand{\Let}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}
 
\newcommand{\lete}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}

\newcommand{\rec}[7]{\mathrm{rec}\, #1 =\lambda (#2 ::#3 ,#4 :#5 ):#6 .#7 }

\newcommand{\ifz}[3]{\mathrm{ifzero}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }

\newcommand{\st}[1]{S_{T}(#1 )}

\newcommand{\subst}[3]{\{#1 /#2 \}#3 }

\newcommand{\context}{\Delta }

\newcommand{\addk}[3]{#1 [#2 ::#3 ]}

\newcommand{\addt}[3]{#1 [#2 :#3 ]}

\newcommand{\caddk}[2]{\addk{\context }{#1 }{#2 }}

\newcommand{\caddt}[2]{\addt{\context }{#1 }{#2 }}

\newcommand{\extk}[2]{[#1 ::#2 ]}

\newcommand{\extt}[2]{[#1 :#2 ]}

\newcommand{\iffloat}[3]{\mathrm{ifFloat}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }
 


\title{Core Nil}


\author{Leaf Petersen}

\maketitle

\section{Syntax}


\begin{eqnarray*}
\kappa  & ::= & T\: |\: \st{c}\: |\: \Sigma (\alpha ::\kappa ).\kappa \: |\: \Pi (\alpha ::\kappa ).\kappa \\
 &  & \\
c & ::= & \alpha \mid Int\mid BoxFloat\mid \mu (a=c,b=c)\mid c\times c\mid c\rightarrow c\mid \Lam{\alpha }{\kappa }{c}\\
 &  & \mid c\, c\mid <c,c>\mid c.1\mid c.2\mid \Let{\alpha }{c}{c}\\
 &  & \\
\tau  & ::= & c\mid (\alpha ::\kappa ,\tau )\rightarrow \tau \mid Float\mid \tau \times \tau \\
 &  & \\
p & ::= & \alpha \mid p.1\mid p.2\mid p\, c\\
 &  & \\
e & ::= & x\mid \lete{x}{e}{e}\mid \lete{\alpha }{c}{e}\mid \rec{f}{\alpha }{\kappa }{x}{\tau }{\tau }{e}\\
 &  & \mid e[c]e\mid <e,e>\mid e.1\mid e.2\mid n\mid r\mid box(e)\mid unbox(e)\\
 &  & \mid \ifz{e}{e}{e}\mid \iffloat{\tau }{e}{e}\\
 &  & \\
\Delta  & ::= & \bullet \mid \caddt{x}{\tau }\mid \caddk{\alpha }{\kappa }
\end{eqnarray*}



\section{Judgements for the algorithmic core nil}


\newcommand{\infrule}[2]{\frac{#1 }{#2 }}

\newcommand{\axiom}[1]{\overline{#1 }}



\newcommand{\kindvalid}[2]{#1 \vdash #2 }

\newcommand{\kindsynth}[3]{#1 \vdash #2 \Uparrow #3 }

\newcommand{\subkind}[3]{#1 \vdash #2 \preceq #3 }

\newcommand{\conequiv}[4]{#1 \vdash #2 \equiv #3 ::#4 }

\newcommand{\coneq}[3]{\conequiv{\context }{#1 }{#2 }{#3 }}
 
\newcommand{\typevalid}[2]{#1 \vdash #2 }

\newcommand{\typev}[1]{\typevalid{\Delta }{#1 }}



\newcommand{\typesynth}[3]{#1 \vdash #2 \Uparrow #3 }

\newcommand{\types}[2]{\typesynth{\context }{#1 }{#2 }}

\newcommand{\typeequiv}[3]{#1 \vdash #2 \equiv #3 }

\newcommand{\typeeq}[2]{\typeequiv{\context }{#1 }{#2 }}

\newcommand{\hnf}[3]{#1 \vdash #2 \Longrightarrow #3 }

\newcommand{\Hnf}[2]{\hnf{\context }{#1 }{#2 }}

\newcommand{\pathextract}[3]{#1 \vdash #2 \sim #3 }

\newcommand{\pext}[2]{\pathextract{\context }{#1 }{#2 }}

\newcommand{\cok}[1]{#1 \, \mathrm{ok}}

\newcommand{\selfify}[3]{#1 ::#2 =#3 }

\newcommand{\kcheck}[3]{#1 \vdash #2 \Downarrow #3 }



\subsection{Well Formed Context }

\begin{lyxlist}{00.00.0000}
\item [Empty]
\[
\axiom{\cok{\bullet }}\]

\item [Kind]
\[
\infrule{\begin{array}{ll}
\cok{\context } & \kindvalid{\context }{\kappa }
\end{array}}{\cok{\caddk{\alpha }{\kappa }}}\alpha \notin dom(\context )\]

\item [Type]
\[
\infrule{\begin{array}{ll}
\cok{\context } & \typevalid{\context }{\tau }
\end{array}}{\cok{\caddt{x}{\tau }}}x\notin dom(\context )\]

\end{lyxlist}

\subsection{Well Formed Kind }

Assume \( \Delta  \) is well-formed. Check that \( \kappa  \) is well-formed

\begin{lyxlist}{00.00.0000}
\item [Type]
\[
\axiom{\kindvalid{\Delta }{T}}\]

\item [Singleton]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c}{\kappa } & \subkind{\context }{\kappa }{T}
\end{array}}{\kindvalid{\Delta }{\st{c}}}\]

\item [Pi]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa _{1}} & \kindvalid{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}
\end{array}}{\kindvalid{\Delta }{\Pi (\alpha ::\kappa _{1}).k_{2}}}\quad \alpha \notin dom(\Delta )\]

\item [Sigma]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa _{1}} & \kindvalid{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}
\end{array}}{\kindvalid{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}\quad \alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Sub-Kinding \protect\( \subkind{\Delta }{\kappa _{1}}{\kappa _{2}}\protect \)}

Assume that \( \Delta  \), \( \kappa _{1} \) and \( \kappa _{2} \) are well-formed.
Check that \( \kappa _{1} \) is a subkind of \( \kappa _{2} \).

\begin{lyxlist}{00.00.0000}
\item [Type]
\[
\axiom{\subkind{\Delta }{T}{T}}\]

\item [Singleton]
\[
\axiom{\subkind{\Delta }{\st{c}}{T}}\]

\item [Singletons]
\[
\infrule{\conequiv{\Delta }{c}{d}{T}}{\subkind{\Delta }{\st{c}}{\st{d}}}\]

\item [\( \Pi  \)]
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}'}{\kappa _{1}} & \subkind{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\item [\( \Sigma  \)]
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}}{\kappa _{1}'} & \subkind{\Delta [\alpha ::\kappa _{1}']}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Selfification \protect\( \selfify{c}{\kappa }{\kappa '}\protect \)}

\begin{lyxlist}{00.00.0000}
\item [Type]
\[
\axiom{\selfify{c}{T}{\st{c}}}\]

\item [Singleton]
\[
\axiom{c::\st{d}=\st{d}}\]

\item [\( \Pi  \)]
\[
\infrule{\selfify{c\, \alpha }{\kappa _{2}}{\kappa _{2}'}}{\selfify{c}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}'}}\]

\item [\( \Sigma  \)]
\[
\infrule{\begin{array}{ll}
\selfify{c.1}{\kappa _{1}}{\kappa _{1}'} & \selfify{c.2}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\selfify{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'}}\]

\end{lyxlist}

\subsection{Kind Analysis \protect\( \kcheck{\context }{c}{\kappa }\protect \)}

Assume \( \context  \) and \( \kappa  \) are well formed. Check that \( c \)
is well formed and can be given kind \( \kappa  \).


\[
\infrule{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa '} & \subkind{\context }{\kappa '}{\kappa }
\end{array}}{\kcheck{\context }{c}{\kappa }}\]



\subsection{Kind Synthesis \protect\( \kindsynth{\Delta }{c}{\kappa }\protect \)}

Assumes that \( \Delta  \) is well-formed. Check that c is well-kinded, and
construct \( \kappa  \) s.t. \( \kindvalid{\Delta }{\kappa } \) and c has
kind \( \kappa  \)

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\infrule{\selfify{\alpha }{\kappa }{\kappa '}}{\kindsynth{\Delta [\alpha ::\kappa ]}{\alpha }{\kappa }'}\]

\item [Weakening1]
\[
\infrule{\kindsynth{\context }{\alpha }{\kappa }}{\kindsynth{\caddk{\alpha '}{\kappa '}}{\alpha }{\kappa }}\]

\item [Weakening2]
\[
\infrule{\kindsynth{\context }{\alpha }{\kappa }}{\kindsynth{\caddt{x}{\tau }}{\alpha }{\kappa }}\]

\item [Int]
\[
\axiom{\kindsynth{\Delta }{Int}{\st{Int}}}\]

\item [BoxFloat]
\[
\axiom{\kindsynth{\Delta }{BoxFloat}{\st{BoxFloat}}}\]

\item [\( \mu  \)]
\[
\infrule{\begin{array}{ll}
\kcheck{\Delta [a::T,b::T]}{c_{1}}{T} & \kcheck{\Delta [a::T,b::T]}{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{\mu (a=c_{1},b=c_{2})}{\st{\mu (a=c_{1},b=c_{2}).1}\times \st{\mu (a=c_{1},b=c_{2}).2}}}a,b\notin dom(\Delta )\]
 
\item [Pair]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\times c_{2}}{\st{c_{1}\times c_{2}}}}\]

\item [Arrow]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\rightarrow c_{2}}{\st{c_{1}\rightarrow c_{2}}}}\]

\item [Lambda]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa } & \kindsynth{\Delta [\alpha ::\kappa ]}{c}{\kappa '}
\end{array}}{\kindsynth{\Delta }{\Lam{\alpha }{\kappa }{c}}{\Pi (\alpha ::\kappa ).\kappa '}}\alpha \notin dom(\Delta )\]

\item [App]
\[
\infrule{\begin{array}{cc}
\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & \kcheck{\context }{c_{2}}{\kappa _{1}}
\end{array}
\end{array}}{\kindsynth{\Delta }{c_{1}\, c_{2}}{\subst{c_{2}}{\alpha }{\kappa _{2}}}}\]

\item [Record]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta }{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{<c_{1},c_{2}>}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}\alpha \notin fv(\kappa _{2})\]

\item [Proj1]
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.1}{\kappa _{1}}}\]

\item [Proj2]
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}}\]

\item [Let]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta [\alpha ::\kappa _{1}]}{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{\Let{\alpha }{c_{1}}{c_{2}}}{\subst{c_{1}}{\alpha }{\kappa _{2}}}}\alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Well-formed Type \protect\( \typev{\tau }\protect \)}

Assume \( \context  \) is well-formed. Check that \( \tau  \) is well-formed.

\begin{lyxlist}{00.00.0000}
\item [Constructor]
\[
\frac{\kcheck{\context }{c}{T}}{\typev{c}}\]

\item [ArrowType]
\[
\frac{\begin{array}{ll}
\kindvalid{\context }{\kappa } & \\
\typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}
\end{array}}{\typev{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\alpha \notin dom(\context )\]

\item [Float]
\[
\axiom{\typev{Float}}\]

\item [PairType]
\[
\frac{\begin{array}{ll}
\typev{\tau _{1}} & \typev{\tau _{2}}
\end{array}}{\typev{\tau _{1}\times \tau _{2}}}\]

\end{lyxlist}

\subsection{Type Synthesis \protect\( \types{e}{\tau }\protect \)}

Assume \( \context  \) is well-formed. Check that \( e \) is well-formed and
construct its type \( \tau  \), where \( \typev{\tau } \)

\begin{lyxlist}{00.00.0000}
\item [variable]
\[
\axiom{\typesynth{\caddt{x}{\tau }}{x}{\tau }}\]

\item [weakening1]
\[
\infrule{\types{x}{\tau }}{\typesynth{\caddt{x'}{\tau '}}{x}{\tau }}\]

\item [weakening2]
\[
\infrule{\types{x}{\tau }}{\typesynth{\caddk{\alpha }{\kappa }}{x}{\tau }}\]

\item [lete]
\[
\frac{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \typesynth{\caddt{x}{\tau _{1}}}{e_{2}}{\tau _{2}}
\end{array}}{\types{\lete{x}{e_{1}}{e_{2}}}{\tau _{2}}}x\notin dom(\context )\]

\item [letc]
\[
\frac{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa } & \typesynth{\caddk{\alpha }{\kappa }}{e}{\tau }
\end{array}}{\types{\lete{\alpha }{c}{e}}{\subst{c}{\alpha }{\tau }}}\alpha \notin dom(\context )\]

\item [rec]
\[
\infrule{\begin{array}{lll}
\kindvalid{\context }{\kappa } & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}\\
\typesynth{\context \extt{f}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}\extk{\alpha }{\kappa }\extt{x}{\tau _{1}}}{e}{\tau _{2}'} & \typeequiv{\caddk{\alpha }{\kappa }}{\tau _{2}}{\tau _{2}'} & f,\alpha ,x\notin dom(\context )
\end{array}}{\types{\rec{f}{\alpha }{\kappa }{x}{\tau _{1}}{\tau _{2}}{e}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\]

\item [app]
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}} &  & \kcheck{\context }{c}{\kappa }\\
\types{e_{2}}{\tau _{1}'} &  & \typeeq{\tau _{1}'}{\subst{c}{\alpha }{\tau _{1}}}
\end{array}}{\types{e_{1}[c]e_{2}}{\subst{c}{\alpha }{\tau _{2}}}}\]

\item [app2]
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{c_{e}} & \hnf{\context }{c_{e}}{c_{1}\rightarrow c_{2}} & \\
\types{e_{2}}{c_{1}'} & \coneq{c_{1}}{c_{1}'}{T} & 
\end{array}}{\types{e_{1}\, e_{2}}{c_{2}}}\]

\item [pair]
\[
\infrule{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \types{e_{2}}{\tau _{2}}
\end{array}}{\types{<e_{1},e_{2}>}{\tau _{1}\times \tau _{2}}}\]

\item [type\_proj1]
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}} & 
\end{array}}{\types{e.1}{\tau _{1}}}\]

\item [con\_proj1]
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.1}{c_{1}}}\]

\item [type\_proj2]
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}} & 
\end{array}}{\types{e.2}{\tau _{2}}}\]

\item [con\_proj2]
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.2}{c_{2}}}\]

\item [integer]
\[
\axiom{\types{n}{Int}}\]

\item [float]
\[
\axiom{\types{r}{Float}}\]

\item [box]
\[
\infrule{\types{e}{Float}}{\types{box(e)}{BoxFloat}}\]

\item [unbox]
\[
\infrule{\types{e}{BoxFloat}}{\types{unbox(e)}{Float}}\]

\item [ifzero]
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{Int}\\
\types{e_{1}}{\tau _{1}} & \types{e_{2}}{\tau _{2}}\\
\typeeq{\tau _{1}}{\tau _{2}} & 
\end{array}}{\types{\ifz{e}{e_{1}}{e_{2}}}{\tau _{1}}}\]

\item [ifFloat]
\[
\infrule{\begin{array}{ll}
\typev{\tau } & \types{e_{1}}{\tau _{1}}\\
\types{e_{2}}{\tau _{2}} & \typeeq{\tau _{1}}{\tau _{2}}
\end{array}}{\types{\iffloat{\tau }{e_{1}}{e_{2}}}{\tau _{1}}}\]

\end{lyxlist}

\subsection{Path Extraction \protect\( \pext{p}{\kappa }\protect \)}

Assumes that \( \Delta  \) and \( p \) are well-formed. Returns the unselfified
kind of \( p \). 

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\axiom{\pathextract{\caddk{\alpha }{\kappa }}{\alpha }{\kappa }}\]

\item [Weakening1]
\[
\infrule{\pext{\alpha }{\kappa }}{\pathextract{\caddk{\alpha '}{\kappa '}}{\alpha }{\kappa }}\]

\item [Weakening2]
\[
\infrule{\pext{\alpha }{\kappa }}{\pathextract{\caddt{x}{\tau }}{\alpha }{\kappa }}\]

\item [Proj1]
\[
\infrule{\begin{array}{ll}
\pext{p}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p.1}{\kappa _{1}}}\]

\item [Proj2]
\[
\infrule{\begin{array}{ll}
\pext{p}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p.2}{K(\subst{p.1}{\alpha }{\kappa _{2}})}}\]

\item [App]
\[
\infrule{\begin{array}{ll}
\pext{p}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p\, c}{\subst{c}{\alpha }{\kappa _{2}}}}\]

\end{lyxlist}

\subsection{Constructor Head Normal Form \protect\( \hnf{\context }{c}{c'}\protect \)}

Assumes that \( \Delta  \) and \( c \) are well-formed. Returns the head normal
form of \( c \). 

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\infrule{\pext{x}{c}}{\hnf{\context }{x}{c}}\]

\item [Int]
\[
\axiom{\hnf{\context }{Int}{Int}}\]

\item [BoxFloat]
\[
\axiom{\hnf{\context }{BoxFloat}{BoxFloat}}\]

\item [\( \mu  \)]
\[
\axiom{\Hnf{\mu (a=c_{1},b=c_{2})}{\mu (a=c_{1},b=c_{2})}}\]
 
\item [Pair]
\[
\axiom{\Hnf{c_{1}\times c_{2}}{c_{1}\times c_{2}}}\]

\item [Arrow]
\[
\axiom{\Hnf{c_{1}\rightarrow c_{2}}{c_{1}\rightarrow c_{2}}}\]

\item [Lambda]
\[
\axiom{\Hnf{\Lam{\alpha }{\kappa }{c}}{\Lam{\alpha }{\kappa }{c}}}\]

\item [App]
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{\lambda \alpha ::\kappa .c} & \Hnf{\subst{c_{2}}{\alpha }{c}}{c'}
\end{array}}{\Hnf{c_{1}\, c_{2}}{c'}}\]

\item [App\( \sim  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c_{2}}{\st{c}}\\
\hnf{\context }{c}{c'} & 
\end{array}}{\Hnf{c_{1}\, c_{2}}{c'}}\]

\item [App\( \sim \kappa  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c_{2}}{\kappa }
\end{array}}{\Hnf{c_{1}\, c_{2}}{p\, c_{2}}}\]
\\
where \( \kappa  \) is not a singleton
\item [Record]
\[
\axiom{\Hnf{<c_{1},c_{2}>}{<c_{1},c_{2}>}}\]

\item [Proj1]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c_{1}}{c_{1}'}
\end{array}}{\Hnf{c.1}{c_{1}'}}\]

\item [Proj1\( \sim  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c.1}{c''}}\]

\item [Proj1\( \sim \kappa  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{\kappa }
\end{array}}{\Hnf{c.1}{p.1}}\]
\\
where \( \kappa  \) is not a singleton
\item [Proj2]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c}{c_{2}'}
\end{array}}{\Hnf{c.1}{c_{2}'}}\]

\item [Proj2\( \sim  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c.2}{c''}}\]

\item [Proj2\( \sim \kappa  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{\kappa }
\end{array}}{\Hnf{c.2}{p.2}}\]
\\
where \( \kappa  \) is not a singleton
\item [Let]
\[
\infrule{\Hnf{\subst{c_{1}}{\alpha }{c_{2}}}{c}}{\Hnf{\Let{\alpha }{c_{1}}{c_{2}}}{c}}\]

\end{lyxlist}
\end{document}
