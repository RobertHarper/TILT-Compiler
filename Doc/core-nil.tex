%% This LaTeX-file was created by <leaf> Thu Oct  1 18:04:27 1998
%% LyX 0.12 (C) 1995-1998 by Matthias Ettrich and the LyX Team

%% Do not edit this file unless you know what you are doing.
\documentclass{article}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\newcommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\spacefactor1000}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
  {\begin{list}{}
    {\settowidth{\labelwidth}{#1}
     \setlength{\leftmargin}{\labelwidth}
     \addtolength{\leftmargin}{\labelsep}
     \renewcommand{\makelabel}[1]{##1 \hfill}}}
  {\end{list}}

\makeatother

\begin{document}


\newcommand{\Lam}[3]{\lambda #1 ::#2 .#3 }
 
\newcommand{\Let}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}
 
\newcommand{\lete}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}

\newcommand{\rec}[7]{\mathrm{rec}\, #1 =\lambda (#2 ::#3 ,#4 :#5 ):#6 .#7 }

\newcommand{\ifz}[3]{\mathrm{ifzero}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }

\newcommand{\st}[1]{S_{T}(#1 )}

\newcommand{\subst}[3]{\{#1 /#2 \}#3 }

\newcommand{\context}{\Delta }

\newcommand{\addk}[3]{#1 [#2 ::#3 ]}

\newcommand{\addt}[3]{#1 [#2 :#3 ]}

\newcommand{\caddk}[2]{\addk{\context }{#1 }{#2 }}

\newcommand{\caddt}[2]{\addt{\context }{#1 }{#2 }}

\newcommand{\extk}[2]{[#1 ::#2 ]}

\newcommand{\extt}[2]{[#1 :#2 ]}

\newcommand{\iffloat}[3]{\mathrm{ifFloat}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }
 


\title{Core Nil}


\author{Leaf Petersen}

\maketitle

\section{Syntax}


\begin{eqnarray*}
\kappa  & ::= & T\: |\: \st{c}\: |\: \Sigma (\alpha ::\kappa ).\kappa \: |\: \Pi (\alpha ::\kappa ).\kappa \\
 &  & \\
c & ::= & \alpha \mid Int\mid BoxFloat\mid \mu (a=c,b=c)\mid c\times c\mid c\rightarrow c\mid \Lam{\alpha }{\kappa }{c}\\
 &  & \mid c\, c\mid <c,c>\mid c.1\mid c.2\mid \Let{\alpha }{c}{c}\\
 &  & \\
\tau  & ::= & c\mid (\alpha ::\kappa ,\tau )\rightarrow \tau \mid Float\mid \tau \times \tau \\
 &  & \\
p & ::= & \alpha \mid p.1\mid p.2\mid p\, c\\
 &  & \\
e & ::= & v\mid \lete{x}{e}{e}\mid \lete{\alpha }{c}{e}\mid \rec{f}{\alpha }{\kappa }{x}{c}{c}{e}\\
 &  & \mid e[c]e\mid <e,e>\mid e.1\mid e.2\mid n\mid r\mid box(e)\mid \ifz{e}{e}{e}\\
 &  & \mid \iffloat{\tau }{e}{e}\\
 &  & \\
\Delta  & ::= & \bullet \mid \caddk{\alpha }{\kappa }\mid \caddt{x}{\tau }
\end{eqnarray*}
 


\section{Judgements for the algorithmic core nil}


\newcommand{\infrule}[2]{\frac{#1 }{#2 }}

\newcommand{\axiom}[1]{\overline{#1 }}



\newcommand{\kindvalid}[2]{#1 \vdash #2 }

\newcommand{\kindsynth}[3]{#1 \vdash #2 \Uparrow #3 }

\newcommand{\subkind}[3]{#1 \vdash #2 \preceq #3 }

\newcommand{\conequiv}[4]{#1 \vdash #2 \equiv #3 ::#4 }

\newcommand{\coneq}[3]{\conequiv{\context }{#1 }{#2 }{#3 }}
 
\newcommand{\typevalid}[2]{#1 \vdash #2 }

\newcommand{\typev}[1]{\typevalid{\Delta }{#1 }}



\newcommand{\typesynth}[3]{#1 \vdash #2 \Uparrow #3 }

\newcommand{\types}[2]{\typesynth{\context }{#1 }{#2 }}

\newcommand{\typeequiv}[3]{#1 \vdash #2 \equiv #3 }

\newcommand{\typeeq}[2]{\typeequiv{\context }{#1 }{#2 }}

\newcommand{\hnf}[3]{#1 \vdash #2 \Longrightarrow #3 }

\newcommand{\Hnf}[2]{\hnf{\context }{#1 }{#2 }}

\newcommand{\pathextract}[3]{#1 \vdash #2 \sim #3 }

\newcommand{\pext}[2]{\pathextract{\context }{#1 }{#2 }}



\subsection{Well Formed Kind }

Assume \( \Delta  \) is well-formed. Check that \( \kappa  \) is well-formed

\begin{lyxlist}{00.00.0000}
\item [Type]
\[
\axiom{\kindvalid{\Delta }{T}}\]

\item [Singleton]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c}{\kappa } & \subkind{\context }{\kappa }{T}
\end{array}}{\kindvalid{\Delta }{\st{c}}}\]

\item [Pi]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa _{1}} & \kindvalid{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}
\end{array}}{\kindvalid{\Delta }{\Pi (\alpha ::\kappa _{1}).k_{2}}}\quad \alpha \notin dom(\Delta )\]

\item [Sigma]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa _{1}} & \kindvalid{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}
\end{array}}{\kindvalid{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}\quad \alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Sub-Kinding \protect\( \subkind{\Delta }{\kappa _{1}}{\kappa _{2}}\protect \)}

Assume that \( \Delta  \), \( \kappa _{1} \) and \( \kappa _{2} \) are well-formed.
Check that \( \kappa _{1} \) is a subkind of \( \kappa _{2} \).

\begin{lyxlist}{00.00.0000}
\item [Type]
\[
\axiom{\subkind{\Delta }{T}{T}}\]

\item [Singleton]
\[
\axiom{\subkind{\Delta }{\st{c}}{T}}\]

\item [Singletons]
\[
\infrule{\conequiv{\Delta }{c}{d}{T}}{\subkind{\Delta }{\st{c}}{\st{d}}}\]

\item [\( \Pi  \)]
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}'}{\kappa _{1}} & \subkind{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\item [\( \Sigma  \)]
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}}{\kappa _{1}'} & \subkind{\Delta [\alpha ::\kappa _{1}']}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Kind Synthesis \protect\( \kindsynth{\Delta }{c}{\kappa }\protect \)}

Assumes that \( \Delta  \) is well-formed. Check that c is well-kinded, and
construct \( \kappa  \) s.t. \( \kindvalid{\Delta }{\kappa } \) and c has
kind \( \kappa  \)

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\axiom{\kindsynth{\Delta [\alpha ::\kappa ]}{\alpha }{\kappa }}\]

\item [Int]
\[
\axiom{\kindsynth{\Delta }{Int}{\st{Int}}}\]

\item [BoxFloat]
\[
\axiom{\kindsynth{\Delta }{BoxFloat}{\st{BoxFloat}}}\]

\item [\( \mu  \)]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta [a::T,b::T]}{c_{1}}{\kappa _{1}} & \subkind{\caddk{a}{T}\extk{b}{T}}{\kappa _{1}}{T}\\
\kindsynth{\Delta [a::T,b::T]}{c_{2}}{\kappa _{2}} & \subkind{\caddk{a}{T}\extk{b}{T}}{\kappa _{2}}{T}
\end{array}}{\kindsynth{\Delta }{\mu (a=c_{1},b=c_{2})}{\Sigma (\alpha ::\st{\mu (a=c_{1},b=c_{2}).1}).\st{\mu (a=c_{1},b=c_{2}).2}}}\begin{array}{l}
a,b\notin dom(\Delta )\\
\alpha \notin fv(\mu (a=c_{1},b=c_{2}))
\end{array}\]
 
\item [Pair]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta }{c_{2}}{\kappa _{2}}\\
\subkind{\context }{\kappa _{1}}{T} & \subkind{\context }{\kappa _{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\times c_{2}}{\st{c_{1}\times c_{2}}}}\]

\item [Arrow]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \subkind{\Delta }{\kappa _{1}}{T}\\
\kindsynth{\Delta }{c_{2}}{\kappa _{2}} & \subkind{\Delta }{\kappa _{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\rightarrow c_{2}}{\st{c_{1}\rightarrow c_{2}}}}\]

\item [Lambda]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa } & \kindsynth{\Delta [\alpha ::\kappa ]}{c}{\kappa '}
\end{array}}{\kindsynth{\Delta }{\Lam{\alpha }{\kappa }{c}}{\Pi (\alpha ::\kappa ).\kappa '}}\alpha \notin dom(\Delta )\]

\item [App]
\[
\infrule{\begin{array}{cc}
\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & \\
\kindsynth{\Delta }{c_{2}}{\kappa _{1}'} & \subkind{\Delta }{\kappa _{1}'}{\kappa _{1}}
\end{array}
\end{array}}{\kindsynth{\Delta }{c_{1}\, c_{2}}{\subst{c_{2}}{\alpha }{\kappa _{2}}}}\]

\item [Record]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta }{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{<c_{1},c_{2}>}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}x\notin fv(\kappa _{2})\]

\item [Proj1]
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.1}{\kappa _{1}}}\]

\item [Proj2]
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}}\]

\item [Let]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta [\alpha ::\kappa _{1}]}{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{\Let{\alpha }{c_{1}}{c_{2}}}{\subst{c_{1}}{\alpha }{\kappa _{2}}}}\alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Well-formed Type \protect\( \typev{\tau }\protect \)}

Assume \( \context  \) is well-formed. Check that \( \tau  \) is well-formed.

\begin{lyxlist}{00.00.0000}
\item [Constructor]
\[
\frac{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa } & \subkind{\context }{\kappa }{T}
\end{array}}{\typev{c}}\]

\item [ArrowType]
\[
\frac{\begin{array}{ll}
\kindvalid{\context }{\kappa } & \\
\typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}
\end{array}}{\typev{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\alpha \notin dom(\context )\]

\item [Float]
\[
\axiom{\typev{Float}}\]

\item [PairType]
\[
\frac{\begin{array}{ll}
\typev{\tau _{1}} & \typev{\tau _{2}}
\end{array}}{\typev{\tau _{1}\times \tau _{2}}}\]

\end{lyxlist}

\subsection{Path Extraction \protect\( \pext{p}{c}\protect \)}

Assumes that \( \Delta  \) and \( p \)are well-formed. Returns the head normal
form of \( p \). 

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\infrule{\hnf{\caddk{\alpha }{\st{c}}}{c}{c'}}{\pathextract{\caddk{\alpha }{\st{c}}}{\alpha }{c}'}\]

\item [Proj1\( \simeq  \)]
\[
\infrule{\begin{array}{ll}
\pext{p}{<c_{1},c_{2}>} & \Hnf{c_{1}}{c_{1}'}
\end{array}}{\pext{p.1}{c_{1}'}}\]

\item [Proj1\( \Uparrow  \)]
\[
\infrule{\begin{array}{ll}
\kindsynth{\context }{p}{\Sigma (\alpha ::\st{c}).\kappa } & \Hnf{c}{c'}
\end{array}}{\pext{p.1}{c'}}\]

\item [Proj2\( \simeq  \)]
\[
\infrule{\begin{array}{ll}
\pext{p}{<c_{1},c_{2}>} & \Hnf{c_{2}}{c_{2}'}
\end{array}}{\pext{p.2}{c_{2}'}}\]

\item [Proj2\( \Uparrow  \)]
\[
\infrule{\begin{array}{ll}
\kindsynth{\context }{p}{\Sigma (\alpha ::\kappa ).\st{c}} & \hnf{\caddk{\alpha }{\kappa }}{c}{c'}
\end{array}}{\pext{p.1}{c'}}\]

\item [App\( \simeq  \)]
\[
\infrule{\begin{array}{ll}
\pext{p}{\lambda (\alpha ::\kappa ).c} & \Hnf{\subst{c_{\alpha }}{\alpha }{c}}{c'}
\end{array}}{\pext{p\, c_{\alpha }}{c'}}\]

\item [App\( \Uparrow  \)]
\[
\infrule{\begin{array}{ll}
\kindsynth{\context }{p}{\Pi (\alpha ::\kappa ).\st{c}} & \Hnf{\subst{c_{\alpha }}{\alpha }{c}}{c'}
\end{array}}{\pext{p\, c_{\alpha }}{c'}}\]

\end{lyxlist}

\subsection{Constructor Head Normal Form \protect\( \hnf{\context }{c}{c'}\protect \)}

Assumes that \( \Delta  \) and \( c \)are well-formed. Returns the head normal
form of \( c \). 

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\infrule{\pext{x}{c}}{\hnf{\context }{x}{c}}\]

\item [Int]
\[
\axiom{\hnf{\context }{Int}{Int}}\]

\item [BoxFloat]
\[
\axiom{\hnf{\context }{BoxFloat}{BoxFloat}}\]

\item [\( \mu  \)]
\[
\axiom{\Hnf{\mu (a=c_{1},b=c_{2})}{\mu (a=c_{1},b=c_{2})}}\]
 
\item [Pair]
\[
\axiom{\Hnf{c_{1}\times c_{2}}{c_{1}\times c_{2}}}\]

\item [Arrow]
\[
\axiom{\Hnf{c_{1}\rightarrow c_{2}}{c_{1}\rightarrow c_{2}}}\]

\item [Lambda]
\[
\axiom{\Hnf{\Lam{\alpha }{\kappa }{c}}{\Lam{\alpha }{\kappa }{c}}}\]

\item [App]
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{\lambda \alpha ::\kappa .c} & \Hnf{\subst{c_{2}}{\alpha }{c}}{c'}
\end{array}}{\Hnf{c_{1}\, c_{2}}{c'}}\]

\item [App\( \simeq  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c_{2}}{c'}
\end{array}}{\Hnf{c_{1}\, c_{2}}{c'}}\]

\item [Record]
\[
\axiom{\Hnf{<c_{1},c_{2}>}{<c_{1},c_{2}>}}\]

\item [Proj1]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c_{1}}{c_{1}'}
\end{array}}{\Hnf{c.1}{c_{1}'}}\]

\item [Proj1\( \simeq  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{c'}
\end{array}}{\Hnf{c.1}{c'}}\]

\item [Proj2]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c}{c_{2}'}
\end{array}}{\Hnf{c.1}{c_{2}'}}\]

\item [Proj2\( \simeq  \)]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{c'}
\end{array}}{\Hnf{c.2}{c'}}\]

\item [Let]
\[
\infrule{\Hnf{\subst{c_{1}}{\alpha }{c_{2}}}{c}}{\Hnf{\Let{\alpha }{c_{1}}{c_{2}}}{c}}\]

\end{lyxlist}

\subsection{Type Synthesis \protect\( \types{e}{\tau }\protect \)}

Assume \( \context  \) is well-formed. Check that \( e \) is well-formed and
construct its type \( \tau  \), where \( \typev{\tau } \)

\begin{lyxlist}{00.00.0000}
\item [variable]
\[
\axiom{\typesynth{\caddt{x}{\tau }}{x}{\tau }}\]

\item [lete]
\[
\frac{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \typesynth{\caddt{x}{\tau _{1}}}{e_{2}}{\tau _{2}}
\end{array}}{\types{\lete{x}{e_{1}}{e_{2}}}{\tau _{2}}}x\notin dom(\context )\]

\item [letc]
\[
\frac{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa } & \typesynth{\caddk{\alpha }{\kappa }}{e}{\tau }
\end{array}}{\types{\lete{\alpha }{c}{e}}{\subst{c}{\alpha }{\tau }}}\alpha \notin dom(\context )\]

\item [rec]
\[
\infrule{\begin{array}{lll}
\kindvalid{\context }{\kappa } & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}\\
\typesynth{\context \extt{f}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}\extk{\alpha }{\kappa }\extt{x}{\tau _{1}}}{e}{\tau _{2}'} & \typeequiv{\caddk{\alpha }{\kappa }}{\tau _{2}}{\tau _{2}'} & f,\alpha ,x\notin dom(\context )
\end{array}}{\types{\rec{f}{\alpha }{\kappa }{x}{\tau _{1}}{\tau _{2}}{e}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\]

\item [app]~\footnotemark{}
 
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}} &  & \types{c}{\kappa '}\\
\subkind{\context }{\kappa '}{\kappa } & \types{e_{2}}{\tau _{1}'} & \typeeq{\tau _{1}'}{\subst{c}{\alpha }{\tau _{1}}}
\end{array}}{\types{e_{1}[c]e_{2}}{\subst{c}{\alpha }{\tau _{2}}}}\]

\item [app2]
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{c_{e}} & \hnf{\context }{c_{e}}{c_{1}\rightarrow c_{2}} & \\
\types{e_{2}}{c_{1}'} & \coneq{c_{1}}{c_{1}'}{T} & 
\end{array}}{\types{e_{1}\, e_{2}}{c_{2}}}\]

\item [pair]
\[
\infrule{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \types{e_{2}}{\tau _{2}}
\end{array}}{\types{<e_{1},e_{2}>}{\tau _{1}\times \tau _{2}}}\]

\item [type\_proj1]~\footnotemark{}
 
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}} & 
\end{array}}{\types{e.1}{\tau _{1}}}\]

\item [con\_proj1]
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.1}{c_{1}}}\]

\item [type\_proj2]~\footnotemark{}
 
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}} & 
\end{array}}{\types{e.2}{\tau _{2}}}\]

\item [con\_proj2]
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.2}{c_{2}}}\]

\item [integer]
\[
\axiom{\types{n}{Int}}\]

\item [float]
\[
\axiom{\types{r}{Float}}\]

\item [box]~\footnotemark{}
 
\[
\infrule{\types{e}{Float}}{\types{box(e)}{BoxFloat}}\]

\item [ifzero]
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{Int}\\
\types{e_{1}}{\tau _{1}} & \types{e_{2}}{\tau _{2}}\\
\typeeq{\tau _{1}}{\tau _{2}} & 
\end{array}}{\types{\ifz{e}{e_{1}}{e_{2}}}{\tau _{1}}}\]

\item [ifFloat]
\[
\infrule{\begin{array}{ll}
\typev{\tau } & \types{e_{1}}{\tau _{1}}\\
\types{e_{2}}{\tau _{2}} & \typeeq{\tau _{1}}{\tau _{2}}
\end{array}}{\types{\iffloat{\tau }{e_{1}}{e_{2}}}{\tau _{1}}}\]

\end{lyxlist}
\addtocounter{footnote}{-3}\footnotetext{
Since we are being predicative, we don't need to normalize the result of synthesis
on \( e_{1} \), e.g. \( \hnf{\context }{\tau _{e}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}} \)
}%
\stepcounter{footnote}\footnotetext{
Again, don't need to normalize? \( \hnf{\context }{\tau }{\tau _{1}\times \tau _{2}} \)
}%
\stepcounter{footnote}\footnotetext{
\( \hnf{\context }{\tau }{\tau _{1}\times \tau _{2}} \)
}%
\stepcounter{footnote}\footnotetext{
No need to normalize - predicativity enforces.
}%
\end{document}
