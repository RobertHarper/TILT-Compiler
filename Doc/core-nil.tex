%% This LaTeX-file was created by <leaf> Mon Oct 12 19:41:58 1998
%% LyX 0.12 (C) 1995-1998 by Matthias Ettrich and the LyX Team

%% Do not edit this file unless you know what you are doing.
\documentclass{amsart}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\newcommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\spacefactor1000}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.

\theoremstyle{plain}    
\newtheorem{thm}{Theorem} 
\theoremstyle{plain}    
\newtheorem{lem}{Lemma} 
\newenvironment{lyxlist}[1]
  {\begin{list}{}
    {\settowidth{\labelwidth}{#1}
     \setlength{\leftmargin}{\labelwidth}
     \addtolength{\leftmargin}{\labelsep}
     \renewcommand{\makelabel}[1]{##1 \hfill}}}
  {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{latexsym}
\newcommand{\comment}[1]{}
\makeatother

\begin{document}


\newcommand{\Lam}[3]{\lambda #1 ::#2 .#3 }
 
\newcommand{\Let}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}
 
\newcommand{\lete}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}

\newcommand{\rec}[7]{\mathrm{rec}\, #1 =\lambda (#2 ::#3 ,#4 :#5 ):#6 .#7 }

\newcommand{\ifz}[3]{\mathrm{ifzero}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }

\newcommand{\st}[1]{S_{T}(#1 )}

\newcommand{\subst}[3]{\{#1 /#2 \}#3 }

\newcommand{\context}{\Delta }

\newcommand{\addk}[3]{#1 [#2 ::#3 ]}

\newcommand{\addt}[3]{#1 [#2 :#3 ]}

\newcommand{\caddk}[2]{\addk{\context }{#1 }{#2 }}

\newcommand{\caddt}[2]{\addt{\context }{#1 }{#2 }}

\newcommand{\extk}[2]{[#1 ::#2 ]}

\newcommand{\extt}[2]{[#1 :#2 ]}

\newcommand{\iffloat}[3]{\mathrm{ifBoxFloat}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }
 
\newcommand{\carray}[1]{#1 \: array}

\newcommand{\inl}[2]{inl_{#1 }#2 }

\newcommand{\inr}[2]{inr_{#1 }#2 }

\newcommand{\sumsw}[7]{case\, #1 \, of\, \{inl(#2 :#3 )\Rightarrow #4 ,inr(#5 :#6 )\Rightarrow #7 \}}

\newcommand{\arr}[3]{array_{#1 }(#2 ,#3 )}

\newcommand{\sub}[2]{sub(#1 ,#2 )}

\newcommand{\fsub}[2]{\mathit{fsub}(#1 ,#2 )}



\title{Core Nil}


\author{Leaf Petersen}

\maketitle

\section{Syntax}


\begin{eqnarray*}
\kappa  & ::= & T\: |\: \st{c}\: |\: \Sigma (\alpha ::\kappa ).\kappa \: |\: \Pi (\alpha ::\kappa ).\kappa \\
 &  & \\
c & ::= & \alpha \mid Int\mid BoxFloat\mid \mu (a=c,b=c)\mid c\times c\mid c\rightarrow c\mid c+c\mid \carray{c}\\
 &  & \mid \Lam{\alpha }{\kappa }{c}\mid c\, c\mid <c,c>\mid c.1\mid c.2\mid \Let{\alpha }{c}{c}\\
 &  & \\
\tau  & ::= & c\mid (\alpha ::\kappa ,\tau )\rightarrow \tau \mid Float\mid \tau \times \tau \\
 &  & \\
p & ::= & \alpha \mid p.1\mid p.2\mid p\, c\\
 &  & \\
e & ::= & x\mid \lete{x}{e}{e}\mid \lete{\alpha }{c}{e}\mid \rec{f}{\alpha }{\kappa }{x}{\tau }{\tau }{e}\\
 &  & \mid e[c]e\mid <e,e>\mid e.1\mid e.2\mid n\mid r\mid box(e)\mid unbox(e)\mid \inl{c}{e}\mid \inr{c}{e}\\
 &  & \mid \sumsw{e}{x}{c}{e}{x}{c}{e}\mid \iffloat{c}{e}{e}\\
 &  & \mid \arr{c}{e}{e}\mid \sub{e}{e}\mid \fsub{e}{e}\\
 &  & \\
\Delta  & ::= & \bullet \mid \caddt{x}{\tau }\mid \caddk{\alpha }{\kappa }
\end{eqnarray*}


I occasionally use \( \kappa _{1}\times \kappa _{2} \) for \( \Sigma (\alpha ::\kappa _{1}).\kappa _{2} \)where
\( \alpha \notin fv(\kappa _{2}) \)


\section{Judgements for the algorithmic core nil}


\newcommand{\infrule}[2]{\frac{#1 }{#2 }}

\newcommand{\axiom}[1]{\overline{#1 }}



\newcommand{\kindvalid}[2]{#1 \vdash #2 }

\newcommand{\kindsynth}[3]{#1 \vdash #2 \Uparrow #3 }

\newcommand{\subkind}[3]{#1 \vdash #2 \preceq #3 }

\newcommand{\conequiv}[4]{#1 \vdash #2 \equiv #3 ::#4 }

\newcommand{\coneq}[3]{\conequiv{\context }{#1 }{#2 }{#3 }}
 
\newcommand{\typevalid}[2]{#1 \vdash #2 }

\newcommand{\typev}[1]{\typevalid{\Delta }{#1 }}



\newcommand{\typesynth}[3]{#1 \vdash #2 \Uparrow #3 }

\newcommand{\types}[2]{\typesynth{\context }{#1 }{#2 }}

\newcommand{\typeequiv}[3]{#1 \vdash #2 \equiv #3 }

\newcommand{\typeeq}[2]{\typeequiv{\context }{#1 }{#2 }}

\newcommand{\hnf}[3]{#1 \vdash #2 \Longrightarrow #3 }

\newcommand{\Hnf}[2]{\hnf{\context }{#1 }{#2 }}

\newcommand{\pathextract}[3]{#1 \vdash #2 \leadsto #3 }

\newcommand{\pext}[2]{\pathextract{\context }{#1 }{#2 }}

\newcommand{\cok}[1]{#1 \, \mathrm{ok}}

\newcommand{\selfify}[3]{#1 ::#2 \doteq #3 }

\newcommand{\kcheck}[3]{#1 \vdash #2 \Downarrow #3 }

\newcommand{\betared}[3]{#1 \vdash #2 \rightarrow #3 }



\newcommand{\tcheck}[3]{#1 \vdash #2 \Downarrow #3 }
 


\subsection{Well Formed Context }

\begin{lyxlist}{00.00.0000}
\item [Empty]
\[
\axiom{\cok{\bullet }}\]

\item [Kind]
\[
\infrule{\begin{array}{ll}
\cok{\context } & \kindvalid{\context }{\kappa }
\end{array}}{\cok{\caddk{\alpha }{\kappa }}}\quad \alpha \notin dom(\context )\]

\item [Type]
\[
\infrule{\begin{array}{ll}
\cok{\context } & \typevalid{\context }{\tau }
\end{array}}{\cok{\caddt{x}{\tau }}}\quad x\notin dom(\context )\]

\end{lyxlist}

\subsection{Well Formed Kind }

Assume \( \Delta  \) is well-formed. Check that \( \kappa  \) is well-formed

\begin{lyxlist}{00.00.0000}
\item [Type]
\[
\axiom{\kindvalid{\Delta }{T}}\]

\item [Singleton]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c}{T}
\end{array}}{\kindvalid{\Delta }{\st{c}}}\]

\item [Pi]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa _{1}} & \kindvalid{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}
\end{array}}{\kindvalid{\Delta }{\Pi (\alpha ::\kappa _{1}).k_{2}}}\quad \alpha \notin dom(\Delta )\]

\item [Sigma]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa _{1}} & \kindvalid{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}
\end{array}}{\kindvalid{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}\quad \alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Sub-Kinding \protect\( \subkind{\Delta }{\kappa _{1}}{\kappa _{2}}\protect \)}

Assume that \( \Delta  \), \( \kappa _{1} \) and \( \kappa _{2} \) are well-formed.
Check that \( \kappa _{1} \) is a subkind of \( \kappa _{2} \).

\begin{lyxlist}{00.00.0000}
\item [Type]
\[
\axiom{\subkind{\Delta }{T}{T}}\]

\item [Singleton]
\[
\axiom{\subkind{\Delta }{\st{c}}{T}}\]

\item [Singletons]
\[
\infrule{\conequiv{\Delta }{c}{d}{T}}{\subkind{\Delta }{\st{c}}{\st{d}}}\]

\item [\( \Pi  \)]
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}'}{\kappa _{1}} & \subkind{\Delta [\alpha ::\kappa _{1}']}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\item [\( \Sigma  \)]
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}}{\kappa _{1}'} & \subkind{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Selfification \protect\( \selfify{c}{\kappa }{\kappa '}\protect \)}

This is the definition of selfification. Assume \( c \) and \( \kappa  \)
are well-formed with respect to some context. Return the most precise kind of
\( c \). Intuitively, this is the definition of a singleton at the higher kind.
So assume that there exists \( \context  \) s.t. \( \kcheck{\context }{c}{\kappa } \),
and \( \selfify{c}{\kappa }{\kappa '} \). Then for all \( \kappa '' \) s.t.
\( \kcheck{\context }{c}{\kappa ''} \), \( \subkind{\context }{\kappa '}{\kappa ''} \).

\begin{lyxlist}{00.00.0000}
\item [Type]\( \selfify{c}{T}{\st{c}} \)
\item [Singleton]\( \selfify{c}{\st{d}}{d} \)
\item [\( \Pi  \)]\( \selfify{c}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}'} \)
\\
where \( \selfify{c\, \alpha }{\kappa _{2}}{\kappa _{2}'} \)
\item [\( \Sigma  \)]\( \selfify{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \)
\\
where \( \selfify{c.1}{\kappa _{1}}{\kappa _{1}'} \) and \( \selfify{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}{\kappa _{2}'} \)
\end{lyxlist}

\subsection{Kind Analysis \protect\( \kcheck{\context }{c}{\kappa }\protect \)}

Assume \( \context  \) and \( \kappa  \) are well formed. Check that \( c \)
is well formed and can be given kind \( \kappa  \).


\[
\infrule{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa '} & \subkind{\context }{\kappa '}{\kappa }
\end{array}}{\kcheck{\context }{c}{\kappa }}\]



\subsection{Kind Synthesis \protect\( \kindsynth{\Delta }{c}{\kappa }\protect \)}

Assumes that \( \Delta  \) is well-formed. Check that c is well-kinded, and
construct \( \kappa  \) s.t. \( \kindvalid{\Delta }{\kappa } \) and c has
kind \( \kappa  \). We say that a constructor \( c \) is well-formed with
respect to a well-formed context \( \context  \) iff \( \kindsynth{\context }{c}{\kappa } \)
for some \( \kappa  \).

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\infrule{\selfify{\alpha }{\kappa }{\kappa '}}{\kindsynth{\Delta [\alpha ::\kappa ]}{\alpha }{\kappa }'}\]

\item [BoxFloat]
\[
\axiom{\kindsynth{\Delta }{BoxFloat}{\st{BoxFloat}}}\]

\item [Int]
\[
\axiom{\kindsynth{\context }{Int}{\st{Int}}}\]

\item [\( \mu  \)]
\[
\infrule{\begin{array}{ll}
\kcheck{\Delta [a::T,b::T]}{c_{1}}{T} & \kcheck{\Delta [a::T,b::T]}{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{\mu (a=c_{1},b=c_{2})}{\st{\mu (a=c_{1},b=c_{2}).1}\times \st{\mu (a=c_{1},b=c_{2}).2}}}\quad a,b\notin dom(\Delta )\]
 
\item [Pair]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\times c_{2}}{\st{c_{1}\times c_{2}}}}\]

\item [Arrow]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\rightarrow c_{2}}{\st{c_{1}\rightarrow c_{2}}}}\]

\item [Sum]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}+c_{2}}{\st{c_{1}+c_{2}}}}\]

\item [Array]
\[
\infrule{\kcheck{\context }{c}{T}}{\kindsynth{\context }{\carray{c}}{\st{\carray{c}}}}\]

\item [Lambda]
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa } & \kindsynth{\Delta [\alpha ::\kappa ]}{c}{\kappa '}
\end{array}}{\kindsynth{\Delta }{\Lam{\alpha }{\kappa }{c}}{\Pi (\alpha ::\kappa ).\kappa '}}\quad \alpha \notin dom(\Delta )\]

\item [App]
\[
\infrule{\begin{array}{cc}
\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & \kcheck{\context }{c_{2}}{\kappa _{1}}
\end{array}
\end{array}}{\kindsynth{\Delta }{c_{1}\, c_{2}}{\subst{c_{2}}{\alpha }{\kappa _{2}}}}\]

\item [Record]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta }{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{<c_{1},c_{2}>}{\kappa _{1}\times \kappa _{2}}}\]

\item [Proj1]
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.1}{\kappa _{1}}}\]

\item [Proj2]
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}}\]

\item [Let]
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta [\alpha ::\kappa _{1}]}{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{\Let{\alpha }{c_{1}}{c_{2}}}{\subst{c_{1}}{\alpha }{\kappa _{2}}}}\quad \alpha \notin dom(\Delta )\]

\end{lyxlist}

\subsection{Well-formed Type \protect\( \typev{\tau }\protect \)}

Assume \( \context  \) is well-formed. Check that \( \tau  \) is well-formed.

\begin{lyxlist}{00.00.0000}
\item [Constructor]
\[
\frac{\kcheck{\context }{c}{T}}{\typev{c}}\]

\item [ArrowType]
\[
\frac{\begin{array}{ll}
\kindvalid{\context }{\kappa } & \\
\typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}
\end{array}}{\typev{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\quad \alpha \notin dom(\context )\]

\item [Float]
\[
\axiom{\typev{Float}}\]

\item [PairType]
\[
\frac{\begin{array}{ll}
\typev{\tau _{1}} & \typev{\tau _{2}}
\end{array}}{\typev{\tau _{1}\times \tau _{2}}}\]

\end{lyxlist}

\subsection{Type Analysis \protect\( \tcheck{\context }{e}{\tau }\protect \)}

Assume \( \context  \) and \( \tau  \) are well-formed. Check that \( e \)
is well-typed, and has type \( \tau  \).


\[
\infrule{\begin{array}{ll}
\types{e}{\tau '} & \typeeq{\tau '}{\tau }
\end{array}}{\tcheck{\context }{e}{\tau }}\]



\subsection{Type Synthesis \protect\( \types{e}{\tau }\protect \)}

Assume \( \context  \) is well-formed. Check that \( e \) is well-formed and
construct its type \( \tau  \), where \( \typev{\tau } \)

\begin{lyxlist}{00.00.0000}
\item [variable]
\[
\axiom{\typesynth{\caddt{x}{\tau }}{x}{\tau }}\]

\item [lete]
\[
\frac{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \typesynth{\caddt{x}{\tau _{1}}}{e_{2}}{\tau _{2}}
\end{array}}{\types{\lete{x}{e_{1}}{e_{2}}}{\tau _{2}}}\quad x\notin dom(\context )\]

\item [letc]
\[
\frac{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa } & \typesynth{\caddk{\alpha }{\kappa }}{e}{\tau }
\end{array}}{\types{\lete{\alpha }{c}{e}}{\subst{c}{\alpha }{\tau }}}\quad \alpha \notin dom(\context )\]

\item [rec]
\[
\infrule{\begin{array}{lll}
\kindvalid{\context }{\kappa } & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}\\
\typesynth{\context \extt{f}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}\extk{\alpha }{\kappa }\extt{x}{\tau _{1}}}{e}{\tau _{2}'} & \typeequiv{\caddk{\alpha }{\kappa }}{\tau _{2}}{\tau _{2}'} & 
\end{array}}{\types{\rec{f}{\alpha }{\kappa }{x}{\tau _{1}}{\tau _{2}}{e}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\]
\\
where \( f,\alpha ,x\notin dom(\context ) \).
\item [app]
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}} & \kcheck{\context }{c}{\kappa } & \kcheck{\context }{e_{2}}{\subst{c}{\alpha }{\tau _{1}}}
\end{array}}{\types{e_{1}[c]e_{2}}{\subst{c}{\alpha }{\tau _{2}}}}\]

\item [app2]
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{c_{e}} & \hnf{\context }{c_{e}}{c_{1}\rightarrow c_{2}} & \tcheck{\context }{e_{2}}{c_{1}}
\end{array}}{\types{e_{1}\, e_{2}}{c_{2}}}\]

\item [pair]
\[
\infrule{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \types{e_{2}}{\tau _{2}}
\end{array}}{\types{<e_{1},e_{2}>}{\tau _{1}\times \tau _{2}}}\]

\item [type\_proj1]
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}}
\end{array}}{\types{e.1}{\tau _{1}}}\]

\item [con\_proj1]
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.1}{c_{1}}}\]

\item [type\_proj2]
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}}
\end{array}}{\types{e.2}{\tau _{2}}}\]

\item [con\_proj2]
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.2}{c_{2}}}\]

\item [float]
\[
\axiom{\types{r}{Float}}\]

\item [int]
\[
\axiom{\types{n}{Int}}\]

\item [box]
\[
\infrule{\types{e}{Float}}{\types{box(e)}{BoxFloat}}\]

\item [unbox]
\[
\infrule{\types{e}{BoxFloat}}{\types{unbox(e)}{Float}}\]

\item [sumswitch]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \typesynth{\caddt{x_{1}}{c_{1}}}{e_{1}}{\tau _{1}}\\
\kcheck{\context }{c_{2}}{T} & \typesynth{\caddt{x_{2}}{c_{2}}}{e_{2}}{\tau _{2}}\\
\tcheck{\context }{e}{c_{1}+c_{2}} & \typeeq{\tau _{1}}{\tau _{2}}
\end{array}}{\sumsw{e}{x_{1}}{c_{1}}{e_{1}}{x_{2}}{c_{2}}{e_{2}}}\]

\item [inl]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c}{T} & \hnf{\context }{c}{c_{1}+c_{2}}\\
\tcheck{\context }{e}{c_{1}} & 
\end{array}}{\types{\inl{c}{e}}{c_{1}+c_{2}}}\]

\item [inr]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c}{T} & \hnf{\context }{c}{c_{1}+c_{2}}\\
\tcheck{\context }{e}{c_{2}} & 
\end{array}}{\types{\inr{c}{e}}{c_{1}+c_{2}}}\]

\item [ifBoxFloat]
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c}{T} & \types{e_{1}}{\tau _{1}}\\
\types{e_{2}}{\tau _{2}} & \typeeq{\tau _{1}}{\tau _{2}}
\end{array}}{\types{\iffloat{c}{e_{1}}{e_{2}}}{\tau _{1}}}\]

\item [array]
\[
\infrule{\begin{array}{ll}
\tcheck{\context }{e_{1}}{Int} & \kcheck{\context }{c}{T}\\
\tcheck{\context }{e_{2}}{c} & 
\end{array}}{\types{\arr{c}{e_{1}}{e_{2}}}{\carray{c}}}\]

\item [sub]
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{\carray{c}} & \tcheck{\context }{e_{2}}{Int}
\end{array}}{\types{\sub{e_{1}}{e_{2}}}{c}}\]

\item [fsub]
\[
\infrule{\begin{array}{ll}
\tcheck{\context }{e_{1}}{\carray{BoxFloat}} & \tcheck{\context }{e_{2}}{Int}
\end{array}}{\types{\fsub{e_{1}}{e_{2}}}{Float}}\]

\end{lyxlist}

\subsection{Natural Kind Extraction \protect\( \pext{p}{\kappa }\protect \)}

Assumes that \( \Delta  \) and \( p \) are well-formed. Returns the unselfified
kind of \( p \). 

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\axiom{\pathextract{\caddk{\alpha }{\kappa }}{\alpha }{\kappa }}\]

\item [Proj1]
\[
\infrule{\begin{array}{ll}
\pext{p}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p.1}{\kappa _{1}}}\]

\item [Proj2]
\[
\infrule{\begin{array}{ll}
\pext{p}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p.2}{\subst{p.1}{\alpha }{\kappa _{2}}}}\]

\item [App]
\[
\infrule{\begin{array}{ll}
\pext{p}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p\, c}{\subst{c}{\alpha }{\kappa _{2}}}}\]

\end{lyxlist}

\subsection{Constructor Weak Head Normal Form \protect\( \hnf{\context }{c}{c'}\protect \)}

Assumes that \( \Delta  \) and \( c \) are well-formed. Returns the head normal
form of \( c \). 

\begin{lyxlist}{00.00.0000}
\item [Variable]
\[
\infrule{\begin{array}{ll}
\pext{\alpha }{\st{c}} & \hnf{\context }{c}{c'}
\end{array}}{\hnf{\context }{\alpha }{c'}}\]

\item [OpaqueVariable]
\[
\infrule{\begin{array}{ll}
\pext{\alpha }{\kappa } & 
\end{array}}{\hnf{\context }{\alpha }{\alpha }}\]
\\
where \( \kappa  \) is not a singleton
\item [BoxFloat]
\[
\axiom{\hnf{\context }{BoxFloat}{BoxFloat}}\]

\item [Int]
\[
\axiom{\hnf{\context }{Int}{Int}}\]

\item [\( \mu  \)]
\[
\axiom{\Hnf{\mu (a=c_{1},b=c_{2})}{\mu (a=c_{1},b=c_{2})}}\]
 
\item [Pair]
\[
\axiom{\Hnf{c_{1}\times c_{2}}{c_{1}\times c_{2}}}\]

\item [Arrow]
\[
\axiom{\Hnf{c_{1}\rightarrow c_{2}}{c_{1}\rightarrow c_{2}}}\]

\item [Sum]
\[
\axiom{\Hnf{c_{1}+c_{2}}{c_{1}+c_{2}}}\]

\item [Array]
\[
\axiom{\hnf{\context }{\carray{c}}{\carray{c}}}\]

\item [Lambda]
\[
\axiom{\Hnf{\Lam{\alpha }{\kappa }{c}}{\Lam{\alpha }{\kappa }{c}}}\]

\item [App]
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{\lambda \alpha ::\kappa .c_{1}} & \hnf{\context }{\subst{c_{2}}{\alpha }{c_{1}}}{c}
\end{array}}{\Hnf{c_{1}\, c_{2}}{c}}\]
 
\item [PathApp]
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c_{1}\, c_{2}}{c''}}\]

\item [OpaquePathApp]
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c}{\kappa }
\end{array}}{\Hnf{c_{1}\, c_{2}}{p\, c}}\]
\\
where \( \kappa  \) is not a singleton
\item [Record]
\[
\axiom{\Hnf{<c_{1},c_{2}>}{<c_{1},c_{2}>}}\]

\item [Proj1]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c_{1}}{c_{1}'}
\end{array}}{\Hnf{c.1}{c_{1}'}}\]

\item [PathProj1]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c.1}{c''}}\]

\item [OpaquePathProj1]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{\kappa }
\end{array}}{\Hnf{c.1}{p.1}}\]
\\
where \( \kappa  \) is not a singleton
\item [Proj2]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c_{2}}{c_{2}'}
\end{array}}{\Hnf{c.2}{c_{2}'}}\]

\item [PathProj2]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c.2}{c''}}\]

\item [OpaquePathProj2]
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{\kappa }
\end{array}}{\Hnf{c.2}{p.2}}\]
\\
where \( \kappa  \) is not a singleton
\item [Let]
\[
\infrule{\Hnf{\subst{c_{1}}{\alpha }{c_{2}}}{c}}{\Hnf{\Let{\alpha }{c_{1}}{c_{2}}}{c}}\]

\end{lyxlist}

\section{Proofs}


\subsection{Termination of sub-kinding, well-formed kind, and kind synthesis algorithms.}

For the time being, we assume that constructor equivalence at kind type is decidable.
For this section, I view the judgments given above as algorithms, as they were
intended to be. All of the judgments presented above are algorithmic in the
sense that either they are entirely syntax directed, or else at worse, require
the ``results'' of one of their hypotheses to determine a rule which uniquely
applies.

\begin{thm}
The algorithm for checking subkinding always terminates. That is, the algorithmic
rules for subkinding do not permit any infinite sequences of rule applications. 
\end{thm}
Consider the relation \( \prec  \) on sub-kinding judgments defined as follows:
\( (\subkind{\context '}{\kappa _{1}'}{\kappa _{2}'})\prec (\subkind{\context }{\kappa _{1}}{\kappa _{2}}) \)
iff showing \( \subkind{\context '}{\kappa _{1}'}{\kappa _{2}'} \) is an immediate
sub-goal of showing \( \subkind{\context }{\kappa _{1}}{\kappa _{2}} \). It
suffices to show that the \( \prec  \) relation is well-founded, since if there
are no infinite descending chains in the relation, then clearly there are no
infinite sequences of rule applications. To show that this is the case, we exhibit
a mapping \( SZ \) which maps judgments to natural numbers, and show that this
map is order preserving. 

Define the function \( SZ \) as follows : \( SZ(\subkind{\context }{\kappa _{1}}{\kappa _{2}})=sz(\kappa _{1})+sz(\kappa _{2}) \),
where 


\[
sz(\kappa )=\left\{ \begin{array}{ll}
1 & \mathrm{if}\, \kappa =T\\
1 & \mathrm{if}\, \kappa =\st{c}\\
sz(\kappa _{1})+sz(\kappa _{2}) & \mathrm{if}\, \kappa =\Sigma (\alpha ::\kappa _{1}).\kappa _{2}\\
sz(\kappa _{1})+sz(\kappa _{2}) & \mathrm{if}\, \kappa =\Pi (\alpha ::\kappa _{1}).\kappa _{2}
\end{array}\right. \]


\begin{lem}
\( SZ \) is a function.
\end{lem}
\begin{proof}
Clearly it suffices to show that \( sz \) is a function - that is, \( \forall \kappa ,\exists !n\, s.t.\, sz(\kappa )=n \).
This follows by induction over the structure of \( \kappa  \).
\end{proof}
\begin{lem}
\( SZ \) is order preserving. That is, 
\[
(\subkind{\context '}{\kappa _{1}'}{\kappa _{2}'})\prec (\subkind{\context }{\kappa _{1}}{\kappa _{2})}\Rightarrow SZ(\subkind{\context '}{\kappa _{1}'}{\kappa _{2}'})<SZ(\subkind{\context }{\kappa _{1}}{\kappa _{2}})\]

\end{lem}
\begin{proof}

We proceed by cases on the subkinding judgements that define\( \prec  \).

\begin{enumerate}
\item \( \subkind{\context }{T}{T} \). Vacuously true - the rule has no premises,
and hence has nothing smaller than it. 
\item \( \subkind{\context }{\st{c}}{T} \). Vacuously true - the rule has no premises,
and hence has nothing smaller than it. 
\item \( \subkind{\context }{\st{c}}{\st{d}} \). This rule has no sub-kinding premises,
and hence has nothing smaller than it. The only subgoal is an equivalence judgment,
which we assume terminates. 
\item \( \subkind{\Delta }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'} \).
The subkinding rule for the \( \Pi  \) judgment defines two judgments as smaller:

\begin{enumerate}
\item By definition, \( (\subkind{\context }{\kappa _{1}'}{\kappa _{1}})\prec (\subkind{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}) \).
But note that 
\begin{eqnarray*}
SZ(\subkind{\context }{\kappa _{1}'}{\kappa _{1}}) & = & sz(\kappa _{1}')+sz(\kappa _{1})\\
 & < & sz(\kappa _{1}')+sz(\kappa _{1})+sz(\kappa _{2}')+sz(\kappa _{2})\\
 & = & SZ(\subkind{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'})
\end{eqnarray*}

\item By definition, \( (\subkind{\caddk{\alpha }{\kappa _{1}'}}{\kappa _{2}}{\kappa _{2}'})\prec (\subkind{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}) \).
But note that 
\begin{eqnarray*}
SZ(\subkind{\caddk{\alpha }{\kappa _{1}'}}{\kappa _{2}}{\kappa _{2}}') & = & sz(\kappa _{2}')+sz(\kappa _{2})\\
 & < & sz(\kappa _{1}')+sz(\kappa _{1})+sz(\kappa _{2}')+sz(\kappa _{2})\\
 & = & SZ(\subkind{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'})
\end{eqnarray*}

\end{enumerate}
\item \( \subkind{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \).
The subkinding rule for the \( \Sigma  \) judgment defines two judgements as
smaller:

\begin{enumerate}
\item By definition, \( \subkind{\context }{\kappa _{1}}{\kappa _{1}'}\prec \subkind{\context }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \).
But note that 
\begin{eqnarray*}
SZ(\subkind{\context }{\kappa _{1}}{\kappa _{1}'}) & = & sz(\kappa _{1}')+sz(\kappa _{1})\\
 & < & sz(\kappa _{1}')+sz(\kappa _{1})+sz(\kappa _{2}')+sz(\kappa _{2})\\
 & = & SZ(\subkind{\context }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'})
\end{eqnarray*}

\item By definition, \( \subkind{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}}{\kappa _{2}'}\prec \subkind{\context }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \).
But note that 
\begin{eqnarray*}
SZ(\subkind{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}}{\kappa _{2}}') & = & sz(\kappa _{2}')+sz(\kappa _{2})\\
 & < & sz(\kappa _{1}')+sz(\kappa _{1})+sz(\kappa _{2}')+sz(\kappa _{2})\\
 & = & SZ(\subkind{\context }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'})
\end{eqnarray*}

\end{enumerate}
\end{enumerate}
Clearly then, for all \( \context ,\context ',\kappa _{1},\kappa _{2},\kappa _{1}' \)
and \( \kappa _{2}' \) such that \( (\subkind{\context '}{\kappa _{1}'}{\kappa _{2}'})\prec (\subkind{\context }{\kappa _{1}}{\kappa _{2})} \),
it is the case that \( SZ(\subkind{\context '}{\kappa _{1}'}{\kappa _{2}'})<SZ(\subkind{\context }{\kappa _{1}}{\kappa _{2}}) \).
Therefore \( SZ \) is order preserving.

\end{proof}

\comment{

Weakening1 
\[
\infrule{\kindsynth{\context }{\alpha }{\kappa }}{\kindsynth{\caddk{\alpha '}{\kappa '}}{\alpha }{\kappa }}\]


Weakening2 
\[
\infrule{\kindsynth{\context }{\alpha }{\kappa }}{\kindsynth{\caddt{x}{\tau }}{\alpha }{\kappa }}\]


weakening1 
\[
\infrule{\types{x}{\tau }}{\typesynth{\caddt{x'}{\tau '}}{x}{\tau }}\]


weakening2 
\[
\infrule{\types{x}{\tau }}{\typesynth{\caddk{\alpha }{\kappa }}{x}{\tau }}\]


Weakening1 
\[
\infrule{\pext{\alpha }{\kappa }}{\pathextract{\caddk{\alpha '}{\kappa '}}{\alpha }{\kappa }}\]


Weakening2 
\[
\infrule{\pext{\alpha }{\kappa }}{\pathextract{\caddt{x}{\tau }}{\alpha }{\kappa }}\]


Now we note that the We say that \( \kappa _{1}<\kappa _{2} \) iff \( \kappa _{1} \) is a sub-expression of \( \kappa _{2} \). This is a well-founded ordering. We order triples \( (\context ,\kappa _{1},\kappa _{2}) \) by the product ordering of \( < \). That is, \( (\context ',\kappa _{1}',\kappa _{2}')<(\context ,\kappa _{1},\kappa _{2}) \) iff \( \kappa _{1}'<\kappa _{1} \) and \( \kappa _{2}'<\kappa _{2} \). Finally, we show by cases on the subkinding judgment that \( (\context ',\kappa _{1}',\kappa _{2}')\prec (\context ,\kappa _{1},\kappa _{2})\Rightarrow (\context ',\kappa _{1}',\kappa _{2}')<(\context ,\kappa _{1},\kappa _{2}) \), and hence \( \prec  \) is well-founded. 

}

\end{document}
