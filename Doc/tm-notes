1.  A unit is essentially a top-level declaration (a topdec), which
may be composed of top-level signature, structure, functor, etc
bindings.  Any topdec is OK.  A unit is the unit of compilation.  It
is almost true that a unit is a structure body (an sdec), except that
SML limits what can go into a structure.

2.  An interface is essentially a topspec, even though such do not
exist in SML.  But the meaning should be clear.  A topspec can contain
fixity declarations, signature definitions, structure spec's, functor
spec's, type spec's, value spec's, and so on.  It is almost true that
an interface is a signature body (a spec), except that SML limits what
can go into a signature.

3.  An interface may be ascribed to a unit in order to facilitate
separate compilation of those units that depend on it.  If we don't
ascribe an interface to a unit, then it has to be compiled to obtain
one before any dependent can be compiled (IR).  If we do, then the
dependent can be compiled without having the source for the unit (SC).

4.  If an interface contains signature definitions then equivalent
definitions must occur in any unit to which it is ascribed.

If an interface contains fixity declarations then the same
declarations must occur in any unit to which it is ascribed.

5.  An interface or unit definition may specify those units on which
it depends but this is NOT required.  The ones that it does specify
are precisely those that are implicitly "opened" for use within that
unit or interface.  If you do not specify a list of dependencies, it
is implicitly ALL of the preceding units --- they are implicitly
opened for you.  The order of scoping/shadowing is determined by the
order in which units are opened.  Specifying a dependency list allows
you to manage name clashes.  It can cut down on the compilation
overhead to specify dependencies, particularly in an IR scenario,
because you are saying that certain units do not matter for this unit
or interface.

6.  A project description may contain multiple definitions for a unit
U provided that (i) at most one implementation is defined and (ii)
every definition of U has an ascribed interface and these interfaces
are equivalent.

A project description may contain multiple definitions for an
interface I provided that they are equivalent.

Two interfaces are equivalent if they are defined with identical
source code and if they open the same units in the same order.

These restrictions ensure that every unit and interface name is a
definite reference to a specific unit or interface.

7.  Project descriptions are DESCRIPTIONS.  Their role is to match
abstract entities (units, interfaces) to source code, which typically
lives in a file.

8. Project descriptions describe the ENTIRE project, not its constituent
parts.  This is a restatement of the commitment to units as the units of
compilation, not projects.

The order of definitions in a project description matters in two
senses: a) it determines the order of scoping/shadowing when an
interface or unit definition does not specify a list of units on which
it depends, and b) it determines the order of effects when building up
the initialization code for an executable.

9. TILT permits one to accrete project descriptions from other (sub-)
project descriptions, but this is a detail of how project descriptions
come into existence.  It has no semantic significance.  (Again,
projects are not the units of separate compilation, units are.)
The mechanism is that one (sub-) project description file
can include another by name.

10.  In a project description if you do not ascribe an interface for a
unit, then compilation of a unit or interface that depends on it can
only occur after that unit has been compiled (IR).  If it does, then
the dependent can be compiled without having compiled the
unit/interface on which it depends.

11.  In addition to source interfaces and units, a project description
can define pre-compiled interfaces, pre-compiled units, compiled
interfaces (that have no source), and compiled units.

A library is (by convention) a collection of (pre-)compiled interfaces
and units; see the following discussion of tilt -l.  A library is not
a single unit built up from other units.

12. Unit compilation is specified on the command line:

	tilt -c B mysys.proj		compile unit B from project mysys
	tilt -c A mysys.proj		compile unit A from project mysys
	tilt -o a.out -c B mysys.proj	compile and link, using B as root

The tilt command takes switches telling it what to do followed by a
project description file.

The main switches are

none
	Compile every unit and interface.

-o exe
	Compile every unit and interface and link every unit into an
	executable.  This fails if there are unimplemented units.

-l lib
	Compile every unit and interface and pack them into a library
	directory lib.  Three project descriptions will be created for the
	library: lib/impl, lib/inter, and lib/desc.  The first describes
	the entire library.  The second is similar but contains no unit
	implementations.  The third uses the manager's conditional
	compilation mechanism to include lib/impl if tilt is generating an
	executable and to include lib/inter otherwise.  (If TILT does not
	have a backend for the current system, then lib/impl will be the
	same as lib/inter.)

-p
	Purge (remove) object files for every source unit defined in
	the project description.  With a second -p, purge all
	compiler-generated files for every source unit and source
	interface defined in the project description.  Files
	associated with compiled and pre-compiled units and interfaces
	are never removed.

You can use switches to specify a set of units and interfaces to
operate on:

	-c U	unit U
	-C I	interface I

These serve to GC the project description so that only units and interfaces
relative to the named roots are retained.

In the preceding example, if unit B depends on unit A, and there is no interface
for A specified in mysys.proj, then A must be elaborated before B is compiled.
If A does have a specified interface, then B can be compiled separately from
A; the source code for A need not even exist.  (We must, of course, compile
the interface for A beforehand.)

It is perfectly possible to compile an interface too.  That is, we can write

	tilt -C BI mysys.proj

where BI is an interface from mysys.proj.  It means to compile it as an
interface.

13.  An example project description:

	unit SIG = "SIG.sml"
	interface AI = "A.int"
	unit A : AI = "A.sml"
	unit B = "B.sml"

where SIG.sml contains

	signature SIG = sig ... end

and A.int contains

	structure X : SIG

and A.sml contains

  	structure X :> SIG = struct ... end

and B.sml contains

	structure Y = struct ... A.whatever ... end

We can, if we wish, specify dependencies:

	unit SIG = "SIG.sml" { }
	interface AI = "A.int" { SIG }
	unit A : AI = "A.sml" { SIG }
	unit B = "B.sml" { A }

Notice that A depends on SIG, which means it may (and does) use the
signature defined in SIG.  Notice that A is ascribed AI, which means
that it must provide a structure X with signature SIG, which it does.

We may compile A separately from B.  The following sequence makes sense

	tilt -c B mysys.proj
	tilt -c A mysys.proj
	tilt -o a.out mysys.proj

Assuming a fresh start, the first command elaborates AI and SIG and
compiles B; the second command compiles A; and the third command
compiles SIG and links SIG, A, and B into an executable.
