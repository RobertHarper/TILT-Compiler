This file serves as an overview log for modifications to the TILT
compiler.  Starting date is April 20, 1998.

------------------------------------------------------------------------
April 20  Chris

In discussing the reifier, Perry and I came to the following
conclusions:

 (1) We would like to remove the code in the back-end (in particular,
     in tortl) that determines the tracability of values through type
     normalization, since this is redundent; the reifier already has
     to do all this computation.

 (2) In order for this to be possible, the reifier must annotate every
     subexpression with tracability info (since each subexpression
     corresponds to an RTL/MLRISC pseudoregister needing a tracability
     annotation).  

 (3) Adding annotation nodes to our program is clumsy, and the
     information is hard to maintain.  Therefore, we will add
     tracability annotations to expression-level let bindings, and
     have the reifier emit (term-level) A-normalized code.

 (4) The tracability annotation should be something like

       datatype niltrace = TraceUnknown
                         | TraceKnown of <abstract trace info>
                         | TraceCompute of var

     where we assume the reifier is parameterized by a function

         get_trace : Nil.context * Nil.con -> <abstract trace info> option

     which returns SOME xxx if the tracability of values of this type
     can be determined statically (for now, if the head-normal form is
     known) and NONE otherwise.  If NONE is returned it is the
     reifier's responsibility to bind the constructor to a variable so
     that the type (and hence the tracability) will be available at
     run-time.

 (5) Adding code to the reifier to do a-normalization as it goes seems
     rather redundent at the moment; especially since Perry is
     currently working on Stephanie's CSE optimizer, which also requires
     A-normal form.  We therefore intend to either keep the program in
     A-normal form or normalize it just before calling these two
     passes.  In particular, I'll write the reifier to assume the
     input has been normalized.


------------------------------------------------------------------------    
April 21-22 Perry

	
	I incorporated Morgan's hoister and Stephanie's ExpTable
into TILT.  Also, the linearizer now actually linearizes as well
as renames.  The optimizer has been enahnced to perform CSE.
Preliminary results indicates that linearization, hosisting, and CSE
decrease code size by 10-20%.

	Using A-normal form on constructors and terms help
hoisting and CSE but a-normalizing types can have a deleterious 
effect on compilation time.  By just anormalizing types,
we can end up with many occurrences of Let_c types which require
a lot of work to reduce back to head-normal form.  This may not be 
so bad if the bindings are lifted followed by un-a-normalizing the types.
For some test files, naively anormalizing types causes the optimizer
to take twice as long and tortl to take four times as long.

	In experimenting with the optimizations, I discovered two
bugs.  First, the closure converter does not handle free variables
of type floating-point.  Second, tortl does not handle top-level
variables of type floating-point.  As a workaround, I have disabled the
hoister and CSE for unboxed floating-point terms.

------------------------------------------------------------------------

April 26

	The optimzer rather than tortl is now responsible for
lifting out the polymorphic array operations.  THe lifting
is needed so we don't get too many copies of these operations
which are rather lengthy.
	
	Since the optimizer binds variables rather early,
we eneded up with NIL variables with their integer parts
in the teens.  This had the bizarre effect that tortl
translated them to RTL variables with the same low nbumbers.
Unfortunately, these were then mapped to physical registers.
In particular, I was fortunate enough to have the heap pointer
trashed so I detected this quite quickly.  If it had been
a normal physical register, this would have been very hard to 
figure out.

------------------------------------------------------------------------

April 27

Primitives have been changed in the following ways:

(1) Reference operations are now HIL-only primitives.
	During phase-splitting, these are converted 
	to array primitives.

(2) We now have Int(Array/vector), Float(Array/vector),
	and Other(Array/vector).  The int and float
	versions carry the int/float size of the items.
	The bool on the "Other" version indicates whether
	the type of the element is reducible to HNF.

I fixed some nasty bugs in tortl-sum and tortl-array.

TILT compilation times:
				non-cumulative	cumulative
Basis				11 min		1.5meg
part of NJ lib used by TILT	3.5 min
Util				3 min
Parser				14.5 min	3.4meg
=========================================================
Total				92 min		9meg


------------------------------------------------------------------------

April 28  Chris

I've checked-in the first version of the reifier, which works
essentially as described above.  Main changes were to:

   nil.sig.sml    added a niltrace datatype, and annotation to Exp_b
   traceinfo.sig.sml
   traceinfo.sml       rtl-like datatype for nil tracability 
   traceops.sig.sml
   traceops.sml        contains get_trace : ctxt * con -> traceinfo

(It would be nice to merge traceinfo and traceops, or put the
traceops with nilutil, but either of these would create cyclic
dependencies.)

Several other nil files and tortl have been modified to insert
TraceUnknown on Exp_b bindings, or to preserve the niltrace annotation
when modifying bindings.  

toclosure and tortl do not (yet) use the niltrace annotations.  The
only benefit they get from the reifier is that classifiers on function
arguments will now always either have a known hnf or be a (small)
path.  (This may require placing type bindings between the two
lambdas of a polymorphic function, which may inhibit uncurrying
unless these are made into extra type arguments.)

Although primitives such as record creation are not actually passed
type arguments (which are officially needed to determine the
traceability of the record components), if we're in A-normal form at
the expression level we're guaranteed that tortl can determine the
tracability of all the components because it will know the tracability
of all variables.
