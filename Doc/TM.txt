-*- outline -*-

<<Write an abstract.>>

* Project Description

The following is a high-level description of our project description
language. In order not to confuse issues, our concrete syntax for
describing projects is explained in a later section.

A project is made up of a number of compilation units and a mapfile.

** Mapfile

A mapfile is is a list of compilation units in "use"-file order. It
introduces names for the compilation units and maps them to
implementation and interface files. Compilation unit names are
arbitrary, though the name of a compilation unit typically matches the
structure, signature, or functor defined within. TILT doesn't support
a notion of shadowing compilation unit names so within a mapfile, all
names must be distinct.

Since the mapfile is ordered, it serves the important function of
specifying the order of effects for the project. The mapfile also
specifies some number of targets (possibly zero); executables will be
built for these.

** Compilation Unit

A compilation unit is an implementation, an interface, and a set of
dependencies.

*** Implementation

Every compilation unit has SML source implementing it. Our units can
consist of any number of top-level declarations, such as signature or
value decs.

An example implementation:

	structure S :> SIG =
	struct
	...
	end

	val x = 7

	type t = int

*** Interface

Every compilation unit has an interface consisting of an optional,
user-supplied external interface and a compiler-generated internal
interface. External interfaces are used to support separate
compilation (see below).

**** External Interface

An external interface is a series of structure and value descriptions
as they might appear in a signature ('spec' in the Definition; p14),
perhaps:

	structure S : SIG

	val x : int

If an external interface is provided for a compilation unit, then at
compilation time, TILT checks that the implementation matches the
interface through a process similar to opaque signature ascription.
An external interface can be used to hide top-level declarations and
type information provided in the implementation.

Although TILT only supports structure and value descriptions in an
external interface, we have no compelling argument against supporting
other kinds of descriptions.

**** Internal Interface

An internal interface is the list of context entries generated by
elaborating the compilation unit according to the Harper and Stone
interpretation of Standard ML (see their 1997 technical report).

TILT generates an internal interface for every compilation unit. An
elaboration context is built by combining the internal interfaces of
the unit's direct and indirect ancestors while hiding the top-level
labels provided by indirect ancestors. The unit's source code is
elaborated in this context yielding internal language code for the
unit and an internal interface. If an external interface is provided,
it is used to constrain the internal interface. By hiding labels, TILT
requires that all the free identifiers of a unit be provided by its
direct ancestors (hereafter: parents).

*** Dependencies

Compilation units specify the units that they depend on. Dependencies
are specified using the compilation unit names defined in the
mapfile. Only a unit's parents are specified.

**** Order Among Dependencies

We decided the order that a unit's dependencies are specified should
not be important. Therefore, we have no notion of one parent shadowing
another; it is an error when (a) two units declare the same top-level
identifier and (b) a third unit depends (directly or indirectly) on
both.

It is permitted to shadow identifiers within a compilation unit. For
example, the source code "structure S = struct end; structure S =
struct end" is accepted.

It is permitted for two units in the same project to "conflict" in the
sense of (a) as long as they have no dependents in common. This is
possible, for example, when the project has more than one target or
includes units not depended on by any target.

Condition (b) could be relaxed to generate errors only for direct
mutual dependencies.

**** File Dependencies

Currently, a unit's implementation and external interface are stored
in separate files. For each file, those units necessary to elaborate
that file are specified. When both files are present, they are
elaborated together in a context built up from both sets of units.

The dependencies specified for a unit's external interface file and
it's implementation file may be different. For example,

	--- implementation: dependencies are SplayTree, MAP, ... ---

	structure Map : MAP =
	struct
	type ('a, 'b) map = ('a, 'b) SplayTree.splaytree
	...
	end

	--- external interface: dependency is MAP ---

	structure Map : MAP

To elaborate the external interface in isolation, the unit SplayTree
is not required. The dependencies for the implementation do not
necessarily include the dependencies for the interface, either:

	--- implementation: no dependencies ---

	structure Str =
	struct
	val x = 5
	end

	--- interface: dependency is SIG ---

	structure Str : SIG

* Concrete Syntax

We now describe the concrete syntax for mapfiles, the concrete syntax
for file dependencies, and some specifics related to the Basis
Library.

** Mapfiles

A mapfile is a line-oriented list of compilation units. Each line in a
mapfile is either a unit specification or an include directive.
Comments in a mapfile begin with // and extend to the end of the line.

*** Unit Specification

A unit specification looks like either

	A path

or

	A path TARGET

where `A' is the unit's name, `path' is a Unix-style path, resolved
relative to the directory containing the mapfile, to the unit's source
file (path.sml) and optional external interface file (path.int), and
TARGET, if present, indicates that unit A is a target. If no targets
are specified, TILT treats the last unit in the mapfile as a target.
(Recall that TILT will build executables for the targets.)

Another reasonable design would be to require that source and external
interface filenames be provided explicitly. This would eliminate the
special treatment of suffixes like ".sml" and ".int". More importantly,
this would make explicit in the project description whether a unit is
constrained by an external interface. Currently, you have to examine
the file system to answer this question.

*** Include Directive

An include directive looks like

	#include path

where `path' is a Unix-style path to a mapfile. The contents of the
included mapfile are considered in place of the include
directive. TILT performs a simple search to resolve the path: first
TILT tries to resolve the path relative to the mapfile, then TILT
tries to resolve the path relative to a designated TILT library
directory (where a compiled copy of the basis library is stored).

*** Mapfile Example

Here is a complete example of a mapfile. In addition to the hundreds
of Basis Library units, this mapfile specifies two non-target units
and a target unit Main:

	// simple mapfile
	#include mapfile-basis

	MAP map-sig
	Map map
	Main main TARGET

Focusing on the unit named Map, the compiler looks for the source in
file map.sml and for an external interface in map.int.

** Dependencies

Inside an SML file, the (direct) file dependencies for the
implementation are given using the import directive (a special
comment). Import directives specify unit names as defined in the
mapfile, not file names. For example, map.sml might contain:

	(*$import MAP SplayTree *)

	structure Map :> MAP =
	struct
	...
	end

Inside an external interface file, the file dependencies are given
with a similar include directive. For example, map.int might contain:

	(*$include MAP *)

	structure Map : MAP

Import directives only appear within an implementation, and include
directives only appear within an external interface.

Another reasonable design would have been to store dependency
information outside of the source and external interface files. For
example, inside the mapfile. This would make it easier for automated
tools to prepare a project for compilation with TILT. This would
require that more checks be performed to determine when a unit is
changed (see the section on cut-off recompilation below).

** Basis Library

We used a simple rule to divide our basis library implementation into
compilation units and to name those units.

Most basis structures, signatures, and functors are defined in a
compilation unit of the same name. Example unit names include List,
LIST, and TextIO. The exceptions are IO_SIG, OS_SIG, and SML90_SIG.
These name the units providing the signatures IO, OS, and SML90,
respectively. The unit names IO, OS, and SML90 provide the
corresponding structures.

TILT requires that every compilation unit depend on the units named
Prelude and TopLevel. Together, these units provide the terms and
types bound at the top level like print, map, etc. These units are
part of our basis library implementation so TILT requires that every
project description "include" mapfile-basis. Of course, these
conventions are for user-level code and aren't strictly adopted by the
basis library implementation.

* Cut-off Recompilation

TILT supports cut-off recompilation (see Adams et al 1994).

** Description

One way to understand cut-off recompilation is as an improvement over
the simple strategy of cascading recompilation. Adams et al describe
cascading recompilation. ``A dependency relation is imposed upon
compilation units. When a unit changes, its directly and indirectly
dependent units are compiled also.'' With cut-off recompilation, this
strategy is enhanced by comparing old and new compiler outputs. ``If
the old and new compiler outputs for a unit do not differ, then no
change can propagate out of that unit. It is therefore safe to cut off
further compilations of dependents of that unit.''

** Recompilation Rule

TILT uses a simple rule to govern when a unit must be recompiled. A
compilation unit must be recompiled when (1) it is changed, or (2) the
internal interface of a parent unit is changed.

** When to Cut Off

Condition (2) justifies the name "cut-off recompilation". Changes to a
unit's indirect ancestors do not necessarily cause the unit to be
recompiled.

For example, if the source of unit A is

	type t = int

and the source of unit B (which depends on A) is

	structure S :> sig type t end = struct type t = t end

then changes to the definition of type t in unit A will not (due to
the opaque signature ascription) change the internal interface of unit
B and so will not cause dependents of unit B to be recompiled.

*** Two Timestamps

To properly implement condition (2), TILT must keep track of two
timestamps for each unit A:

	lastWritten(A) = time when A's internal interface was written
	lastChecked(A) = time when A was compiled

To implement (2) given a unit A and a parent unit B, TILT checks
whether lastWritten(B) <= lastChecked(A).

*** Problem with One Timestamp

The compiler would do too much work if condition (2) were implemented
using only the lastWritten timestamp.

To see why, consider the situation with three units named A, B, and C
where C depends on B, B depends on A, and there are no other
dependencies. Assume that initially everything is up-to-date. We have
lastWritten(A) < lastWritten(B) < lastWritten(C). Now assume unit A is
modified so as to change A's internal interface but not B's and that
the compiler is told to bring everything up to date. Since A was
modified, it must be recompiled. A has a new internal interface that
must be written. We now have lastWritten(A) > lastWritten(B), so B
must be recompiled. B's internal interface is unchanged. We can either
discard or write the new copy. In either case, the compiler will do
too much work.

Case 1: If we discard the new copy, we will not have changed the state
that lastWritten(A) > lastWritten(B). When next the compiler is told
to bring everything up to date, it will needlessly recompile unit B.

Case 2: If we write the new copy, we will have lastWritten(B) >
lastWritten(C). The compiler will needlessly recompile unit C.

** Noticing Change

TILT considers a unit to have changed when (a) its source code is
changed, (b) an external interface for the unit is added, removed, or
changed, or (c) its set of parent units is changed.

These conditions are a little peculiar. We must motivate (c) and
explain the asymmetry between (a) and (b).

*** Dependencies Change

It is necessary to consider a unit changed when its set of parent
units is changed. As described above, the internal interfaces of a
unit's parents provide typing information for the free identifiers in
that unit. Changing the set of parents could invalidate typing
assumptions and so requires the unit to be recompiled.

TILT does not explicitly check (c) since dependency information is
stored in the same files that hold source code and external interfaces
and TILT notices ((a) and (b)) when these files are modified.

*** Source Code Changes

The reason that (a) is simpler than (b) is currently TILT does not
support separate compilation. This is a bug in TILT. We will discuss
separate compilation next.

* Separate Compilation

Separate compilation means different things to different people.  We
think it essential that a system supporting separate compilation can
use a compilation unit without having source code for that unit.

We stress that TILT does not currently support separate compilation.

** Unimplemented Units

To compile against a compilation unit that does not have an
implementation, we use external interfaces. An external interface can
be elaborated to produce the internal interface required for compiling
dependent units.

External interfaces only solve half the problem. In general, projects
with unimplemented units can not be linked and run. It must be
possible to fill in an unimplemented unit when an implementation
becomes available.

** Candidate Implementations

An implementation, viewed as a candidate for use with a formerly
unimplemented compilation unit, has an internal interface, object
code, and a unit environment.

A unit environment provides a specification for every parent of the
implementation. Currently, TILT implements a unit environment as a
finite map taking a unit's name to a hash of it's internal interface
file.

Candidates provided in source form can be compiled to obtain an
internal interface, object code, and a unit environment.

** Plugging in a Candidate

To use a candidate implementation in place of a formerly unimplemented
compilation unit, without forcing dependent units to recompile, we
must check that (a) the implementation's internal interface matches
the unit's external interface, (b) the implementation's internal
interface matches its object code, and (c) the implementation's unit
environment matches the units available up to this point in the
project description.

*** Interface Matching

We check (a) by first elaborating the external interface to an
internal interface and then matching the two internal interfaces.

Two internal interfaces are matched through a process similar to
opaque signature ascription. An implementation can provide more
components and more type information than the unit's external
interface.

In general, the compiler must provide coercions to handle the
difference between a unit's external interface and it's
implementation's internal interface.

*** Binary Certification

When source code is available, (b) presents no problem.  TILT can
recompile to ensure that the object code and the internal interface
come from the same source.

When source code is not available, TILT will simply trust that the
object file matches its internal interface. Work on extending TILT to
generate Typed Assembly Language is underway. It should eventually be
possible to certify that a binary matches an internal interface.

* Acknowledgements

Perry Cheng, Martin Elsmann, Robert Harper, Greg Morrisett, Leaf
Petersen, and Chris Stone contributed to the design of TILT's
compilation manager. The current version was implemented by Perry
Cheng and David Swasey.
