Here's a high-level description of the TILT project management system.
We were actually just looking at reworking the surface syntax (and also at
writing a CM import tool), so the prospect of standardizing on something
is exciting to us.

DESCRIPTION
-----------

The TILT make system has four components: mapfiles, import lists,
interface files, and include lists.

Mapfiles are analogous to UNIX makefiles and SML/NJ's .cm files.
Mapfiles do not need to have any particular suffix. Mapfiles map logical
module names to filenames and specify a set of targets (executables to
build). For example,

	FooBar Bar/foobar

in a mapfile would indicate that the logical module name FooBar is to be
associated with the file Baz/foobar.sml.  Note that the extension .sml
is omitted.  To specify that TILT should create an executable from FooBar
(and the modules it depends on), we would write

	FooBar Bar/foobar TARGET

Mapfiles support a simple include directive.  The line

	#include mapfile-basis

adds associations for the standard basis library to a mapfile. Most
basis structures, signatures, and functors are defined in a module of
the same name. Examples include List, LIST, and TextIO. The exceptions
are IO_SIG, OS_SIG, and SML90_SIG which provide signatures IO, OS, and
SML90. The logical names IO, OS, and SML90 provide the corresponding
structures. The logical names Prelude and TopLevel together provide the
terms and types bound at the top level like print, map, etc.

An import list is a specialized comment placed as the first line of an
SML source file. For example,

	(*$import FooBar Goo *)

as the first line of a file indicates that the file depends on the
modules named FooBar and Goo. A file can only depend on modules which
appear earlier in the mapfile.  If a file depends on a module that has
not been imported, then unbound variable errors will result.  For example,

	(*$import Prelude TopLevel *)
	val _ = TextIO.print "Hello, world"

will not compile because TextIO is missing from the import list.
Only direct dependencies need to be listed.

Interfaces specify the exports of a module (and their types). Interfaces
have include lists which play a role similar to import lists: they specify
which modules are necessary to elaborate the interface.  An interface
file contains a list of declarations as they might appear in a signature
('spec' in the Definition; p14).  For example,

	(*$include Prelude TopLevel MAIN *)
	structure Main : MAIN
	val x : int
	type t

describes the interface of a module providing a top-level structure
Main, value x, and type t.  This interface depends on signature MAIN
(presumably provided by module MAIN).

When processing a mapfile, TILT recompiles any files which are out-of-date
and generates an executable file for each TARGET.  For each mapfile entry

	Name base

TILT examines the filesystem to determine whether a source file
(base.sml), an interface file (base.int), or both have been provided.
We support both separate compilation (when the interface file is present)
and incremental recompilation (when it is not, it is generated by
elaboration of the source).

DISCUSSION
----------

A module can contain any number of top-level declarations. It can be
defined by an interface file, an implementation file, or both.

A module has two sets of dependencies called imports and includes.
We say "set" because order is not important inside import and include
lists.  Imports are the modules needed to compile the implementation;
includes are the modules necessary to elaborate the interface. Only
direct dependencies are listed.

A module can only depend on modules which are listed earlier in the
mapfile. Thus the order in which modules are listed gives a "use-file"
ordering. Specifying this ordering allows the user to decide on the
order in which effects take place.

Steve Weeks asked that there be an easy way to go from a project
description to an SML source file (without, for instance, doing dependency
analysis). This is almost the case with our system.

If there are no interface files, concatenating the source of the modules
in mapfile order gives such an SML source file.

If both an implementation and interface file are supplied, it is necessary
to check/seal the implementation with respect to the interface. This may
be possible with signature matching and 'open'.  Suppose we have a module
with source M and interface I. We can translate this to the following
(where N is a new structure name):

	structure N :> sig <text of I> end =
	struct

	  <text of M>

	end

	open N

One important problem with this translation is that it limits what users
can write in I and M.  For instance, functors and signatures can not
appear in SML'97 signatures and structures.

PLANNED IMPROVEMENTS
--------------------

We plan to move import and include lists out of the source and interface
files and into the mapfile.

We plan to eliminate the special treatment of suffixes .sml and .int
and to require the user to explicitly specify when source and interface
files are present.

Except when bootstrapping the compiler (in particular, when compiling
the Basis Library), the units Prelude and TopLevel must always be
imported/included.  Without them, users don't see a standard toplevel
environment.  We plan to eliminate this nuisance but we may not do so
by extending the project description language.

We haven't got a concrete proposal for fitting libraries into this
framework.  One issue here is that our module names must be globally
unique (they are used to generate symbols for the linker).

Tom Murphy
Dave Swasey
