#This file was created by <leaf> Thu Oct 15 20:52:38 1998
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass amsart-seq
\begin_preamble
\usepackage{latexsym}
\newcommand{\comment}[1]{}
\end_preamble
\language default
\inputencoding default
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 1
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout Standard


\begin_inset FormulaMacro 
\newcommand{\Lam}[3]{\lambda #1 ::#2 .#3 }

\end_inset 

 
\begin_inset FormulaMacro 
\newcommand{\Let}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}

\end_inset 

 
\begin_inset FormulaMacro 
\newcommand{\lete}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\rec}[7]{\mathrm{rec}\, #1 =\lambda (#2 ::#3 ,#4 :#5 ):#6 .#7 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\ifz}[3]{\mathrm{ifzero}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\st}[1]{S_{T}(#1 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\subst}[3]{\{#1 /#2 \}#3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\context}{\Delta }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\addk}[3]{#1 [#2 ::#3 ]}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\addt}[3]{#1 [#2 :#3 ]}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\caddk}[2]{\addk{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\caddt}[2]{\addt{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\extk}[2]{[#1 ::#2 ]}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\extt}[2]{[#1 :#2 ]}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\iffloat}[3]{\mathrm{ifBoxFloat}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }

\end_inset 

 
\begin_inset FormulaMacro 
\newcommand{\carray}[1]{#1 \: array}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\inl}[2]{inl_{#1 }#2 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\inr}[2]{inr_{#1 }#2 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\sumsw}[7]{case\, #1 \, of\, \{inl(#2 :#3 )\Rightarrow #4 ,inr(#5 :#6 )\Rightarrow #7 \}}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\arr}[3]{array_{#1 }(#2 ,#3 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\sub}[2]{sub(#1 ,#2 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\fsub}[2]{fsub(#1 ,#2 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\pikind}[3]{\Pi (#1 ::#2 ).#3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\sigkind}[3]{\Sigma (#1 ::#2 ).#3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\kone}{\kappa _{1}}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\ktwo}{\kappa _{2}}

\end_inset 


\layout Title

Core Nil
\layout Author

Leaf Petersen
\layout Section

Syntax
\layout Standard


\begin_inset Formula 
\begin{eqnarray*}
\kappa  & ::= & T\: |\: \st{c}\: |\: \Sigma (\alpha ::\kappa ).\kappa \: |\: \Pi (\alpha ::\kappa ).\kappa \\
 &  & \\
c & ::= & \alpha \mid Int\mid BoxFloat\mid \mu (a=c,b=c)\mid c\times c\mid c\rightarrow c\mid c+c\mid \carray{c}\\
 &  & \mid \Lam{\alpha }{\kappa }{c}\mid c\, c\mid <c,c>\mid c.1\mid c.2\mid \Let{\alpha }{c}{c}\\
 &  & \\
\tau  & ::= & c\mid (\alpha ::\kappa ,\tau )\rightarrow \tau \mid Float\mid \tau \times \tau \\
 &  & \\
p & ::= & \alpha \mid p.1\mid p.2\mid p\, c\\
 &  & \\
e & ::= & x\mid \lete{x}{e}{e}\mid \lete{\alpha }{c}{e}\mid \rec{f}{\alpha }{\kappa }{x}{\tau }{\tau }{e}\\
 &  & \mid e[c]e\mid <e,e>\mid e.1\mid e.2\mid n\mid r\mid box(e)\mid unbox(e)\mid \inl{c}{e}\mid \inr{c}{e}\\
 &  & \mid \sumsw{e}{x}{c}{e}{x}{c}{e}\mid \iffloat{c}{e}{e}\\
 &  & \mid \arr{c}{e}{e}\mid \sub{e}{e}\mid \fsub{e}{e}\\
 &  & \\
\Delta  & ::= & \bullet \mid \caddt{x}{\tau }\mid \caddk{\alpha }{\kappa }
\end{eqnarray*}

\end_inset 


\layout Standard

I occasionally use 
\begin_inset Formula \( \kappa _{1}\times \kappa _{2} \)
\end_inset 

 for 
\begin_inset Formula \( \Sigma (\alpha ::\kappa _{1}).\kappa _{2} \)
\end_inset 

where 
\begin_inset Formula \( \alpha \notin fv(\kappa _{2}) \)
\end_inset 


\layout Standard


\begin_inset FormulaMacro 
\newcommand{\infrule}[2]{\frac{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\axiom}[1]{\overline{#1 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\deltaok}[1]{#1 \, \mathrm{ok}}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\kindok}[2]{#1 \vdash #2 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\kok}[1]{\kindok{\context }{#1 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\typeok}[2]{#1 \vdash #2 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\tok}[1]{\typeok{\context }{#1 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\conok}[3]{#1 \vdash #2 ::#3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\cok}[2]{\conok{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\klessthan}[3]{#1 \vdash #2 \preceq #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\klt}[2]{\klessthan{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\eqcon}[4]{#1 \vdash #2 \equiv #3 ::#4 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\eqtype}[3]{#1 \vdash #2 \equiv #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\expok}[3]{#1 \vdash #2 :#3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\eok}[2]{\expok{\context }{#1 }{#2 }}

\end_inset 


\layout Section

The declarative system (MIL)
\layout Subsection

Well Formed Context 
\layout Description

Empty 
\begin_inset Formula 
\[
\axiom{\deltaok{\bullet }}\]

\end_inset 


\layout Description

Kind 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\deltaok{\context } & \kok{\kappa }
\end{array}}{\deltaok{\caddk{\alpha }{\kappa }}}\quad \alpha \notin dom(\context )\]

\end_inset 


\layout Description

Type 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\deltaok{\context } & \tok{\tau }
\end{array}}{\deltaok{\caddt{\alpha }{\tau }}}\quad x\notin dom(\context )\]

\end_inset 


\layout Subsection

Well Formed Kind 
\begin_inset Formula \( \kindok{\context }{\kappa } \)
\end_inset 


\layout Description

Type 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\kindok{\context }{T}}\]

\end_inset 


\layout Description

Singleton 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c}{T}
\end{array}}{\kok{\st{c}}}\]

\end_inset 


\layout Description

Pi 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kok{\kappa _{1}} & \kindok{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}}
\end{array}}{\kok{\Pi (\alpha ::\kappa _{1}).k_{2}}}\]

\end_inset 


\layout Description

Sigma 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kok{\kappa _{1}} & \kindok{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}}
\end{array}}{\kok{\sigkind{\alpha }{\kone }{\ktwo }}}\]

\end_inset 


\layout Subsection

Sub-Kinding 
\begin_inset Formula \( \klt{\kone }{\ktwo } \)
\end_inset 


\layout Description

Type 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\klt{T}{T}}\]

\end_inset 


\layout Description

Singleton 
\begin_inset Formula 
\[
\infrule{\kok{\st{c}}}{\klt{\st{c}}{T}}\]

\end_inset 


\layout Description

Singletons 
\begin_inset Formula 
\[
\infrule{\eqcon{\context }{c}{d}{T}}{\klt{\st{c}}{\st{d}}}\]

\end_inset 


\layout Description


\begin_inset Formula \( \Pi  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\klt{\kone '}{\kone } & \klessthan{\caddk{\alpha }{\kone '}}{\ktwo }{\ktwo '}
\end{array}}{\klt{\pikind{\alpha }{\kone }{\ktwo }}{\pikind{\alpha }{\kone '}{\ktwo '}}}\]

\end_inset 


\layout Description


\begin_inset Formula \( \Sigma  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\klt{\kone }{\kone '} & \klessthan{\caddk{\alpha }{\kone }}{\ktwo }{\ktwo '}
\end{array}}{\klt{\sigkind{\alpha }{\kone }{\ktwo }}{\sigkind{\alpha }{\kone '}{\ktwo '}}}\]

\end_inset 


\layout Subsection

Well-formed constructor 
\begin_inset Formula \( \cok{c}{\kappa } \)
\end_inset 


\layout Description

Variable 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\cok{\alpha }{\context (\alpha )}}\]

\end_inset 


\layout Description

BoxFloat 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\cok{BoxFloat}{T}}\]

\end_inset 


\layout Description

Int 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\cok{Int}{T}}\]

\end_inset 


\layout Description


\begin_inset Formula \( \mu  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\conok{\Delta [a::T,b::T]}{c_{1}}{T} & \conok{\Delta [a::T,b::T]}{c_{2}}{T}
\end{array}}{\cok{\mu (a=c_{1},b=c_{2})}{T}}\]

\end_inset 

 
\layout Description

Pair 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c_{1}}{T} & \cok{c_{2}}{T}
\end{array}}{\cok{c_{1}\times c_{2}}{T}}\]

\end_inset 


\layout Description

Arrow 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c_{1}}{T} & \cok{c_{2}}{T}
\end{array}}{\cok{c_{1}\rightarrow c_{2}}{T}}\]

\end_inset 


\layout Description

Sum 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c_{1}}{T} & \cok{c_{2}}{T}
\end{array}}{\cok{c_{1}+c_{2}}{T}}\]

\end_inset 


\layout Description

Array 
\begin_inset Formula 
\[
\infrule{\cok{c}{T}}{\cok{\carray{c}}{T}}\]

\end_inset 


\layout Description

Lambda 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kok{\kappa } & \conok{\caddk{\alpha }{\kappa }}{c}{\kappa '}
\end{array}}{\cok{\lambda (\alpha ::\kappa ).c}{\pikind{\alpha }{\kappa }{\kappa '}}}\]

\end_inset 


\layout Description

App 
\begin_inset Formula 
\[
\infrule{\begin{array}{cc}
\begin{array}{ll}
\cok{c_{1}}{\pikind{\alpha }{\kappa _{1}}{\ktwo }} & \cok{c_{2}}{\kone }
\end{array}
\end{array}}{\cok{c_{1}\, c_{2}}{\subst{c_{2}}{\alpha }{\ktwo }}}\]

\end_inset 


\layout Description

Record 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c_{1}}{\kone } & \cok{c_{2}}{\ktwo }
\end{array}}{\cok{<c_{1},c_{2}>}{\kone \times \ktwo }}\]

\end_inset 


\layout Description

Proj1 
\begin_inset Formula 
\[
\infrule{\cok{c}{\sigkind{\alpha }{\kone }{\ktwo }}}{\cok{c.1}{\kone }}\]

\end_inset 


\layout Description

Proj2 
\begin_inset Formula 
\[
\infrule{\cok{c}{\sigkind{\alpha }{\kone }{\ktwo }}}{\cok{c.2}{\subst{c.1}{\alpha }{\ktwo }}}\]

\end_inset 


\layout Description

Let 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c_{1}}{\kone } & \conok{\caddk{\alpha }{\kone }}{c_{2}}{\ktwo }
\end{array}}{\cok{\Let{\alpha }{c_{1}}{c_{2}}}{\subst{c_{1}}{\alpha }{\ktwo }}}\]

\end_inset 


\layout Description

Selfify 
\begin_inset Formula 
\[
\infrule{\cok{c}{T}}{\cok{c}{\st{c}}}\]

\end_inset 


\layout Description

Subkind 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c}{\kappa } & \klt{\kappa }{\kappa '}
\end{array}}{\cok{c}{\kappa '}}\]

\end_inset 


\layout Description

Sigma
\protected_separator 
Eta1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c}{\sigkind{\alpha }{\kone }{\ktwo }} & \cok{c.1}{\kone '}
\end{array}}{\cok{c}{\sigkind{\alpha }{\kone '}{\ktwo }}}\]

\end_inset 


\layout Description

Sigma
\protected_separator 
Eta2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c}{\sigkind{\alpha }{\kone }{\ktwo }} & \conok{\caddk{\alpha }{\kone }}{c.2}{\ktwo '}
\end{array}}{\cok{c}{\sigkind{\alpha }{\kone }{\ktwo '}}}\]

\end_inset 


\layout Description

Pi
\protected_separator 
Eta 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c}{\pikind{\alpha }{\kone }{\ktwo }} & \conok{\caddk{\alpha }{\kone }}{c\, \alpha }{\ktwo '}
\end{array}}{\cok{c}{\pikind{\alpha }{\kone }{\ktwo '}}}\]

\end_inset 


\layout Subsection

Well-formed Type 
\begin_inset Formula \( \tok{\tau } \)
\end_inset 


\layout Description

Constructor 
\begin_inset Formula 
\[
\frac{\cok{c}{T}}{\tok{c}}\]

\end_inset 


\layout Description

ArrowType 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\kok{\kappa } & \\
\typeok{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typeok{\caddk{\alpha }{\kappa }}{\tau _{2}}
\end{array}}{\tok{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\]

\end_inset 


\layout Description

Float 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\tok{Float}}\]

\end_inset 


\layout Description

PairType 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\tok{\tau _{1}} & \tok{\tau _{2}}
\end{array}}{\tok{\tau _{1}\times \tau _{2}}}\]

\end_inset 


\layout Subsection

Well-typed term: 
\begin_inset Formula \( \eok{e}{\tau } \)
\end_inset 


\layout Description

variable 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\eok{x}{\context (x)}}\]

\end_inset 


\layout Description

lete 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\eok{e_{1}}{\tau _{1}} & \expok{\caddt{x}{\tau _{1}}}{e_{2}}{\tau _{2}}
\end{array}}{\eok{\lete{x}{e_{1}}{e_{2}}}{\tau _{2}}}\]

\end_inset 


\layout Description

letc 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\cok{c}{\kappa } & \expok{\caddk{\alpha }{\kappa }}{e}{\tau }
\end{array}}{\eok{\lete{\alpha }{c}{e}}{\tau }}\]

\end_inset 


\layout Description

rec 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kok{\kappa } & \typeok{\caddk{\alpha }{\kappa }}{\tau _{1}}\\
\typeok{\caddk{\alpha }{\kappa }}{\tau _{2}} & \expok{\context \extt{f}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}\extk{\alpha }{\kappa }\extt{x}{\tau _{1}}}{e}{\tau _{2}}
\end{array}}{\eok{\rec{f}{\alpha }{\kappa }{x}{\tau _{1}}{\tau _{2}}{e}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\]

\end_inset 


\layout Description

app 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\eok{e_{1}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}} & \cok{c}{\kappa } & \eok{e_{2}}{\subst{c}{\alpha }{\tau _{1}}}
\end{array}}{\eok{e_{1}[c]e_{2}}{\tau _{2}}}\]

\end_inset 


\layout Description

app2 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\eok{e_{1}}{c_{1}\rightarrow c_{2}} & \eok{e_{2}}{c_{1}}
\end{array}}{\eok{e_{1}\, e_{2}}{c_{2}}}\]

\end_inset 


\layout Description

pair 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\eok{e_{1}}{\tau _{1}} & \eok{e_{2}}{\tau _{2}}
\end{array}}{\eok{<e_{1},e_{2}>}{\tau _{1}\times \tau _{2}}}\]

\end_inset 


\layout Description

type_proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\eok{e}{\tau _{1}\times \tau _{2}}
\end{array}}{\eok{e.1}{\tau _{1}}}\]

\end_inset 


\layout Description

con_proj1 
\begin_inset Formula 
\[
\infrule{\eok{e}{c_{1}\times c_{2}}}{\eok{e.1}{c_{1}}}\]

\end_inset 


\layout Description

type_proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\eok{e}{\tau _{1}\times \tau _{2}}
\end{array}}{\eok{e.2}{\tau _{2}}}\]

\end_inset 


\layout Description

con_proj2 
\begin_inset Formula 
\[
\infrule{\eok{e}{c_{1}\times c_{2}}}{\eok{e.2}{c_{2}}}\]

\end_inset 


\layout Description

float 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\eok{r}{Float}}\]

\end_inset 


\layout Description

int 
\begin_inset Formula 
\[
\infrule{\deltaok{\context }}{\eok{n}{Int}}\]

\end_inset 


\layout Description

box 
\begin_inset Formula 
\[
\infrule{\eok{e}{Float}}{\eok{box(e)}{BoxFloat}}\]

\end_inset 


\layout Description

unbox 
\begin_inset Formula 
\[
\infrule{\eok{e}{BoxFloat}}{\eok{unbox(e)}{Float}}\]

\end_inset 


\layout Description

sumswitch 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c_{1}}{T} & \expok{\caddt{x_{1}}{c_{1}}}{e_{1}}{\tau }\\
\cok{c_{2}}{T} & \expok{\caddt{x_{2}}{c_{2}}}{e_{2}}{\tau }\\
\eok{e}{c_{1}+c_{2}} & 
\end{array}}{\eok{\sumsw{e}{x_{1}}{c_{1}}{e_{1}}{x_{2}}{c_{2}}{e_{2}}}{\tau }}\]

\end_inset 


\layout Description

inl 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c}{T} & \eqcon{\context }{c}{c_{1}+c_{2}}{T}\\
\eok{e}{c_{1}} & 
\end{array}}{\eok{\inl{c}{e}}{c_{1}+c_{2}}}\]

\end_inset 


\layout Description

inr 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c}{T} & \eqcon{\context }{c}{c_{1}+c_{2}}{T}\\
\eok{e}{c_{2}} & 
\end{array}}{\eok{\inr{c}{e}}{c_{1}+c_{2}}}\]

\end_inset 


\layout Description

ifBoxFloat 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{c}{T} & \eok{e_{1}}{\tau }\\
\eok{e_{2}}{\tau } & 
\end{array}}{\eok{\iffloat{c}{e_{1}}{e_{2}}}{\tau }}\]

\end_inset 


\layout Description

array 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\eok{e_{1}}{Int} & \cok{c}{T}\\
\eok{e_{2}}{c} & 
\end{array}}{\eok{\arr{c}{e_{1}}{e_{2}}}{\carray{c}}}\]

\end_inset 


\layout Description

sub 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\eok{e_{1}}{\carray{c}} & \eok{e_{2}}{Int}
\end{array}}{\eok{\sub{e_{1}}{e_{2}}}{c}}\]

\end_inset 


\layout Description

fsub 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\eok{e_{1}}{\carray{BoxFloat}} & \eok{e_{2}}{Int}
\end{array}}{\eok{\fsub{e_{1}}{e_{2}}}{Float}}\]

\end_inset 


\layout Section

Judgements for the algorithmic core nil
\layout Standard


\begin_inset FormulaMacro 
\newcommand{\kindvalid}[2]{#1 \models #2 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\kindsynth}[3]{#1 \models #2 \Uparrow #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\subkind}[3]{#1 \models #2 \preceq #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\conequiv}[4]{#1 \models #2 \equiv #3 ::#4 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\coneq}[3]{\models }

\end_inset 

 
\begin_inset FormulaMacro 
\newcommand{\typevalid}[2]{#1 \models #2 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\typev}[1]{\typevalid{\Delta }{#1 }}

\end_inset 


\layout Standard


\begin_inset FormulaMacro 
\newcommand{\typesynth}[3]{#1 \models #2 \Uparrow #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\types}[2]{\typesynth{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\typeequiv}[3]{#1 \models #2 \equiv #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\typeeq}[2]{\typeequiv{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\hnf}[3]{#1 \models #2 \Longrightarrow #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\Hnf}[2]{\hnf{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\pathextract}[3]{#1 \models #2 \leadsto #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\pext}[2]{\pathextract{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\selfify}[3]{#1 ::#2 \doteq #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\kcheck}[3]{#1 \models #2 \Downarrow #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\betared}[3]{#1 \models #2 \rightarrow #3 }

\end_inset 


\layout Standard


\begin_inset FormulaMacro 
\newcommand{\tcheck}[3]{#1 \models #2 \Downarrow #3 }

\end_inset 

 
\layout Subsection

Sub-Kinding 
\begin_inset Formula \( \subkind{\Delta }{\kappa _{1}}{\kappa _{2}} \)
\end_inset 


\layout Standard

Assume that 
\begin_inset Formula \( \Delta  \)
\end_inset 

, 
\begin_inset Formula \( \kappa _{1} \)
\end_inset 

 and 
\begin_inset Formula \( \kappa _{2} \)
\end_inset 

 are well-formed.
 Check that 
\begin_inset Formula \( \kappa _{1} \)
\end_inset 

 is a subkind of 
\begin_inset Formula \( \kappa _{2} \)
\end_inset 

.
\layout Standard

TS: Termination
\layout Standard

TS: if 
\begin_inset Formula \( \klt{\kone }{\ktwo } \)
\end_inset 

, then 
\begin_inset Formula \( \subkind{\context }{\kone }{\ktwo } \)
\end_inset 


\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

, 
\begin_inset Formula \( \kok{\kone } \)
\end_inset 

, 
\begin_inset Formula \( \kok{\ktwo } \)
\end_inset 

, and 
\begin_inset Formula \( \subkind{\context }{\kone }{\ktwo } \)
\end_inset 

, then 
\begin_inset Formula \( \klt{\kone }{\ktwo } \)
\end_inset 


\layout Description

Type 
\begin_inset Formula 
\[
\axiom{\subkind{\Delta }{T}{T}}\]

\end_inset 


\layout Description

Singleton 
\begin_inset Formula 
\[
\axiom{\subkind{\Delta }{\st{c}}{T}}\]

\end_inset 


\layout Description

Singletons 
\begin_inset Formula 
\[
\infrule{\conequiv{\Delta }{c}{d}{T}}{\subkind{\Delta }{\st{c}}{\st{d}}}\]

\end_inset 


\layout Description


\begin_inset Formula \( \Pi  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}'}{\kappa _{1}} & \subkind{\Delta [\alpha ::\kappa _{1}']}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout Description


\begin_inset Formula \( \Sigma  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}}{\kappa _{1}'} & \subkind{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout Subsection

Selfification 
\begin_inset Formula \( \selfify{c}{\kappa }{\kappa '} \)
\end_inset 


\layout Standard

This is the definition of selfification.
 Assume 
\begin_inset Formula \( c \)
\end_inset 

 and 
\begin_inset Formula \( \kappa  \)
\end_inset 

 are well-formed with respect to some context.
 Return the most precise kind of 
\begin_inset Formula \( c \)
\end_inset 

.
 Intuitively, this is the definition of a singleton at the higher kind.
 
\layout Standard

TS: if 
\begin_inset Formula \( \kok{\kappa } \)
\end_inset 

, 
\begin_inset Formula \( \cok{c}{\kappa } \)
\end_inset 

, and 
\begin_inset Formula \( \selfify{c}{\kappa }{\kappa '} \)
\end_inset 

, then 
\begin_inset Formula \( \cok{c}{\kappa '} \)
\end_inset 

.
\layout Standard

TS: if 
\begin_inset Formula \( \kok{\kappa } \)
\end_inset 

, 
\begin_inset Formula \( \cok{c}{\kappa } \)
\end_inset 

, and 
\begin_inset Formula \( \selfify{c}{\kappa }{\kappa '} \)
\end_inset 

, then for all 
\begin_inset Formula \( \kappa '' \)
\end_inset 

 such that 
\begin_inset Formula \( \cok{c}{\kappa ''} \)
\end_inset 

, 
\begin_inset Formula \( \klt{\kappa '}{\kappa ''} \)
\end_inset 

 
\layout Description

Type 
\begin_inset Formula \( \selfify{c}{T}{\st{c}} \)
\end_inset 


\layout Description

Singleton 
\begin_inset Formula \( \selfify{c}{\st{d}}{\st{d}} \)
\end_inset 


\layout Description


\begin_inset Formula \( \Pi  \)
\end_inset 

 
\begin_inset Formula \( \selfify{c}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}'} \)
\end_inset 

 
\newline 
where 
\begin_inset Formula \( \selfify{c\, \alpha }{\kappa _{2}}{\kappa _{2}'} \)
\end_inset 


\layout Description


\begin_inset Formula \( \Sigma  \)
\end_inset 

 
\begin_inset Formula \( \selfify{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \)
\end_inset 

 
\newline 
where 
\begin_inset Formula \( \selfify{c.1}{\kappa _{1}}{\kappa _{1}'} \)
\end_inset 

 and 
\begin_inset Formula \( \selfify{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}{\kappa _{2}'} \)
\end_inset 


\layout Subsection

Kind Analysis 
\begin_inset Formula \( \kcheck{\context }{c}{\kappa } \)
\end_inset 


\layout Standard

Assume 
\begin_inset Formula \( \context  \)
\end_inset 

 and 
\begin_inset Formula \( \kappa  \)
\end_inset 

 are well formed.
 Check that 
\begin_inset Formula \( c \)
\end_inset 

 is well formed and can be given kind 
\begin_inset Formula \( \kappa  \)
\end_inset 

.
\layout Standard

TS: if 
\begin_inset Formula \( \cok{c}{\kappa } \)
\end_inset 

then 
\begin_inset Formula \( \kcheck{\context }{c}{\kappa } \)
\end_inset 

.
\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

, 
\begin_inset Formula \( \kok{\kappa } \)
\end_inset 

 and 
\begin_inset Formula \( \kcheck{\context }{c}{\kappa } \)
\end_inset 

, then 
\begin_inset Formula \( \cok{c}{\kappa } \)
\end_inset 


\layout Standard


\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa '} & \subkind{\context }{\kappa '}{\kappa }
\end{array}}{\kcheck{\context }{c}{\kappa }}\]

\end_inset 


\layout Subsection

Kind Synthesis 
\begin_inset Formula \( \kindsynth{\Delta }{c}{\kappa } \)
\end_inset 


\layout Standard

Assumes that 
\begin_inset Formula \( \Delta  \)
\end_inset 

 is well-formed.
 Check that c is well-kinded, and construct 
\begin_inset Formula \( \kappa  \)
\end_inset 

 s.t.
 
\begin_inset Formula \( \kindvalid{\Delta }{\kappa } \)
\end_inset 

 and c has kind 
\begin_inset Formula \( \kappa  \)
\end_inset 

.
 
\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

, and 
\begin_inset Formula \( \kindsynth{\context }{c}{\kappa } \)
\end_inset 

 then 
\begin_inset Formula \( \kok{\kappa } \)
\end_inset 


\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

, and 
\begin_inset Formula \( \kindsynth{\context }{c}{\kappa } \)
\end_inset 

 then 
\begin_inset Formula \( \cok{c}{\kappa } \)
\end_inset 

.
\layout Standard

TS: if 
\begin_inset Formula \( \cok{c}{\kappa } \)
\end_inset 

, then 
\begin_inset Formula \( \kindsynth{\context }{c}{\kappa '} \)
\end_inset 

, such that 
\begin_inset Formula \( \klt{\kappa '}{\kappa } \)
\end_inset 


\layout Description

Variable 
\begin_inset Formula 
\[
\infrule{\selfify{\alpha }{\kappa }{\kappa '}}{\kindsynth{\Delta [\alpha ::\kappa ]}{\alpha }{\kappa }'}\]

\end_inset 


\layout Description

BoxFloat 
\begin_inset Formula 
\[
\axiom{\kindsynth{\Delta }{BoxFloat}{\st{BoxFloat}}}\]

\end_inset 


\layout Description

Int 
\begin_inset Formula 
\[
\axiom{\kindsynth{\context }{Int}{\st{Int}}}\]

\end_inset 


\layout Description


\begin_inset Formula \( \mu  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\Delta [a::T,b::T]}{c_{1}}{T} & \kcheck{\Delta [a::T,b::T]}{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{\mu (a=c_{1},b=c_{2})}{\st{\mu (a=c_{1},b=c_{2}).1}\times \st{\mu (a=c_{1},b=c_{2}).2}}}\quad a,b\notin dom(\Delta )\]

\end_inset 

 
\layout Description

Pair 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\times c_{2}}{\st{c_{1}\times c_{2}}}}\]

\end_inset 


\layout Description

Arrow 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\rightarrow c_{2}}{\st{c_{1}\rightarrow c_{2}}}}\]

\end_inset 


\layout Description

Sum 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}+c_{2}}{\st{c_{1}+c_{2}}}}\]

\end_inset 


\layout Description

Array 
\begin_inset Formula 
\[
\infrule{\kcheck{\context }{c}{T}}{\kindsynth{\context }{\carray{c}}{\st{\carray{c}}}}\]

\end_inset 


\layout Description

Lambda 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa } & \kindsynth{\Delta [\alpha ::\kappa ]}{c}{\kappa '}
\end{array}}{\kindsynth{\Delta }{\Lam{\alpha }{\kappa }{c}}{\Pi (\alpha ::\kappa ).\kappa '}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout Description

App 
\begin_inset Formula 
\[
\infrule{\begin{array}{cc}
\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & \kcheck{\context }{c_{2}}{\kappa _{1}}
\end{array}
\end{array}}{\kindsynth{\Delta }{c_{1}\, c_{2}}{\subst{c_{2}}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout Description

Record 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta }{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{<c_{1},c_{2}>}{\kappa _{1}\times \kappa _{2}}}\]

\end_inset 


\layout Description

Proj1 
\begin_inset Formula 
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.1}{\kappa _{1}}}\]

\end_inset 


\layout Description

Proj2 
\begin_inset Formula 
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout Description

Let 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta [\alpha ::\kappa _{1}]}{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{\Let{\alpha }{c_{1}}{c_{2}}}{\subst{c_{1}}{\alpha }{\kappa _{2}}}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout Subsection

Well-formed Type 
\begin_inset Formula \( \typev{\tau } \)
\end_inset 


\layout Standard

Assume 
\begin_inset Formula \( \context  \)
\end_inset 

 is well-formed.
 Check that 
\begin_inset Formula \( \tau  \)
\end_inset 

 is well-formed.
\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

 and 
\begin_inset Formula \( \typev{\tau } \)
\end_inset 

 then 
\begin_inset Formula \( \tok{\tau } \)
\end_inset 

.
\layout Standard

TS: if 
\begin_inset Formula \( \tok{\tau } \)
\end_inset 

 then 
\begin_inset Formula \( \typev{\tau '} \)
\end_inset 

 such that 
\begin_inset Formula \( \eqtype{\context }{\tau }{\tau '} \)
\end_inset 


\layout Description

Constructor 
\begin_inset Formula 
\[
\frac{\kcheck{\context }{c}{T}}{\typev{c}}\]

\end_inset 


\layout Description

ArrowType 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\kindvalid{\context }{\kappa } & \\
\typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}
\end{array}}{\typev{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\quad \alpha \notin dom(\context )\]

\end_inset 


\layout Description

Float 
\begin_inset Formula 
\[
\axiom{\typev{Float}}\]

\end_inset 


\layout Description

PairType 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\typev{\tau _{1}} & \typev{\tau _{2}}
\end{array}}{\typev{\tau _{1}\times \tau _{2}}}\]

\end_inset 


\layout Subsection

Type Analysis 
\begin_inset Formula \( \tcheck{\context }{e}{\tau } \)
\end_inset 


\layout Standard

Assume 
\begin_inset Formula \( \context  \)
\end_inset 

 and 
\begin_inset Formula \( \tau  \)
\end_inset 

 are well-formed.
 Check that 
\begin_inset Formula \( e \)
\end_inset 

 is well-typed, and has type 
\begin_inset Formula \( \tau  \)
\end_inset 

.
\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

, 
\begin_inset Formula \( \tok{\tau } \)
\end_inset 

 and 
\begin_inset Formula \( \tcheck{\context }{e}{\tau } \)
\end_inset 

, then 
\begin_inset Formula \( \eok{e}{\tau } \)
\end_inset 


\layout Standard

TS: if 
\begin_inset Formula \( \eok{e}{\tau } \)
\end_inset 

 then 
\begin_inset Formula \( \tcheck{\context }{e}{\tau } \)
\end_inset 


\layout Standard


\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{\tau '} & \typeeq{\tau '}{\tau }
\end{array}}{\tcheck{\context }{e}{\tau }}\]

\end_inset 


\layout Subsection

Type Synthesis 
\begin_inset Formula \( \types{e}{\tau } \)
\end_inset 


\layout Standard

Assume 
\begin_inset Formula \( \context  \)
\end_inset 

 is well-formed.
 Check that 
\begin_inset Formula \( e \)
\end_inset 

 is well-formed and construct its type 
\begin_inset Formula \( \tau  \)
\end_inset 

, where 
\begin_inset Formula \( \typev{\tau } \)
\end_inset 


\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

 and 
\begin_inset Formula \( \types{e}{\tau } \)
\end_inset 

 then 
\begin_inset Formula \( \tok{\tau } \)
\end_inset 

.
\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

 and 
\begin_inset Formula \( \types{e}{\tau } \)
\end_inset 

 then 
\begin_inset Formula \( \eok{e}{\tau } \)
\end_inset 


\layout Standard

TS if 
\begin_inset Formula \( \eok{e}{\tau } \)
\end_inset 

, then 
\begin_inset Formula \( \types{e}{\tau '} \)
\end_inset 

 such that 
\begin_inset Formula \( \eqtype{\context }{\tau }{\tau '} \)
\end_inset 


\layout Description

variable 
\begin_inset Formula 
\[
\axiom{\typesynth{\caddt{x}{\tau }}{x}{\tau }}\]

\end_inset 


\layout Description

lete 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \typesynth{\caddt{x}{\tau _{1}}}{e_{2}}{\tau _{2}}
\end{array}}{\types{\lete{x}{e_{1}}{e_{2}}}{\tau _{2}}}\quad x\notin dom(\context )\]

\end_inset 


\layout Description

letc 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa } & \typesynth{\caddk{\alpha }{\kappa }}{e}{\tau }
\end{array}}{\types{\lete{\alpha }{c}{e}}{\subst{c}{\alpha }{\tau }}}\quad \alpha \notin dom(\context )\]

\end_inset 


\layout Description

rec 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindvalid{\context }{\kappa } & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}}\\
\typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}} & \typeequiv{\caddk{\alpha }{\kappa }}{\tau _{2}}{\tau _{2}'}\\
\typesynth{\context \extt{f}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}\extk{\alpha }{\kappa }\extt{x}{\tau _{1}}}{e}{\tau _{2}'} & 
\end{array}}{\types{\rec{f}{\alpha }{\kappa }{x}{\tau _{1}}{\tau _{2}}{e}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\]

\end_inset 

  where 
\begin_inset Formula \( f,\alpha ,x\notin dom(\context ) \)
\end_inset 

.
\layout Description

app 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}} & \kcheck{\context }{c}{\kappa } & \kcheck{\context }{e_{2}}{\subst{c}{\alpha }{\tau _{1}}}
\end{array}}{\types{e_{1}[c]e_{2}}{\subst{c}{\alpha }{\tau _{2}}}}\]

\end_inset 


\layout Description

app2 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{c_{e}} & \hnf{\context }{c_{e}}{c_{1}\rightarrow c_{2}} & \tcheck{\context }{e_{2}}{c_{1}}
\end{array}}{\types{e_{1}\, e_{2}}{c_{2}}}\]

\end_inset 


\layout Description

pair 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \types{e_{2}}{\tau _{2}}
\end{array}}{\types{<e_{1},e_{2}>}{\tau _{1}\times \tau _{2}}}\]

\end_inset 


\layout Description

type_proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}}
\end{array}}{\types{e.1}{\tau _{1}}}\]

\end_inset 


\layout Description

con_proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.1}{c_{1}}}\]

\end_inset 


\layout Description

type_proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}}
\end{array}}{\types{e.2}{\tau _{2}}}\]

\end_inset 


\layout Description

con_proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.2}{c_{2}}}\]

\end_inset 


\layout Description

float 
\begin_inset Formula 
\[
\axiom{\types{r}{Float}}\]

\end_inset 


\layout Description

int 
\begin_inset Formula 
\[
\axiom{\types{n}{Int}}\]

\end_inset 


\layout Description

box 
\begin_inset Formula 
\[
\infrule{\types{e}{Float}}{\types{box(e)}{BoxFloat}}\]

\end_inset 


\layout Description

unbox 
\begin_inset Formula 
\[
\infrule{\types{e}{BoxFloat}}{\types{unbox(e)}{Float}}\]

\end_inset 


\layout Description

sumswitch 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \typesynth{\caddt{x_{1}}{c_{1}}}{e_{1}}{\tau _{1}}\\
\kcheck{\context }{c_{2}}{T} & \typesynth{\caddt{x_{2}}{c_{2}}}{e_{2}}{\tau _{2}}\\
\tcheck{\context }{e}{c_{1}+c_{2}} & \typeeq{\tau _{1}}{\tau _{2}}
\end{array}}{\types{\sumsw{e}{x_{1}}{c_{1}}{e_{1}}{x_{2}}{c_{2}}{e_{2}}}{\tau _{1}}}\]

\end_inset 


\layout Description

inl 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c}{T} & \hnf{\context }{c}{c_{1}+c_{2}}\\
\tcheck{\context }{e}{c_{1}} & 
\end{array}}{\types{\inl{c}{e}}{c_{1}+c_{2}}}\]

\end_inset 


\layout Description

inr 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c}{T} & \hnf{\context }{c}{c_{1}+c_{2}}\\
\tcheck{\context }{e}{c_{2}} & 
\end{array}}{\types{\inr{c}{e}}{c_{1}+c_{2}}}\]

\end_inset 


\layout Description

ifBoxFloat 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c}{T} & \types{e_{1}}{\tau _{1}}\\
\types{e_{2}}{\tau _{2}} & \typeeq{\tau _{1}}{\tau _{2}}
\end{array}}{\types{\iffloat{c}{e_{1}}{e_{2}}}{\tau _{1}}}\]

\end_inset 


\layout Description

array 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\tcheck{\context }{e_{1}}{Int} & \kcheck{\context }{c}{T}\\
\tcheck{\context }{e_{2}}{c} & 
\end{array}}{\types{\arr{c}{e_{1}}{e_{2}}}{\carray{c}}}\]

\end_inset 


\layout Description

sub 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{\carray{c}} & \tcheck{\context }{e_{2}}{Int}
\end{array}}{\types{\sub{e_{1}}{e_{2}}}{c}}\]

\end_inset 


\layout Description

fsub 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\tcheck{\context }{e_{1}}{\carray{BoxFloat}} & \tcheck{\context }{e_{2}}{Int}
\end{array}}{\types{\fsub{e_{1}}{e_{2}}}{Float}}\]

\end_inset 


\layout Subsection

Natural Kind Extraction 
\begin_inset Formula \( \pext{p}{\kappa } \)
\end_inset 


\layout Standard

Assumes that 
\begin_inset Formula \( \Delta  \)
\end_inset 

 and 
\begin_inset Formula \( p \)
\end_inset 

 are well-formed.
 Returns the unselfified kind of 
\begin_inset Formula \( p \)
\end_inset 

.
 
\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

, 
\begin_inset Formula \( \cok{p}{\kappa } \)
\end_inset 

and 
\begin_inset Formula \( \pext{p}{\kappa '} \)
\end_inset 

, then 
\begin_inset Formula \( \kok{\kappa } \)
\end_inset 

.
\layout Standard

TS: if 
\begin_inset Formula \( \deltaok{\context } \)
\end_inset 

, 
\begin_inset Formula \( \cok{p}{\kappa } \)
\end_inset 

and 
\begin_inset Formula \( \pext{p}{\kappa '} \)
\end_inset 

, then 
\begin_inset Formula \( \cok{p}{\kappa '} \)
\end_inset 

.
\layout Description

Variable 
\begin_inset Formula 
\[
\axiom{\pathextract{\caddk{\alpha }{\kappa }}{\alpha }{\kappa }}\]

\end_inset 


\layout Description

Proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\pext{p}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p.1}{\kappa _{1}}}\]

\end_inset 


\layout Description

Proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\pext{p}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p.2}{\subst{p.1}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout Description

App 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\pext{p}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p\, c}{\subst{c}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout Subsection

Constructor Weak Head Normal Form 
\begin_inset Formula \( \hnf{\context }{c}{c'} \)
\end_inset 


\layout Standard

Assumes that 
\begin_inset Formula \( \Delta  \)
\end_inset 

 and 
\begin_inset Formula \( c \)
\end_inset 

 are well-formed.
 Returns the head normal form of 
\begin_inset Formula \( c \)
\end_inset 

.
 
\layout Standard

TS: if 
\begin_inset Formula \( \cok{c}{\kappa } \)
\end_inset 

and 
\begin_inset Formula \( \hnf{\context }{c}{c'} \)
\end_inset 

, then 
\begin_inset Formula \( \cok{c'}{\kappa } \)
\end_inset 


\layout Description

Variable 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\pext{\alpha }{\st{c}} & \hnf{\context }{c}{c'}
\end{array}}{\hnf{\context }{\alpha }{c'}}\]

\end_inset 


\layout Description

OpaqueVariable 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\pext{\alpha }{\kappa } & 
\end{array}}{\hnf{\context }{\alpha }{\alpha }}\]

\end_inset 


\newline 
where 
\begin_inset Formula \( \kappa  \)
\end_inset 

 is not a singleton
\layout Description

BoxFloat 
\begin_inset Formula 
\[
\axiom{\hnf{\context }{BoxFloat}{BoxFloat}}\]

\end_inset 


\layout Description

Int 
\begin_inset Formula 
\[
\axiom{\hnf{\context }{Int}{Int}}\]

\end_inset 


\layout Description


\begin_inset Formula \( \mu  \)
\end_inset 

 
\begin_inset Formula 
\[
\axiom{\Hnf{\mu (a=c_{1},b=c_{2})}{\mu (a=c_{1},b=c_{2})}}\]

\end_inset 

 
\layout Description

Pair 
\begin_inset Formula 
\[
\axiom{\Hnf{c_{1}\times c_{2}}{c_{1}\times c_{2}}}\]

\end_inset 


\layout Description

Arrow 
\begin_inset Formula 
\[
\axiom{\Hnf{c_{1}\rightarrow c_{2}}{c_{1}\rightarrow c_{2}}}\]

\end_inset 


\layout Description

Sum 
\begin_inset Formula 
\[
\axiom{\Hnf{c_{1}+c_{2}}{c_{1}+c_{2}}}\]

\end_inset 


\layout Description

Array 
\begin_inset Formula 
\[
\axiom{\hnf{\context }{\carray{c}}{\carray{c}}}\]

\end_inset 


\layout Description

Lambda 
\begin_inset Formula 
\[
\axiom{\Hnf{\Lam{\alpha }{\kappa }{c}}{\Lam{\alpha }{\kappa }{c}}}\]

\end_inset 


\layout Description

App 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{\lambda \alpha ::\kappa .c_{1}} & \hnf{\context }{\subst{c_{2}}{\alpha }{c_{1}}}{c}
\end{array}}{\Hnf{c_{1}\, c_{2}}{c}}\]

\end_inset 

 
\layout Description

PathApp 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c_{1}\, c_{2}}{c''}}\]

\end_inset 


\layout Description

OpaquePathApp 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c}{\kappa }
\end{array}}{\Hnf{c_{1}\, c_{2}}{p\, c}}\]

\end_inset 


\newline 
where 
\begin_inset Formula \( \kappa  \)
\end_inset 

 is not a singleton
\layout Description

Record 
\begin_inset Formula 
\[
\axiom{\Hnf{<c_{1},c_{2}>}{<c_{1},c_{2}>}}\]

\end_inset 


\layout Description

Proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c_{1}}{c_{1}'}
\end{array}}{\Hnf{c.1}{c_{1}'}}\]

\end_inset 


\layout Description

PathProj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c.1}{c''}}\]

\end_inset 


\layout Description

OpaquePathProj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{\kappa }
\end{array}}{\Hnf{c.1}{p.1}}\]

\end_inset 


\newline 
where 
\begin_inset Formula \( \kappa  \)
\end_inset 

 is not a singleton
\layout Description

Proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c_{2}}{c_{2}'}
\end{array}}{\Hnf{c.2}{c_{2}'}}\]

\end_inset 


\layout Description

PathProj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c.2}{c''}}\]

\end_inset 


\layout Description

OpaquePathProj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{\kappa }
\end{array}}{\Hnf{c.2}{p.2}}\]

\end_inset 


\newline 
where 
\begin_inset Formula \( \kappa  \)
\end_inset 

 is not a singleton
\layout Description

Let 
\begin_inset Formula 
\[
\infrule{\Hnf{\subst{c_{1}}{\alpha }{c_{2}}}{c}}{\Hnf{\Let{\alpha }{c_{1}}{c_{2}}}{c}}\]

\end_inset 


\layout Section

Termination Proofs
\layout Standard

For the time being, we assume that constructor equivalence at kind type
 is decidable.
 For this section, I view the judgments given above as algorithms, as they
 were intended to be.
 All of the judgments presented above are algorithmic in the sense that
 either they are entirely syntax directed, or else at worse, require the
 
\begin_inset Quotes eld
\end_inset 

results
\begin_inset Quotes erd
\end_inset 

 of one of their hypotheses to determine a rule which uniquely applies.
\layout Subsection

Termination of sub-kinding.
\layout Standard

Consider the relation 
\begin_inset Formula \( \prec  \)
\end_inset 

 on sub-kinding judgments defined as follows: 
\begin_inset Formula \( (\subkind{\context '}{\kappa _{1}'}{\kappa _{2}'})\prec (\subkind{\context }{\kappa _{1}}{\kappa _{2}}) \)
\end_inset 

 iff showing 
\begin_inset Formula \( \subkind{\context '}{\kappa _{1}'}{\kappa _{2}'} \)
\end_inset 

 is an immediate sub-goal of showing 
\begin_inset Formula \( \subkind{\context }{\kappa _{1}}{\kappa _{2}} \)
\end_inset 

.
 It suffices to show that the 
\begin_inset Formula \( \prec  \)
\end_inset 

 relation is well-founded, since if there are no infinite descending chains
 in the relation, then clearly there are no infinite sequences of rule applicati
ons.
 To show that this is the case, we exhibit a mapping 
\begin_inset Formula \( SZ \)
\end_inset 

 which maps judgments to natural numbers, and show that this map is order
 preserving.
 
\layout Definition


\begin_inset Formula \( SZ(\subkind{\context }{\kappa _{1}}{\kappa _{2}})=sz(\kappa _{1})+sz(\kappa _{2}) \)
\end_inset 

, where
\layout Definition


\begin_inset Formula 
\[
sz(\kappa )=\left\{ \begin{array}{ll}
1 & \mathrm{if}\, \kappa =T\\
1 & \mathrm{if}\, \kappa =\st{c}\\
sz(\kappa _{1})+sz(\kappa _{2}) & \mathrm{if}\, \kappa =\Sigma (\alpha ::\kappa _{1}).\kappa _{2}\\
sz(\kappa _{1})+sz(\kappa _{2}) & \mathrm{if}\, \kappa =\Pi (\alpha ::\kappa _{1}).\kappa _{2}
\end{array}\right. \]

\end_inset 


\layout Lemma


\begin_inset Formula \( SZ \)
\end_inset 

 is a function.
\layout Proof

Clearly it suffices to show that 
\begin_inset Formula \( sz \)
\end_inset 

 is a function - that is, 
\begin_inset Formula \( \forall \kappa ,\exists !n\, s.t.\, sz(\kappa )=n \)
\end_inset 

.
 This follows by induction over the structure of 
\begin_inset Formula \( \kappa  \)
\end_inset 

.
\layout Lemma


\begin_inset Formula \( SZ \)
\end_inset 

 is order preserving.
 That is, 
\begin_inset Formula 
\[
(\subkind{\context '}{\kappa _{1}'}{\kappa _{2}'})\prec (\subkind{\context }{\kappa _{1}}{\kappa _{2})}\Rightarrow SZ(\subkind{\context '}{\kappa _{1}'}{\kappa _{2}'})<SZ(\subkind{\context }{\kappa _{1}}{\kappa _{2}})\]

\end_inset 


\layout Proof

We proceed by cases on the subkinding judgements that define
\begin_inset Formula \( \prec  \)
\end_inset 

.
\begin_deeper 
\layout Enumerate


\begin_inset Formula \( \subkind{\context }{T}{T} \)
\end_inset 

.
 Vacuously true - the rule has no premises, and hence has nothing smaller
 than it.
 
\layout Enumerate


\begin_inset Formula \( \subkind{\context }{\st{c}}{T} \)
\end_inset 

.
 Vacuously true - the rule has no premises, and hence has nothing smaller
 than it.
 
\layout Enumerate


\begin_inset Formula \( \subkind{\context }{\st{c}}{\st{d}} \)
\end_inset 

.
 This rule has no sub-kinding premises, and hence has nothing smaller than
 it.
 The only subgoal is an equivalence judgment, which we assume terminates.
 
\layout Enumerate


\begin_inset Formula \( \subkind{\Delta }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'} \)
\end_inset 

.
 The subkinding rule for the 
\begin_inset Formula \( \Pi  \)
\end_inset 

 judgment defines two judgments as smaller:
\begin_deeper 
\layout Enumerate

By definition, 
\begin_inset Formula \( (\subkind{\context }{\kappa _{1}'}{\kappa _{1}})\prec (\subkind{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}) \)
\end_inset 

.
 But note that 
\begin_inset Formula 
\begin{eqnarray*}
SZ(\subkind{\context }{\kappa _{1}'}{\kappa _{1}}) & = & sz(\kappa _{1}')+sz(\kappa _{1})\\
 & < & sz(\kappa _{1}')+sz(\kappa _{1})+sz(\kappa _{2}')+sz(\kappa _{2})\\
 & = & SZ(\subkind{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'})
\end{eqnarray*}

\end_inset 


\layout Enumerate

By definition, 
\begin_inset Formula \( (\subkind{\caddk{\alpha }{\kappa _{1}'}}{\kappa _{2}}{\kappa _{2}'})\prec (\subkind{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}) \)
\end_inset 

.
 But note that 
\begin_inset Formula 
\begin{eqnarray*}
SZ(\subkind{\caddk{\alpha }{\kappa _{1}'}}{\kappa _{2}}{\kappa _{2}}') & = & sz(\kappa _{2}')+sz(\kappa _{2})\\
 & < & sz(\kappa _{1}')+sz(\kappa _{1})+sz(\kappa _{2}')+sz(\kappa _{2})\\
 & = & SZ(\subkind{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'})
\end{eqnarray*}

\end_inset 


\end_deeper 
\layout Enumerate


\begin_inset Formula \( \subkind{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \)
\end_inset 

.
 The subkinding rule for the 
\begin_inset Formula \( \Sigma  \)
\end_inset 

 judgment defines two judgements as smaller:
\begin_deeper 
\layout Enumerate

By definition, 
\begin_inset Formula \( \subkind{\context }{\kappa _{1}}{\kappa _{1}'}\prec \subkind{\context }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \)
\end_inset 

.
 But note that 
\begin_inset Formula 
\begin{eqnarray*}
SZ(\subkind{\context }{\kappa _{1}}{\kappa _{1}'}) & = & sz(\kappa _{1}')+sz(\kappa _{1})\\
 & < & sz(\kappa _{1}')+sz(\kappa _{1})+sz(\kappa _{2}')+sz(\kappa _{2})\\
 & = & SZ(\subkind{\context }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'})
\end{eqnarray*}

\end_inset 


\layout Enumerate

By definition, 
\begin_inset Formula \( \subkind{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}}{\kappa _{2}'}\prec \subkind{\context }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \)
\end_inset 

.
 But note that 
\begin_inset Formula 
\begin{eqnarray*}
SZ(\subkind{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}}{\kappa _{2}}') & = & sz(\kappa _{2}')+sz(\kappa _{2})\\
 & < & sz(\kappa _{1}')+sz(\kappa _{1})+sz(\kappa _{2}')+sz(\kappa _{2})\\
 & = & SZ(\subkind{\context }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'})
\end{eqnarray*}

\end_inset 


\end_deeper 
\end_deeper 
\layout Theorem


\begin_inset LatexCommand \label{thm:subkindTerm}

\end_inset 

The algorithm for checking subkinding always terminates.
 That is, the algorithmic rules for subkinding do not permit any infinite
 sequences of rule applications.
 
\layout Proof

By the previous lemmas, every rule uses only premises that are strictly
 smaller than the conclusion according to a well-founded ordering.
 Therefore, there can be no infinite sequence of rule applications, since
 such a sequence would correspond to an infinite descending chain in the
 well-founded ordering.
\layout Subsection

Termination of the well-formed kind, kind analysis, and kind synthesis algorithm
s
\layout Standard


\begin_inset FormulaMacro 
\newcommand{\ksz}[1]{sz_{\kappa }(#1 )}

\end_inset 

 
\begin_inset FormulaMacro 
\newcommand{\csz}[1]{sz_{c}(#1 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\Smeas}[1]{SZ_{\Uparrow }(#1 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\Ameas}[1]{SZ_{\Downarrow }(#1 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\Kmeas}[1]{SZ_{\kappa }(#1 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\smeas}[3]{\Smeas{\kindsynth{#1 }{#2 }{#3 }}}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\ameas}[3]{\Ameas{\kcheck{#1 }{#2 }{#3 }}}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\kmeas}[2]{\Kmeas{\kindvalid{#1 }{#2 }}}

\end_inset 


\layout Standard

We proceed by defining measure functions which map judgments to the natural
 numbers, and show that for every rule, the measure of each premise is smaller
 than the measure of the conclusion.
 Therefore, any infinite sequence of rules corresponds to an infinite descending
 chain of natural numbers, which contradicts the well-foundedness of (N,<).
\layout Standard

We give mutually inductive definitions for two functions 
\begin_inset Formula \( \ksz{} \)
\end_inset 

 and 
\begin_inset Formula \( \csz{} \)
\end_inset 

, which act as measures on kinds and constructors, respectively, and use
 these to define measures on judgements.
\layout Definition


\begin_inset Formula 
\[
\ksz{\kappa }=\left\{ \begin{array}{ll}
1 & \mathrm{if}\, \kappa =T\\
\csz{c}+1 & \mathrm{if}\, \kappa =\st{c}\\
\ksz{\kappa _{1}}+\ksz{\kappa _{2}} & \mathrm{if}\, \kappa =\Sigma (\alpha ::\kappa _{1}).\kappa _{2}\\
\ksz{\kappa _{1}}+\ksz{\kappa _{2}} & \mathrm{if}\, \kappa =\Pi (\alpha ::\kappa _{1}).\kappa _{2}
\end{array}\right. \]

\end_inset 


\layout Definition


\begin_inset Formula 
\[
\csz{c}=\left\{ \begin{array}{ll}
1 & \mathrm{if}\, c=\alpha ,Int,BoxFloat\\
\csz{c_{1}}+\csz{c_{2}} & \mathrm{if}\, c=\mu (a=c_{1},b=c_{2})\\
\csz{c_{1}}+\csz{c_{2}} & \mathrm{if}\, c=c_{1}\times c_{2},c_{1}\rightarrow c_{2},c_{1}+c_{2}\\
\csz{c'}+1 & \mathrm{if}\, \carray{c=c'}\\
\csz{c'}+\ksz{\kappa } & \mathrm{if}\, c=\Lam{\alpha }{\kappa }{c'}\\
\csz{c_{1}}+\csz{c_{2}} & \mathrm{if}\, c=c_{1}\, c_{2}\\
\csz{c_{1}}+\csz{c_{2}} & \mathrm{if}\, c=<c_{1},c_{2}>\\
\csz{c'}+1 & \mathrm{if}\, c=c'.1,c'.2\\
\csz{c_{1}}+\csz{c_{2}} & \mathrm{if}\, c=\Let{\alpha }{c_{1}}{c_{2}}
\end{array}\right. \]

\end_inset 


\layout LaTeX

%
\layout Definition


\begin_inset Formula \( \kmeas{\context }{\kappa }=\ksz{\kappa } \)
\end_inset 


\layout LaTeX

%
\layout Definition


\begin_inset Formula \( \ameas{\context }{c}{\kappa }=\csz{c} \)
\end_inset 


\layout LaTeX

%
\layout Definition


\begin_inset Formula \( \smeas{\context }{c}{\kappa }=\csz{c} \)
\end_inset 


\layout Lemma


\begin_inset Formula \( \Kmeas{} \)
\end_inset 

, 
\begin_inset Formula \( \Smeas{} \)
\end_inset 

, and 
\begin_inset Formula \( \Ameas{} \)
\end_inset 

 are well-defined functions.
\layout Proof

It clearly suffices to show that 
\begin_inset Formula \( \csz{} \)
\end_inset 

, and 
\begin_inset Formula \( \ksz{} \)
\end_inset 

 are well-defined.
 This follows by induction over the structure of 
\begin_inset Formula \( \kappa  \)
\end_inset 

 and 
\begin_inset Formula \( c \)
\end_inset 

.
\layout Lemma

Termination of selficiation.
\layout Proof

To be shown
\layout Lemma

The measures decrease
\layout Proof

The proof proceeds by cases over the rules, demonstrating that for each
 premise, either the premise is a judgment that is known not to admit an
 infinite sequence of rule applications (i.e.
 subkinding, selfification), or has a measure which is strictly smaller
 than the measure of the conclusion of the rule.
 For kind analysis, we observe that the measure does not increase in the
 premises, and that the rules do not permit consecutive applications of
 the kind analysis rule.
 
\begin_deeper 
\layout Itemize

Well Formed Kind 
\begin_inset Formula \( \kindvalid{\context }{\kappa } \)
\end_inset 


\begin_deeper 
\layout Description

Type No premises.
\layout Description

Singleton No premises
\layout Description

Pi 
\begin_deeper 
\layout Enumerate


\begin_inset Formula 
\begin{eqnarray*}
\kmeas{\context }{\kappa _{1}} & = & \ksz{\kappa _{1}}\\
 & < & \ksz{\kappa _{1}}+\ksz{\kappa _{2}}\\
 & = & \kmeas{\context }{\Pi (\alpha ::\kappa _{1}).k_{2}}
\end{eqnarray*}

\end_inset 


\layout Enumerate


\begin_inset Formula 
\begin{eqnarray*}
\kmeas{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}} & = & \ksz{\kappa _{2}}\\
 & < & \ksz{\kappa _{1}}+\ksz{\kappa _{2}}\\
 & = & \kmeas{\context }{\Pi (\alpha ::\kappa _{1}).k_{2}}
\end{eqnarray*}

\end_inset 


\end_deeper 
\layout Description

Sigma 
\begin_deeper 
\layout Enumerate


\begin_inset Formula 
\begin{eqnarray*}
\kmeas{\context }{\kappa _{1}} & = & \ksz{\kappa _{1}}\\
 & < & \ksz{\kappa _{1}}+\ksz{\kappa _{2}}\\
 & = & \kmeas{\context }{\Sigma (\alpha ::\kappa _{1}).k_{2}}
\end{eqnarray*}

\end_inset 


\layout Enumerate


\begin_inset Formula 
\begin{eqnarray*}
\kmeas{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}} & = & \ksz{\kappa _{2}}\\
 & < & \ksz{\kappa _{1}}+\ksz{\kappa _{2}}\\
 & = & \kmeas{\context }{\Sigma (\alpha ::\kappa _{1}).k_{2}}
\end{eqnarray*}

\end_inset 


\end_deeper 
\end_deeper 
\layout Itemize

Kind Analysis 
\begin_inset Formula \( \kcheck{\context }{c}{\kappa } \)
\end_inset 

.
 We observe that while the measure does not decrease in the first premise,
 it also does not increase.
 It is sufficient therefore to note that there is no way to apply the kind
 analysis rule twice in succession.
 Every use of the rule must be followed by a use of a kind synthesis rule,
 all of which are strictly decreasing.
\begin_deeper 
\layout Enumerate


\begin_inset Formula 
\begin{eqnarray*}
\smeas{\context }{c}{\kappa '} & = & \csz{c}\\
 & = & \ameas{\context }{c}{\kappa }
\end{eqnarray*}

\end_inset 


\layout Enumerate

By theorem 
\begin_inset LatexCommand \ref{thm:subkindTerm}

\end_inset 


\end_deeper 
\layout Itemize

Kind Synthesis 
\begin_inset Formula \( \kindsynth{\Delta }{c}{\kappa } \)
\end_inset 


\begin_deeper 
\layout Description

Variable 
\begin_inset Formula 
\[
\infrule{\selfify{\alpha }{\kappa }{\kappa '}}{\kindsynth{\Delta [\alpha ::\kappa ]}{\alpha }{\kappa }'}\]

\end_inset 


\layout Description

BoxFloat 
\begin_inset Formula 
\[
\axiom{\kindsynth{\Delta }{BoxFloat}{\st{BoxFloat}}}\]

\end_inset 


\layout Description

Int 
\begin_inset Formula 
\[
\axiom{\kindsynth{\context }{Int}{\st{Int}}}\]

\end_inset 


\layout Description


\begin_inset Formula \( \mu  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\Delta [a::T,b::T]}{c_{1}}{T} & \kcheck{\Delta [a::T,b::T]}{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{\mu (a=c_{1},b=c_{2})}{\st{\mu (a=c_{1},b=c_{2}).1}\times \st{\mu (a=c_{1},b=c_{2}).2}}}\quad a,b\notin dom(\Delta )\]

\end_inset 

 
\layout Description

Pair 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\times c_{2}}{\st{c_{1}\times c_{2}}}}\]

\end_inset 


\layout Description

Arrow 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\rightarrow c_{2}}{\st{c_{1}\rightarrow c_{2}}}}\]

\end_inset 


\layout Description

Sum 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}+c_{2}}{\st{c_{1}+c_{2}}}}\]

\end_inset 


\layout Description

Array 
\begin_inset Formula 
\[
\infrule{\kcheck{\context }{c}{T}}{\kindsynth{\context }{\carray{c}}{\st{\carray{c}}}}\]

\end_inset 


\layout Description

Lambda 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa } & \kindsynth{\Delta [\alpha ::\kappa ]}{c}{\kappa '}
\end{array}}{\kindsynth{\Delta }{\Lam{\alpha }{\kappa }{c}}{\Pi (\alpha ::\kappa ).\kappa '}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout Description

App 
\begin_inset Formula 
\[
\infrule{\begin{array}{cc}
\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & \kcheck{\context }{c_{2}}{\kappa _{1}}
\end{array}
\end{array}}{\kindsynth{\Delta }{c_{1}\, c_{2}}{\subst{c_{2}}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout Description

Record 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta }{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{<c_{1},c_{2}>}{\kappa _{1}\times \kappa _{2}}}\]

\end_inset 


\layout Description

Proj1 
\begin_inset Formula 
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.1}{\kappa _{1}}}\]

\end_inset 


\layout Description

Proj2 
\begin_inset Formula 
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout Description

Let 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta [\alpha ::\kappa _{1}]}{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{\Let{\alpha }{c_{1}}{c_{2}}}{\subst{c_{1}}{\alpha }{\kappa _{2}}}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\end_deeper 
\end_deeper 
\layout Theorem

The rules for kind synthesis, kind analysis, and kind well-formedness do
 not permit an infinite sequence of rule applications.
\layout Proof

The proof proceeds by cases over the rules, demonstrating that for each
 premise, either the premise is a judgment that is known not to admit an
 infinite sequence of rule applications (i.e.
 subkinding, selfification), or has a measure which is strictly smaller
 than the measure of the conclusion of the rule.
 Therefore any infinite sequence of rule applications would correspond to
 an infinite descending chain of natural numbers, and hence there are no
 such sequences.
\layout Section

Other Proofs
\layout Lemma


\series bold 
Admissibility of weakening.

\series default 
 The weakening rule for constructors is admissible.
\layout Proof

By induction over the structure of kind synthesis derivations.
\layout Lemma

Selfification.
 If 
\begin_inset Formula \( \cok{\context }{} \)
\end_inset 

nd_inset .
\layout Proof

By induction over the structure of well-formed kind derivations.
\begin_deeper 
\layout Description

Type 
\begin_inset Formula \( \kindvalid{\context }{T} \)
\end_inset 

.
 By assumption, 
\begin_inset Formula \( \kcheck{\context }{c}{T} \)
\end_inset 

, so by the definition of well-kindedness, 
\begin_inset Formula \( \kindvalid{\context }{\st{c}} \)
\end_inset 

.
\layout Description

Singleton 
\begin_inset Formula \( \kindvalid{\context }{\st{d}} \)
\end_inset 

.
 This is what we need.
\layout Description


\begin_inset Formula \( \Pi  \)
\end_inset 

 
\begin_inset Formula \( \kindvalid{\context }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} \)
\end_inset 

.
 By the definition of well-formed kinds, 
\begin_inset Formula \( \kindvalid{\context }{\kappa _{1}} \)
\end_inset 

 and 
\begin_inset Formula \( \kindvalid{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}} \)
\end_inset 

.
 We need to show that 
\begin_inset Formula \( \kindvalid{\caddk{\alpha }{\kappa _{1}}}{\kappa _{2}'} \)
\end_inset 

.
 By induction, it is sufficient to show that 
\begin_inset Formula \( \kcheck{\caddk{\alpha }{\kappa _{1}}}{c\, \alpha }{\kappa _{2}} \)
\end_inset 

.
 We construct such a derivation using the assumptions, along with the admissible
 weakening rule.
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\caddk{\alpha }{\kappa _{1}}}{c}{\Pi (\alpha '::\kappa } & \kindsynth{\caddk{\alpha }{\kappa _{1}}}{\alpha }{\kappa _{1}}
\end{array}}{\kcheck{\caddk{\alpha }{\kappa _{1}}}{c\, \alpha }{\kappa _{2}}}\]

\end_inset 


\newline 

\begin_inset Formula \( \selfify{c}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}'} \)
\end_inset 

 
\newline 
where 
\begin_inset Formula \( \selfify{c\, \alpha }{\kappa _{2}}{\kappa _{2}'} \)
\end_inset 


\layout Description


\begin_inset Formula \( \Sigma  \)
\end_inset 

 
\begin_inset Formula \( \selfify{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \)
\end_inset 

 
\newline 
where 
\begin_inset Formula \( \selfify{c.1}{\kappa _{1}}{\kappa _{1}'} \)
\end_inset 

 and 
\begin_inset Formula \( \selfify{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}{\kappa _{2}'} \)
\end_inset 


\end_deeper 
\layout Lemma

Selfification.
 If 
\begin_inset Formula \( \kcheck{\context }{c}{\kappa } \)
\end_inset 

, and 
\begin_inset Formula \( \selfify{c}{\kappa }{\kappa '} \)
\end_inset 

, then for all 
\begin_inset Formula \( \kappa '' \)
\end_inset 

 s.t.
 
\begin_inset Formula \( \kcheck{\context }{c}{\kappa ''} \)
\end_inset 

, 
\begin_inset Formula \( \subkind{\context }{\kappa '}{\kappa ''} \)
\end_inset 

.
\layout Proof

By induction over the structure of typing derivations.
\begin_deeper 
\layout Description

Type 
\begin_inset Formula \( \selfify{c}{T}{\st{c}} \)
\end_inset 


\layout Description

Singleton 
\begin_inset Formula \( \selfify{c}{\st{d}}{\st{d}} \)
\end_inset 


\layout Description


\begin_inset Formula \( \Pi  \)
\end_inset 

 
\begin_inset Formula \( \selfify{c}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}'} \)
\end_inset 

 
\newline 
where 
\begin_inset Formula \( \selfify{c\, \alpha }{\kappa _{2}}{\kappa _{2}'} \)
\end_inset 


\layout Description


\begin_inset Formula \( \Sigma  \)
\end_inset 

 
\begin_inset Formula \( \selfify{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'} \)
\end_inset 

 
\newline 
where 
\begin_inset Formula \( \selfify{c.1}{\kappa _{1}}{\kappa _{1}'} \)
\end_inset 

 and 
\begin_inset Formula \( \selfify{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}{\kappa _{2}'} \)
\end_inset 


\the_end
