#This file was created by <leaf> Mon Oct  5 17:43:29 1998
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass article
\language default
\inputencoding default
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard


\begin_inset FormulaMacro 
\newcommand{\Lam}[3]{\lambda #1 ::#2 .#3 }

\end_inset 

 
\begin_inset FormulaMacro 
\newcommand{\Let}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}

\end_inset 

 
\begin_inset FormulaMacro 
\newcommand{\lete}[3]{\mathrm{let}\, #1 =#2 \, \mathrm{in}\, #3 \, \mathrm{end}}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\rec}[7]{\mathrm{rec}\, #1 =\lambda (#2 ::#3 ,#4 :#5 ):#6 .#7 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\ifz}[3]{\mathrm{ifzero}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\st}[1]{S_{T}(#1 )}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\subst}[3]{\{#1 /#2 \}#3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\context}{\Delta }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\addk}[3]{#1 [#2 ::#3 ]}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\addt}[3]{#1 [#2 :#3 ]}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\caddk}[2]{\addk{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\caddt}[2]{\addt{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\extk}[2]{[#1 ::#2 ]}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\extt}[2]{[#1 :#2 ]}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\iffloat}[3]{\mathrm{ifFloat}\, #1 \, \mathrm{then}\, #2 \, \mathrm{else}\, #3 }

\end_inset 

 
\layout Title

Core Nil
\layout Author

Leaf Petersen
\layout Section

Syntax
\layout Standard


\begin_inset Formula 
\begin{eqnarray*}
\kappa  & ::= & T\: |\: \st{c}\: |\: \Sigma (\alpha ::\kappa ).\kappa \: |\: \Pi (\alpha ::\kappa ).\kappa \\
 &  & \\
c & ::= & \alpha \mid Int\mid BoxFloat\mid \mu (a=c,b=c)\mid c\times c\mid c\rightarrow c\mid \Lam{\alpha }{\kappa }{c}\\
 &  & \mid c\, c\mid <c,c>\mid c.1\mid c.2\mid \Let{\alpha }{c}{c}\\
 &  & \\
\tau  & ::= & c\mid (\alpha ::\kappa ,\tau )\rightarrow \tau \mid Float\mid \tau \times \tau \\
 &  & \\
p & ::= & \alpha \mid p.1\mid p.2\mid p\, c\\
 &  & \\
e & ::= & x\mid \lete{x}{e}{e}\mid \lete{\alpha }{c}{e}\mid \rec{f}{\alpha }{\kappa }{x}{\tau }{\tau }{e}\\
 &  & \mid e[c]e\mid <e,e>\mid e.1\mid e.2\mid n\mid r\mid box(e)\mid unbox(e)\\
 &  & \mid \ifz{e}{e}{e}\mid \iffloat{\tau }{e}{e}\\
 &  & \\
\Delta  & ::= & \bullet \mid \caddt{x}{\tau }\mid \caddk{\alpha }{\kappa }
\end{eqnarray*}

\end_inset 


\layout Section

Judgements for the algorithmic core nil
\layout Standard


\begin_inset FormulaMacro 
\newcommand{\infrule}[2]{\frac{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\axiom}[1]{\overline{#1 }}

\end_inset 


\layout Standard


\begin_inset FormulaMacro 
\newcommand{\kindvalid}[2]{#1 \vdash #2 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\kindsynth}[3]{#1 \vdash #2 \Uparrow #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\subkind}[3]{#1 \vdash #2 \preceq #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\conequiv}[4]{#1 \vdash #2 \equiv #3 ::#4 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\coneq}[3]{\conequiv{\context }{#1 }{#2 }{#3 }}

\end_inset 

 
\begin_inset FormulaMacro 
\newcommand{\typevalid}[2]{#1 \vdash #2 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\typev}[1]{\typevalid{\Delta }{#1 }}

\end_inset 


\layout Standard


\begin_inset FormulaMacro 
\newcommand{\typesynth}[3]{#1 \vdash #2 \Uparrow #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\types}[2]{\typesynth{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\typeequiv}[3]{#1 \vdash #2 \equiv #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\typeeq}[2]{\typeequiv{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\hnf}[3]{#1 \vdash #2 \Longrightarrow #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\Hnf}[2]{\hnf{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\pathextract}[3]{#1 \vdash #2 \sim #3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\pext}[2]{\pathextract{\context }{#1 }{#2 }}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\cok}[1]{#1 \, \mathrm{ok}}

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\selfify}[3]{#1 ::#2 =#3 }

\end_inset 


\begin_inset FormulaMacro 
\newcommand{\kcheck}[3]{#1 \vdash #2 \Downarrow #3 }

\end_inset 


\layout Subsection

Well Formed Context 
\layout List
\labelwidthstring 00.00.0000

Empty 
\begin_inset Formula 
\[
\axiom{\cok{\bullet }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Kind 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{\context } & \kindvalid{\context }{\kappa }
\end{array}}{\cok{\caddk{\alpha }{\kappa }}}\alpha \notin dom(\context )\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Type 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\cok{\context } & \typevalid{\context }{\tau }
\end{array}}{\cok{\caddt{x}{\tau }}}x\notin dom(\context )\]

\end_inset 


\layout Subsection

Well Formed Kind 
\layout Standard

Assume 
\begin_inset Formula \( \Delta  \)
\end_inset 

 is well-formed.
 Check that 
\begin_inset Formula \( \kappa  \)
\end_inset 

 is well-formed
\layout List
\labelwidthstring 00.00.0000

Type 
\begin_inset Formula 
\[
\axiom{\kindvalid{\Delta }{T}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Singleton 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c}{\kappa } & \subkind{\context }{\kappa }{T}
\end{array}}{\kindvalid{\Delta }{\st{c}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Pi 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa _{1}} & \kindvalid{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}
\end{array}}{\kindvalid{\Delta }{\Pi (\alpha ::\kappa _{1}).k_{2}}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Sigma 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa _{1}} & \kindvalid{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}
\end{array}}{\kindvalid{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout Subsection

Sub-Kinding 
\begin_inset Formula \( \subkind{\Delta }{\kappa _{1}}{\kappa _{2}} \)
\end_inset 


\layout Standard

Assume that 
\begin_inset Formula \( \Delta  \)
\end_inset 

, 
\begin_inset Formula \( \kappa _{1} \)
\end_inset 

 and 
\begin_inset Formula \( \kappa _{2} \)
\end_inset 

 are well-formed.
 Check that 
\begin_inset Formula \( \kappa _{1} \)
\end_inset 

 is a subkind of 
\begin_inset Formula \( \kappa _{2} \)
\end_inset 

.
\layout List
\labelwidthstring 00.00.0000

Type 
\begin_inset Formula 
\[
\axiom{\subkind{\Delta }{T}{T}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Singleton 
\begin_inset Formula 
\[
\axiom{\subkind{\Delta }{\st{c}}{T}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Singletons 
\begin_inset Formula 
\[
\infrule{\conequiv{\Delta }{c}{d}{T}}{\subkind{\Delta }{\st{c}}{\st{d}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000


\begin_inset Formula \( \Pi  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}'}{\kappa _{1}} & \subkind{\Delta [\alpha ::\kappa _{1}]}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000


\begin_inset Formula \( \Sigma  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\subkind{\Delta }{\kappa _{1}}{\kappa _{1}'} & \subkind{\Delta [\alpha ::\kappa _{1}']}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\subkind{\Delta }{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'}}\quad \alpha \notin dom(\Delta )\]

\end_inset 


\layout Subsection

Selfification 
\begin_inset Formula \( \selfify{c}{\kappa }{\kappa '} \)
\end_inset 


\layout List
\labelwidthstring 00.00.0000

Type 
\begin_inset Formula 
\[
\axiom{\selfify{c}{T}{\st{c}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Singleton 
\begin_inset Formula 
\[
\axiom{c::\st{d}=\st{d}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000


\begin_inset Formula \( \Pi  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\selfify{c\, \alpha }{\kappa _{2}}{\kappa _{2}'}}{\selfify{c}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}'}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000


\begin_inset Formula \( \Sigma  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\selfify{c.1}{\kappa _{1}}{\kappa _{1}'} & \selfify{c.2}{\kappa _{2}}{\kappa _{2}'}
\end{array}}{\selfify{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}{\Sigma (\alpha ::\kappa _{1}').\kappa _{2}'}}\]

\end_inset 


\layout Subsection

Kind Analysis 
\begin_inset Formula \( \kcheck{\context }{c}{\kappa } \)
\end_inset 


\layout Standard

Assume 
\begin_inset Formula \( \context  \)
\end_inset 

 and 
\begin_inset Formula \( \kappa  \)
\end_inset 

 are well formed.
 Check that 
\begin_inset Formula \( c \)
\end_inset 

 is well formed and can be given kind 
\begin_inset Formula \( \kappa  \)
\end_inset 

.
\layout Standard


\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa '} & \subkind{\context }{\kappa '}{\kappa }
\end{array}}{\kcheck{\context }{c}{\kappa }}\]

\end_inset 


\layout Subsection

Kind Synthesis 
\begin_inset Formula \( \kindsynth{\Delta }{c}{\kappa } \)
\end_inset 


\layout Standard

Assumes that 
\begin_inset Formula \( \Delta  \)
\end_inset 

 is well-formed.
 Check that c is well-kinded, and construct 
\begin_inset Formula \( \kappa  \)
\end_inset 

 s.t.
 
\begin_inset Formula \( \kindvalid{\Delta }{\kappa } \)
\end_inset 

 and c has kind 
\begin_inset Formula \( \kappa  \)
\end_inset 


\layout List
\labelwidthstring 00.00.0000

Variable 
\begin_inset Formula 
\[
\infrule{\selfify{\alpha }{\kappa }{\kappa '}}{\kindsynth{\Delta [\alpha ::\kappa ]}{\alpha }{\kappa }'}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Weakening1 
\begin_inset Formula 
\[
\infrule{\kindsynth{\context }{\alpha }{\kappa }}{\kindsynth{\caddk{\alpha '}{\kappa '}}{\alpha }{\kappa }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Weakening2 
\begin_inset Formula 
\[
\infrule{\kindsynth{\context }{\alpha }{\kappa }}{\kindsynth{\caddt{x}{\tau }}{\alpha }{\kappa }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Int 
\begin_inset Formula 
\[
\axiom{\kindsynth{\Delta }{Int}{\st{Int}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

BoxFloat 
\begin_inset Formula 
\[
\axiom{\kindsynth{\Delta }{BoxFloat}{\st{BoxFloat}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000


\begin_inset Formula \( \mu  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\Delta [a::T,b::T]}{c_{1}}{T} & \kcheck{\Delta [a::T,b::T]}{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{\mu (a=c_{1},b=c_{2})}{\st{\mu (a=c_{1},b=c_{2}).1}\times \st{\mu (a=c_{1},b=c_{2}).2}}}a,b\notin dom(\Delta )\]

\end_inset 

 
\layout List
\labelwidthstring 00.00.0000

Pair 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\times c_{2}}{\st{c_{1}\times c_{2}}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Arrow 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kcheck{\context }{c_{1}}{T} & \kcheck{\context }{c_{2}}{T}
\end{array}}{\kindsynth{\Delta }{c_{1}\rightarrow c_{2}}{\st{c_{1}\rightarrow c_{2}}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Lambda 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindvalid{\Delta }{\kappa } & \kindsynth{\Delta [\alpha ::\kappa ]}{c}{\kappa '}
\end{array}}{\kindsynth{\Delta }{\Lam{\alpha }{\kappa }{c}}{\Pi (\alpha ::\kappa ).\kappa '}}\alpha \notin dom(\Delta )\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

App 
\begin_inset Formula 
\[
\infrule{\begin{array}{cc}
\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & \kcheck{\context }{c_{2}}{\kappa _{1}}
\end{array}
\end{array}}{\kindsynth{\Delta }{c_{1}\, c_{2}}{\subst{c_{2}}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Record 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta }{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{<c_{1},c_{2}>}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}\alpha \notin fv(\kappa _{2})\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj1 
\begin_inset Formula 
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.1}{\kappa _{1}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj2 
\begin_inset Formula 
\[
\infrule{\kindsynth{\Delta }{c}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}}}{\kindsynth{\Delta }{c.2}{\subst{c.1}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Let 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\kindsynth{\Delta }{c_{1}}{\kappa _{1}} & \kindsynth{\Delta [\alpha ::\kappa _{1}]}{c_{2}}{\kappa _{2}}
\end{array}}{\kindsynth{\Delta }{\Let{\alpha }{c_{1}}{c_{2}}}{\subst{c_{1}}{\alpha }{\kappa _{2}}}}\alpha \notin dom(\Delta )\]

\end_inset 


\layout Subsection

Well-formed Type 
\begin_inset Formula \( \typev{\tau } \)
\end_inset 


\layout Standard

Assume 
\begin_inset Formula \( \context  \)
\end_inset 

 is well-formed.
 Check that 
\begin_inset Formula \( \tau  \)
\end_inset 

 is well-formed.
\layout List
\labelwidthstring 00.00.0000

Constructor 
\begin_inset Formula 
\[
\frac{\kcheck{\context }{c}{T}}{\typev{c}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

ArrowType 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\kindvalid{\context }{\kappa } & \\
\typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}
\end{array}}{\typev{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\alpha \notin dom(\context )\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Float 
\begin_inset Formula 
\[
\axiom{\typev{Float}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

PairType 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\typev{\tau _{1}} & \typev{\tau _{2}}
\end{array}}{\typev{\tau _{1}\times \tau _{2}}}\]

\end_inset 


\layout Subsection

Type Synthesis 
\begin_inset Formula \( \types{e}{\tau } \)
\end_inset 


\layout Standard

Assume 
\begin_inset Formula \( \context  \)
\end_inset 

 is well-formed.
 Check that 
\begin_inset Formula \( e \)
\end_inset 

 is well-formed and construct its type 
\begin_inset Formula \( \tau  \)
\end_inset 

, where 
\begin_inset Formula \( \typev{\tau } \)
\end_inset 


\layout List
\labelwidthstring 00.00.0000

variable 
\begin_inset Formula 
\[
\axiom{\typesynth{\caddt{x}{\tau }}{x}{\tau }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

weakening1 
\begin_inset Formula 
\[
\infrule{\types{x}{\tau }}{\typesynth{\caddt{x'}{\tau '}}{x}{\tau }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

weakening2 
\begin_inset Formula 
\[
\infrule{\types{x}{\tau }}{\typesynth{\caddk{\alpha }{\kappa }}{x}{\tau }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

lete 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \typesynth{\caddt{x}{\tau _{1}}}{e_{2}}{\tau _{2}}
\end{array}}{\types{\lete{x}{e_{1}}{e_{2}}}{\tau _{2}}}x\notin dom(\context )\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

letc 
\begin_inset Formula 
\[
\frac{\begin{array}{ll}
\kindsynth{\context }{c}{\kappa } & \typesynth{\caddk{\alpha }{\kappa }}{e}{\tau }
\end{array}}{\types{\lete{\alpha }{c}{e}}{\subst{c}{\alpha }{\tau }}}\alpha \notin dom(\context )\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

rec 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\kindvalid{\context }{\kappa } & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{1}} & \typevalid{\caddk{\alpha }{\kappa }}{\tau _{2}}\\
\typesynth{\context \extt{f}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}\extk{\alpha }{\kappa }\extt{x}{\tau _{1}}}{e}{\tau _{2}'} & \typeequiv{\caddk{\alpha }{\kappa }}{\tau _{2}}{\tau _{2}'} & f,\alpha ,x\notin dom(\context )
\end{array}}{\types{\rec{f}{\alpha }{\kappa }{x}{\tau _{1}}{\tau _{2}}{e}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

app 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{(\alpha ::\kappa ,\tau _{1})\rightarrow \tau _{2}} &  & \kcheck{\context }{c}{\kappa }\\
\types{e_{2}}{\tau _{1}'} &  & \typeeq{\tau _{1}'}{\subst{c}{\alpha }{\tau _{1}}}
\end{array}}{\types{e_{1}[c]e_{2}}{\subst{c}{\alpha }{\tau _{2}}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

app2 
\begin_inset Formula 
\[
\infrule{\begin{array}{lll}
\types{e_{1}}{c_{e}} & \hnf{\context }{c_{e}}{c_{1}\rightarrow c_{2}} & \\
\types{e_{2}}{c_{1}'} & \coneq{c_{1}}{c_{1}'}{T} & 
\end{array}}{\types{e_{1}\, e_{2}}{c_{2}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

pair 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e_{1}}{\tau _{1}} & \types{e_{2}}{\tau _{2}}
\end{array}}{\types{<e_{1},e_{2}>}{\tau _{1}\times \tau _{2}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

type_proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}} & 
\end{array}}{\types{e.1}{\tau _{1}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

con_proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.1}{c_{1}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

type_proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{\tau _{1}\times \tau _{2}} & 
\end{array}}{\types{e.2}{\tau _{2}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

con_proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{c_{1}\times c_{2}}
\end{array}}{\types{e.2}{c_{2}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

integer 
\begin_inset Formula 
\[
\axiom{\types{n}{Int}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

float 
\begin_inset Formula 
\[
\axiom{\types{r}{Float}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

box 
\begin_inset Formula 
\[
\infrule{\types{e}{Float}}{\types{box(e)}{BoxFloat}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

unbox 
\begin_inset Formula 
\[
\infrule{\types{e}{BoxFloat}}{\types{unbox(e)}{Float}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

ifzero 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\types{e}{c} & \hnf{\context }{c}{Int}\\
\types{e_{1}}{\tau _{1}} & \types{e_{2}}{\tau _{2}}\\
\typeeq{\tau _{1}}{\tau _{2}} & 
\end{array}}{\types{\ifz{e}{e_{1}}{e_{2}}}{\tau _{1}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

ifFloat 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\typev{\tau } & \types{e_{1}}{\tau _{1}}\\
\types{e_{2}}{\tau _{2}} & \typeeq{\tau _{1}}{\tau _{2}}
\end{array}}{\types{\iffloat{\tau }{e_{1}}{e_{2}}}{\tau _{1}}}\]

\end_inset 


\layout Subsection

Path Extraction 
\begin_inset Formula \( \pext{p}{\kappa } \)
\end_inset 


\layout Standard

Assumes that 
\begin_inset Formula \( \Delta  \)
\end_inset 

 and 
\begin_inset Formula \( p \)
\end_inset 

 are well-formed.
 Returns the unselfified kind of 
\begin_inset Formula \( p \)
\end_inset 

.
 
\layout List
\labelwidthstring 00.00.0000

Variable 
\begin_inset Formula 
\[
\axiom{\pathextract{\caddk{\alpha }{\kappa }}{\alpha }{\kappa }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Weakening1 
\begin_inset Formula 
\[
\infrule{\pext{\alpha }{\kappa }}{\pathextract{\caddk{\alpha '}{\kappa '}}{\alpha }{\kappa }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Weakening2 
\begin_inset Formula 
\[
\infrule{\pext{\alpha }{\kappa }}{\pathextract{\caddt{x}{\tau }}{\alpha }{\kappa }}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\pext{p}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p.1}{\kappa _{1}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\pext{p}{\Sigma (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p.2}{K(\subst{p.1}{\alpha }{\kappa _{2}})}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

App 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\pext{p}{\Pi (\alpha ::\kappa _{1}).\kappa _{2}} & 
\end{array}}{\pext{p\, c}{\subst{c}{\alpha }{\kappa _{2}}}}\]

\end_inset 


\layout Subsection

Constructor Head Normal Form 
\begin_inset Formula \( \hnf{\context }{c}{c'} \)
\end_inset 


\layout Standard

Assumes that 
\begin_inset Formula \( \Delta  \)
\end_inset 

 and 
\begin_inset Formula \( c \)
\end_inset 

 are well-formed.
 Returns the head normal form of 
\begin_inset Formula \( c \)
\end_inset 

.
 
\layout List
\labelwidthstring 00.00.0000

Variable 
\begin_inset Formula 
\[
\infrule{\pext{x}{c}}{\hnf{\context }{x}{c}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Int 
\begin_inset Formula 
\[
\axiom{\hnf{\context }{Int}{Int}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

BoxFloat 
\begin_inset Formula 
\[
\axiom{\hnf{\context }{BoxFloat}{BoxFloat}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000


\begin_inset Formula \( \mu  \)
\end_inset 

 
\begin_inset Formula 
\[
\axiom{\Hnf{\mu (a=c_{1},b=c_{2})}{\mu (a=c_{1},b=c_{2})}}\]

\end_inset 

 
\layout List
\labelwidthstring 00.00.0000

Pair 
\begin_inset Formula 
\[
\axiom{\Hnf{c_{1}\times c_{2}}{c_{1}\times c_{2}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Arrow 
\begin_inset Formula 
\[
\axiom{\Hnf{c_{1}\rightarrow c_{2}}{c_{1}\rightarrow c_{2}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Lambda 
\begin_inset Formula 
\[
\axiom{\Hnf{\Lam{\alpha }{\kappa }{c}}{\Lam{\alpha }{\kappa }{c}}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

App 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{\lambda \alpha ::\kappa .c} & \Hnf{\subst{c_{2}}{\alpha }{c}}{c'}
\end{array}}{\Hnf{c_{1}\, c_{2}}{c'}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

App
\begin_inset Formula \( \sim  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c_{2}}{\st{c}}\\
\hnf{\context }{c}{c'} & 
\end{array}}{\Hnf{c_{1}\, c_{2}}{c'}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

App
\begin_inset Formula \( \sim \kappa  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c_{1}}{p} & \pext{p\, c_{2}}{\kappa }
\end{array}}{\Hnf{c_{1}\, c_{2}}{p\, c_{2}}}\]

\end_inset 


\newline 
where 
\begin_inset Formula \( \kappa  \)
\end_inset 

 is not a singleton
\layout List
\labelwidthstring 00.00.0000

Record 
\begin_inset Formula 
\[
\axiom{\Hnf{<c_{1},c_{2}>}{<c_{1},c_{2}>}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj1 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c_{1}}{c_{1}'}
\end{array}}{\Hnf{c.1}{c_{1}'}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj1
\begin_inset Formula \( \sim  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c.1}{c''}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj1
\begin_inset Formula \( \sim \kappa  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.1}{\kappa }
\end{array}}{\Hnf{c.1}{p.1}}\]

\end_inset 


\newline 
where 
\begin_inset Formula \( \kappa  \)
\end_inset 

 is not a singleton
\layout List
\labelwidthstring 00.00.0000

Proj2 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{<c_{1},c_{2}>} & \Hnf{c}{c_{2}'}
\end{array}}{\Hnf{c.1}{c_{2}'}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj2
\begin_inset Formula \( \sim  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{\st{c'}}\\
\hnf{\context }{c'}{c''} & 
\end{array}}{\Hnf{c.2}{c''}}\]

\end_inset 


\layout List
\labelwidthstring 00.00.0000

Proj2
\begin_inset Formula \( \sim \kappa  \)
\end_inset 

 
\begin_inset Formula 
\[
\infrule{\begin{array}{ll}
\Hnf{c}{p} & \pext{p.2}{\kappa }
\end{array}}{\Hnf{c.2}{p.2}}\]

\end_inset 


\newline 
where 
\begin_inset Formula \( \kappa  \)
\end_inset 

 is not a singleton
\layout List
\labelwidthstring 00.00.0000

Let 
\begin_inset Formula 
\[
\infrule{\Hnf{\subst{c_{1}}{\alpha }{c_{2}}}{c}}{\Hnf{\Let{\alpha }{c_{1}}{c_{2}}}{c}}\]

\end_inset 


\the_end
