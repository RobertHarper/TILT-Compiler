====
TILT
====

The TILT compiler source is distributed in 8 directories:
Util, Parser, Elaborator, Nil, Rtl, Backend, Alpha, and Top.

Util provides a place to store miscellaneous files used by various
parts of TILT.

The Parser takes ML source code into the AST (abstract syntax tree).
In addition, the module level AST is put into named form
and free (user-level) type variables are bound.  

The Elabrator then takes the AST and translates this into HIL.  Since
HIL is fully typed, type inference is performed at the same time.
Some of the more important parts of the compilation process are
datatype compilation, pattern compilation, signature patching, and
coercion compilation.  Some of the other issues include overloading
resolution, flexible record types, infix parsing, and providing an
initial basis.  Providing an efficient data structure for identifier
lookup is tricky due to the "open" construct.

The Nil level is the core of the compiler.  Most optimizations occur here.
The most important part is the type checker and type normalizer.
Since normalization assumes well-formed, it is faster.  Ideally,
the typechecker will be off on during "final" use.  The phase-splitter
converts the HIL program into MIL.  At this point, all module-level
construct are eliminated.  After that, we perform some simple optimizations:
deaad code elimination, optimizing sums, and specializing polymorphic functions
used at one type.  Finally, closure conversion then takes place.
Many (if not all) of these transformations assume that the same variable
is never bound twice so we must occasionally perform an alpha conversion.

When we enter the RTL level, we generate low-level code for the first
time.  At this stage, we must choose all data representation.  The NIL
primitives and optimization goals and the RTL data representation
should be chosen with coordination!  The translation to RTL is quite
complex because it is dealing with several issues all at once.  First,
the translation of sums, cases on sums, and arrays is quite
specialized.  Second, the translator makes a distinction between
values and locations so that immediates are not repeatedly generated.
(This can cause a surprisingly large code bloat).  Third, using the
locations and values information, it must allocate globals and
statically allocate as much as possible.  Fourth, GC checks are
aggressively merged (e.g. across conditionals).  Fifth, exception
handlers are compiled into pseudo-closures.  Sixth, the translator
recognizes tail calls and translates these specially.  Other issues
include optimizing the cases on bools (= SUM(2;[])), arithmetic with
constant operands, write barriers.

The Backend directory contains the part of the backend that is relatively
architecturally independent such as def-use analysis, interference
graph construction, register allocation, and GC descriptor generation.

The Alpha directory provides a machine description of the DEC ALPHAs.
Instructions, register sets, calling conventions, a translator
from RTL to alpha code constitute this directory.

Finally, the overall interfaces to the compiler is in the Top directory.
These files allow TILT to be used interactively within NJ or
at the command line.  There is support for benchmarking, interacting
with the system assembler and loader, and a compilation manager.


============
File listing 
============

Below is a listing of all non-signature files.  Line counts and
brief descriptions are provided.

Util:
-----
64  bin_io_util.sml	Utility for binary I/O operations
149 blast.sml		Basic object exporter/importer
188 crc.sml		Checksum module
812 formatter.sml	Basic pretty-printer
180 graph.sml		General directed graph module
86  graphutil.sml	Chris Okasaki's graph utility module to compute SCC
257 listops.sml		Various versions of zips, unzips, member, ...
75  sorted_list.sml	Used by the Parser
220 stats.sml		Keeps track of timers and counters
334 tilword32.sml	TILT's local copy of Word32 (augments the NJ structure)
291 tilword64.sml	TILT will eventually need Word64 if we want to support this type on Alphas
87  util.sml		oneshots(references that can be updated once)

Parser:
-------
273  ast.sml		Defines the abstract syntax
473  asthelp.sml	NJ file providing utility for the AST
100  astutil.sml	TIL file providing utility for the AST (kept seprate because NJ was changing)
169  control.sml	NJ structure containing compiler flags
377  env.sml		Defines the Symbols used by the AST module
153  errormsg.sml	NJ file for error message at the lexing/parsing level
40   fixity.sml		Defines fixity(infix/nonfix) info used by the AST
150  frontend.sml	NJ file that puts all the pieces together
109  intstrmap.sml	NJ helper file
85   join.sml		NJ/Yacc helper file that joins the lexer and parser together
69   linkparse.sml	TIL link file; subsequent phases need to access only this module
77   lrtable.sml	NJ/Yacc helper file
3698 ml.grm.sml		ML grammar file
1536 ml.lex.sml		ML lex file
187  name.sml		TIL file to support labels, tags, variables, and maps/sets on these
89   nameblast.sml	TIL file to support export/import of labels, tags, variables, ...
181  namedform.sml	TIL file that anormalized the AST at the module level
572  parser2.sml	NJ helper file
53   pathnames.sml	NJ helper file
563  pp.sml		NJ helper file
945  ppast.sml		NJ helper file
95   ppqueue.sml	NJ helper file
94   printutil.sml	NJ helper file
68   sortedlist.sml	NJ helper file
57   source.sml		NJ helper file
199  sourcemap.sml	NJ file providing a mapping from AST "srcpos" to the file positions
39   stream.sml		NJ helper file
50   strghash.sml	NJ string hashing used by the Symbols module
125  tokentable.sml	NJ helper file
349  tvclose.sml	TIL file to bind free user-level type varible


Elaborator:
-----------
110  tyvar.sml		Defines type meta-variables (used for type inference)
				and "overloaded" types
139  prim.sml		Defines generic term level primitives(arithmetic, arrays, ...)
				parametrized by types and non-primitive terms
302  ppprim.sml		Pretty-printing for primitives
430  primutil.sml	Utility functions for primitives parameterized by types 
				and non-primitive terms
59  ilprimutilparam.sml	Defines the HIL level parameters used by the primitives utility module
153  il.sml		Defines the HIL datatype; uses the tyvar and prim module
518  ppil.sml		Pretty-printing for HIL
635  ilcontext.sml	Defines HIL context and various lookup routines
1126 ilcontexteq.sml	Defines HIL context (and type, term, ...) equivalence;
				used by compilation manager
1339 ilutil.sml		HIL utilities: general substitution, rebinding variables
2083 ilstatic.sml		HIL typechecker and type unifier
69   error.sml		Error module for reporting user errors during elaboration
1040 datatype.sml		Datatype compilation
325  equal.sml		Equality compilation
321  infixparse.sml	Parsing possibly infixed expressions and patterns;
				this cannot be done prior to elaboration since
				fixity directives may occur throughout the program
1024 pat.sml		Pattern compilation
2583 toil.sml		The main elaborator uses all of the above modules.
500  ileval.sml		HIL evaluator
597  basis.sml		The "core" basis defines base types (int, float, ...)
				and base primitives (+, -, ...)
534  linkil.sml		Puts the elaborator together


Nil:
----
47   nilprimutilparam.sml	MIL parameter to the primitives module
186  nil.sml		MIL language
457  ppnil.sml		NIL pretty-printer
710  subst.sml		NIL substitutions
1491 nilutil.sml	MIL utility functions
457  linearize.sml	Alpha convert a MIL module so the same variable is never bound twice
138  nilerror.sml	NIL error messages during typechecking
2035 nilstatic.sml	NIL typechecker
989  normalize.sml	NIL type reduce (assumes well-formed)
78   alpha_context.sml	Allows substituions to be performed lazily
216  nilcontext.sml	NIL typing contexts
8    annote.sml		NIL annotations
3707 tonil.sml		NIL phase-splitter
685  optimize.sml	NIL one-pass optimizer (dead code elimination, optimizes sums)
367  specialize.sml	NIL two-pass optimizer (specializes polymorphic functions used at one type)
1711 toclosure.sml	NIL closure-converter
461  nileval.sml	NIL evaluator
564  linknil.sml	Puts the NIL phase together


Rtl:
----
236  rtl.sml		RTL language
436  pprtl.sml		Pretty-printing RTL
129  rtlheap.sml	Simulates RTL memory
786  rtlinterp.sml	RTL interpreter
171  rtloper.sml	RTL instruction evaluator
764  rtlopt.sml		RTL level optimizer
148  rtlregister.sml	RTL registers
108  tags.sml		RTL tag representation
1436 tortl-base.sml	Provides basic functions needed to translate Nil code to RTL
3030 tortl.sml		Translator from NIL to RTL
127  linkrtl.sml	Puts the RTL phase together

Backend:
--------
231  bblock.sml		Basic block module
432  chaitin.sml	Register Allocator
204  color1.sml		Interference graph colorer
337  ifgraph.sml	Interference graph
 25  labelgraph.sml	Procedure level graphs
 20  labelmap.sml	Procedure level maps
245  printutils.sml	Pretty-printing
126  recursion.sml	Divide functions into connected components such that
				functions from different components do not directly call each other
 68  regmap.sml		Maps from registers to values
 18  regset.sml		Register sets
469  rtltoasm.sml	Non-architecture specific portion of translation from RTL to native assembly
495  tracetable.sml	Compute GC descriptors
 26  vargraph.sml	Used for expressing call graphs

Note: There is no link file here since the backend is parameterized by the architecture.


Alpha:
------
106  callconv.sml	Calling convention for ML and C on the Alpha.
803  decalpha.sml	DEC Alpha datatype
154  decalphautils.sml	Alpha utilities
416  divmult.sml	Optimize division/multiplcation by constants.
1303 toalpha.sml	Translate from Alpha to RTL.
238  trackstorage.sml	Keeps track of the stack frame.
232  linkalpha.sml	Puts the Backend and Alpha directory together.

Top:
----
58 compiler.sml
301 linker.sml		Calls the assembler and linker with the right flags.
284 makedep.sml		Create dependency for generating makefiles
529 manager.sml		Compilation manager
265 linkall.sml		Puts TILT together
826 measure.sml		Used for profiling and benchmarking
61 distribute.sml	Exports TILT for command-line usage
420 toplevel.sml	Interactive loop for testing the compiler

