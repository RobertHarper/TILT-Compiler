HIGH PRIORITY
-------------
(0) Remove unnecessary renaming in HIL and various NIL phases; 
	systematically rename in tonil

(1) Debug the typechecker and fix bugs in compiler that the checker reveals
        The typechecker is *really* slow on functors.  Profiling reveals
        that a lot of time is spent in the rewriter. Why?

(2) Change NIL to include reify results at function formals

(3) modify tortl to fully rely on reification results;
	after this, all "assuming TRACE" messages should disappear
        Also, make sure the xxx_type variables don't appear in the
        assembly code

(4) document how the system is used (mapfiles and make)

(5) The phase-splitter is marking all functors as partial because
        it doesn't have enough information.  Either it has to keep
        a term-level context, or HIL functors must be marked TOTAL/PARTIAL

(6) It appears that some functions in the run-time allocate memory on the
        heap, but assert(0) rather than invoking GC if the heap happens to
        already be full.

(7) If you run the TILT executable and don't give it a valid mapfile,
        the program crashes with a bus error (?)

(8) Type sharing between datatypes and non-datatypes isn't handled
        properly by the elaborator.  If we have
            type t
            datatype u = A
            sharing t = u
        it seems the equality between t and u is forgotten when the
        datatype is exposed as a recursive type. (that is, t remains
        abstract.)  Symptom: Parser/join.sml does not typecheck
        (the hil code ought not typecheck if we did typechecking, 
        the phase-split code definitely does not typecheck)
        Also, Alpha/divmult.sml fails for the same reason.
	Also, Alpha/toalpha.sml.
	The real culprit with these is a sharing spec in
        decalpha.sig.sml, which manifests itself in other places.
		

(9) Problem with elaboration:
	datatype foo = Foo of int

	(*Works fine*)
	fun f x = g (fn x => Foo x)
	and g fooer = fooer 3

	(*Works fine*)
	fun g fooer = fooer 3
	and f x = g Foo

	(*Doesn't work*)
	fun f x = g Foo
	and g fooer = fooer 3


NORMAL PRIORITY
---------------
(0) record type should no longer be a primcon

(1) change xcoerce_transparent to copy only the needed type components
	currently ilcontext, transparently ascribed generates a LOT of kinds in NIL	

(2) Can't have variable named extern.  Should extern be a keyword as it currently is?

(3) NJ 109.32 does not accept this.  what is the precise meaning of structure sharing/where-ing?

signature Inner = sig type t end

signature Middle1 = 
sig
  structure Inner : Inner
end

signature Middle2 = 
sig
  structure Inner : Inner
end

signature Outer = 
sig
  structure Middle1 : Middle1
  structure Middle2 : Middle2
  sharing Middle1.Inner = Middle2.Inner
end

functor Maker(structure Middle1 : Middle1
	      structure Middle2 : Middle2
	      sharing Middle1.Inner = Middle2.Inner)
    :> Outer where Middle1 = Middle1
             where Middle2 = Middle2 
   =
struct
    structure Middle1 = Middle1
    structure Middle2 = Middle2
end

structure Inner :> Inner = struct type t = int end
structure Middle1 = struct structure Inner = Inner end
structure Middle2 = struct structure Inner = Inner end
structure Outer = Maker(structure Middle1 = Middle1
			structure Middle2 = Middle2)

(4) dropping the :> in ast.sml and replacing it with : causes the NIL optimizer to loop

(5) sharing a partly shared structure is bad

(6) floating point is wrong right now
	Currently, we place a trap barrier after each floating point instruction.
	We use the "su" version of the floating point instruction.
	For overflow and division by zero, our signal handler is not even
		called and the OS puts the right answer there.
		For NaNs, the right answer is put there but our
		signal handler is also called.  For this case, we just return.
	The OS handler may not be able to detect the correct answer
		if the floating point instruction's src and dest registers are the same.



        
LOW PRIORITY
------------
(0) type of thunk prematurely made a rigid record
fun g {a,b} = a + b + 3

fun f thunk = 
  let val {a, ...} = thunk  
  in  g thunk
  end

(1) handle specially datatypes of the form; handle irrefutable case in 
	patterm matcher

	datatype foo = FOO of int
	val FOO x = (y : foo)

(2) improve this error msg:

	Error: infixparse.sml: parse_pat on subcall yielded multiple patterns

(3) backend liveness analysis is too conservative
        We recently fixed a backend bug where liveness analysis was not taking
        COMPUTE's into account, so that a variable could be live long after
        its type was considered dead; when the type was needed to GC this
        variable, the program crashed.

        The fix was to ensure that the type was always live whenever the
        variable was, by defining the pseudoregisters used by an instruction
        to include the variables in the representation of the
        pseudoregisters used.

        This is too conservative; we don't need to keep the type live
        if we know the variable will not be live across a function or
        GC call.  A better fix is to undo this last change to defUse
        and instead define function/GC calls to be uses of the types
        of all variables live across the call.