HIGH PRIORITY
-------------


NORMAL PRIORITY
---------------
(1) change xcoerce_transparent to copy only the needed type components
	currently ilcontext, transparently ascribed generates a LOT of kinds in NIL	

(2) Can't have variable named extern.  Should extern be a keyword as it currently is?

(3) NJ 109.32 does not accept this.  what is the precise meaning of structure sharing/where-ing?

signature Inner = sig type t end

signature Middle1 = 
sig
  structure Inner : Inner
end

signature Middle2 = 
sig
  structure Inner : Inner
end

signature Outer = 
sig
  structure Middle1 : Middle1
  structure Middle2 : Middle2
  sharing Middle1.Inner = Middle2.Inner
end

functor Maker(structure Middle1 : Middle1
	      structure Middle2 : Middle2
	      sharing Middle1.Inner = Middle2.Inner)
    :> Outer where Middle1 = Middle1
             where Middle2 = Middle2 
   =
struct
    structure Middle1 = Middle1
    structure Middle2 = Middle2
end

structure Inner :> Inner = struct type t = int end
structure Middle1 = struct structure Inner = Inner end
structure Middle2 = struct structure Inner = Inner end
structure Outer = Maker(structure Middle1 = Middle1
			structure Middle2 = Middle2)

(4) dropping the :> in ast.sml and replacing it with : causes the NIL optimizer to loop

(5) sharing a partly shared structure is bad

(6) floating point is wrong right now
	Currently, we place a trap barrier after each floating point instruction.
	We use the "su" version of the floating point instruction.
	For overflow and division by zero, our signal handler is not even
		called and the OS puts the right answer there.
		For NaNs, the right answer is put there but our
		signal handler is also called.  For this case, we just return.
	The OS handler may not be able to detect the correct answer
		if the floating point instruction's src and dest registers are the same.

(7) backend liveness analysis is too conservative
        We recently fixed a backend bug where liveness analysis was not taking
        COMPUTE's into account, so that a variable could be live long after
        its type was considered dead; when the type was needed to GC this
        variable, the program crashed.

        The fix was to ensure that the type was always live whenever the
        variable was, by defining the pseudoregisters used by an instruction
        to include the variables in the representation of the
        pseudoregisters used.

        This is too conservative; we don't need to keep the type live
        if we know the variable will not be live across a function or
        GC call.  A better fix is to undo this last change to defUse
        and instead define function/GC calls to be uses of the types
        of all variables live across the call.

        
LOW PRIORITY
------------
(0) type of thunk prematurely made a rigid record
fun g {a,b} = a + b + 3

fun f thunk = 
  let val {a, ...} = thunk  
  in  g thunk
  end

(1) handle specially datatypes of the form; handle irrefutable case in 
	patterm matcher

	datatype foo = FOO of int
	val FOO x = (y : foo)

(2) improve this error msg:

	Error: infixparse.sml: parse_pat on subcall yielded multiple patterns