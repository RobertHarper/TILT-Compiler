HIGH PRIORITY
-------------
(1) compilation manager should not trust the ordering in mapfiles


NORMAL PRIORITY
---------------
(0) type of thunk prematurely made a rigid record
fun g {a,b} = a + b + 3

fun f thunk = 
  let val {a, ...} = thunk  
  in  g thunk
  end

(1) handle specially datatypes of the form; handle irrefutable case in 
	patterm matcher

	datatype foo = FOO of int
	val FOO x = (y : foo)

(2) improve this error msg:

	Error: infixparse.sml: parse_pat on subcall yielded multiple patterns

(3) the result type of mem_rec is not constraied to bool by the elaborator
fun mem_assoc dummy =
  let fun mem_rec (x : bool) : bool = (mem_rec x) 
  in mem_rec
  end

(5) change xcoerce_transparent to copy only the needed type components
	currently ilcontext, transparently ascribed generates a LOT of kinds in NIL	


(7)   fun top_rep (v,rep : var_loc option * var_val option * 'a) = 
      (case rep of
 	   (SOME(VGLOBAL _),_,_) => true 
	 | (_, SOME _, _) => true
	 | _ => false)

not generalizing the user 'a

(8) can't have variable named extern

(9) NJ 109.32 does not accept this.  what is the precise meaning of structure sharing/where-ing?

signature Inner = sig type t end

signature Middle1 = 
sig
  structure Inner : Inner
end

signature Middle2 = 
sig
  structure Inner : Inner
end

signature Outer = 
sig
  structure Middle1 : Middle1
  structure Middle2 : Middle2
  sharing Middle1.Inner = Middle2.Inner
end

functor Maker(structure Middle1 : Middle1
	      structure Middle2 : Middle2
	      sharing Middle1.Inner = Middle2.Inner)
    :> Outer where Middle1 = Middle1
             where Middle2 = Middle2 
   =
struct
    structure Middle1 = Middle1
    structure Middle2 = Middle2
end

structure Inner :> Inner = struct type t = int end
structure Middle1 = struct structure Inner = Inner end
structure Middle2 = struct structure Inner = Inner end
structure Outer = Maker(structure Middle1 = Middle1
			structure Middle2 = Middle2)

(10) dropping the :> in ast.sml and replacing it with : causes the NIL optimizer to loop

(11) sharing a partly shared structure is bad

(12) floating point is wrong right now
	Currently, we place a trap barrier after each floating point instruction.
	We use the "su" version of the floating point instruction.
	For overflow and division by zero, our signal handler is not even
		called and the OS puts the right answer there.
		For NaNs, the right answer is put there but our
		signal handler is also called.  For this case, we just return.
	The OS handler may not be able to detect the correct answer
		if the floating point instruction's src and dest registers are the same.
