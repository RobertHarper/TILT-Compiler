[This file is UTF8 unicode.]

Here is the syntax of the internal project description language (IL),
judgements to determine when an IL description is syntactically
well-formed, the syntax of the external project description language
(EL), and judgements to elaborate EL descriptions into well-formed IL
descriptions.


IL Syntax

The internal project description language is built up from unit
identifiers (U), interface identifiers (I), top-level declarations
(topdec), top-level specifications (topspec), parameterized interface
files (pinterface), and object files (object).  Recall that a
parameterized interface file is essentially a HS signature with all
dependencies on other units represented by paths rooted at parameters
(unit names) rather than variables.

	Unit lists
	units	::=	•
		|	units, U

	Interface source
	isrc	::=	OPEN units IN topspec

	Interface expressions
	iexp	::=	isrc
		|	PRIMITIVE
		|	(pinterface USING units) FROM isrc
		|	pinterface USING units

	Unit source
	usrc	::=	OPEN units IN topdec

	Unit expressions
	uexp	::=	usrc
		|	usrc : I
		|	PRIMITIVE : I
		|	(object USING units) FROM (usrc : I)
		|	(object USING units) OPENING units : I

	Project declarations
	pdec	::=	I = iexp
		|	U : I
		|	U = uexp

	Project descriptions
	desc	::=	•
		|	desc, pdec


Notes

The second form of iexp is the primitive unit's interface.  One of
these is used to describe the primitive unit in the basis library
source.

The third form of iexp is a pre-compiled interface as found in
libraries.  The invariants are that the units are the pinterface
parameters and that pinterface was generated by elaborating isrc.

The fourth form of iexp is a compiled interface that has no
corresponding source.  These have two purposes.  First, the primitive
unit's interface in the compiled basis library is a compiled interface
with no parameters.  Two such interfaces can be compared for
equivalence.  Second, the manager uses compiled interface dependencies
rather than source interface dependencies (ie, USING units rather than
OPEN units) when constructing compilation contexts in order to speed
up compilation.  NB the elaborator that follows does not produce
interfaces of the form (pinterface USING units) where units is
non-empty.

The second form of uexp is a source file sealed to an interface.

The third form of uexp is the primitive unit.  It only appears in the
project description used to compile the basis library.  Every other
project description uses a compiled basis library that defines the
primitive unit as an object file.

The fourth form of uexp is a pre-compiled unit as found in libraries.
The invariants are that the parameters of object (undefined linker
labels) are a subset of units and that object was generated by
compiling (usrc : I).

The fifth form of uexp is a compiled unit.  The invariants are that
the parameters of object are a subset of units and
that the object has interface I.  Units' must be linked in to any executable
containing uexp.


Definitions

Side conditions on rules in the following sections use some syntactic
definitions.

Free units and interfaces

	free : units → set
	free(•) = ∅
	free(units, U) = free(units) ∪ { U }

	free : isrc → set
	free(OPEN units IN topspec) = free(units)

	free : iexp → set
	free(isrc) = free(isrc)
	free(PRIMITIVE) = ∅
	free(pinterface USING units FROM isrc) = free(units) ∪ free(isrc)
	free(pinterface USING units) = free(units)

	free : usrc → set
	free(OPEN units IN topdec) = free(units)

	free : uexp → set
	free(usrc) = free(usrc)
	free(usrc : I) = free(usrc) ∪ { I }
	free(PRIMITIVE : I) = { I }
	free(object USING units FROM (usrc : I)) = free(units) ∪ free(usrc) ∪ { I }
	free(object USING units OPENING units' : I) = free(units) ∪ free(units') ∪ { I }

Units and interfaces defined in desc

	dom : desc → set
	dom(•) = ∅
	dom(desc, I = iexp) = dom(desc) ∪ { I }
	dom(desc, U : I) = dom(desc) ∪ { U }
	dom(desc, U = uexp) = dom(desc) ∪ { U }


Syntactic Checks

A project description is well-formed if no unit or interface is used
before it is defined and if each unit and interface is defined once.

Judgements

	⊢ desc ok		desc is well-formed
	desc ⊢ pdec ok		pdec is well-formed

⊢ desc ok

	⊢ • ok

	If ⊢ desc ok
	and desc ⊢ pdec ok
	then ⊢ desc, pdec ok

desc ⊢ pdec ok


	If I ∉ dom(desc)
	and free(iexp) ⊂ dom(desc)
	then desc ⊢ I = iexp ok

	If U ∉ dom(desc)
	and I ∈ dom(desc)
	then desc ⊢ U : I ok

	If U ∉ dom(desc)
	and free(uexp) ⊂ dom(desc)
	then desc ⊢ U = uexp ok


EL Syntax

This section describes the abstract syntax of the external project
description language.  This is simpler than the concrete syntax.
First, the EL is not concerned with how units, interfaces, and the
project description are arranged as files on disk.  Second, the EL
does not have an expression language or conditional compilation.
Finally, EL compiled interfaces and compiled units are more explicit:
The stuff in angle brackets is not written down in the concrete
syntax.

	Interface expressions
	ie	::=	topspec
		|	topspec { units }
		|	PRIMITIVE
		|	COMPILED<pinterface,units> topspec { units' }
		|	COMPILED<pinterface>

	Unit expressions
	ue	::=	topdec
		|	topdec { units }
		|	topdec : I
		|	topdec { units } : I
		|	PRIMITIVE : I
		|	COMPILED<object,units> topdec { units' } : I
		|	COMPILED<object,units> { units' } : I

	Project description entries
	ent	::=	INTERFACE I = ie
		|	UNIT U : I
		|	UNIT U = ue

	Project descriptions
	ents	::=	•
		|	ents, ent


Elaboration

Elaboration performs three small tasks.  First, the lists of "opened"
units are made explicit; for example,

	unit A = "A.sml"
	unit B = "B.sml"

elaborates to

	unit A = "A.sml" {}
	unit B = "B.sml" {A}

Second, any unit definitions after the first are eliminated; for
example,

	interface I₁ = "I₁.int" {}
	unit U : I₁ = "U.sml" {}
	interface I₂ = "I₂.int" {}
	unit U : I₂

elaborates to

	interface I₁ = "I₁.int" {}
	unit U : I₁ = "U.sml" {}
	interface I₂ = "I₂.int" {}

provided I₁ and I₂ are equivalent interfaces.  Third, duplicate
interface definitions are eliminated; for example,

	interface I = "I₁.int" {}
	interface I = "I₂.int" {}

elaborates to

	interface I = "I₁.int" {}

provided the interfaces are equivalent.

Elaboration also performs syntactic checks so that we have

	If ⊢ ents ⇒ desc
	then ⊢ desc ok.

Judgements

	⊢ ents ⇒ desc				project elaboration
	desc ⊢ ie ⇒ iexp			interface elaboration
	desc ⊢ ue ⇒ uexp			unit elaboration
	⊢ desc ↓ units				desc defines units
	desc ⊢ U : I				U has interface I
	⊢ uexp : I				"read off" I from uexp

	⊢ iexp₁ ≡ iexp₂				interface equivalence
	⊢ iexp → isrc				"read off" source from iexp
	⊢ pinterface₁ ≡ pinterface₂ HS		pinterface equivalence

The judgement ⊢ pinterface₁ ≡ pinterface₂ HS compares
parameterized interfaces in the empty context; it is essentially HS
signature equivalence.  It is only used when linking the compiled
basis library with some other compiled library to verify that the
primitive unit's interface has not changed.

⊢ ents ⇒ desc

	⊢ • ⇒ •

	If ⊢ ents ⇒ desc
	and (I = iexp) ∈ desc
	and desc ⊢ ie ⇒ iexp'
	and ⊢ iexp ≡ iexp'
	then ⊢ (ents, INTERFACE I = ie) ⇒ desc

	If ⊢ ents ⇒ desc
	and I ∉ dom(desc)
	and desc ⊢ ie ⇒ iexp
	then ⊢ (ents, INTERFACE I = ie) ⇒ (desc, I = iexp)

	If ⊢ ents ⇒ desc
	and desc ⊢ U : I'
	and (I' = iexp') ∈ desc
	and (I = iexp) ∈ desc
	and ⊢ iexp ≡ iexp'
	then ⊢ (ents, UNIT U : I) ⇒ desc

	If ⊢ ents ⇒ desc
	and I ∈ dom(desc)
	and U ∉ dom(desc)
	then ⊢ (ents, UNIT U : I) ⇒ (desc, U : I)

	If ⊢ ents ⇒ desc
	and U ∉ dom(desc)
	and desc ⊢ ue ⇒ uexp
	then ⊢ (ents, UNIT U = ue) ⇒ (desc, U = uexp)

desc ⊢ ie ⇒ iexp

	If ⊢ desc ↓ units
	then desc ⊢ topspec ⇒ OPEN units IN topspec

	If units ⊂ dom(desc)
	then desc ⊢ topspec { units } ⇒ OPEN units IN topspec

	desc ⊢ PRIMITIVE ⇒ PRIMITIVE

	If units ⊂ dom(desc)
	and units' ⊂ dom(desc)
	then desc ⊢ COMPILED<pinterface,units> topspec { units' } ⇒
		(pinterface USING units) FROM (OPEN units' IN topspec)

	desc ⊢ COMPILED<pinterface> ⇒ pinterface USING •

desc ⊢ ue ⇒ uexp

	If ⊢ desc ↓ units
	then desc ⊢ topdec ⇒ OPEN units IN topdec

	If units ⊂ dom(desc)
	then desc ⊢ topdec { units } ⇒ OPEN units IN topdec

	If I ∈ dom(desc)
	and ⊢ desc ↓ units
	then desc ⊢ topdec : I ⇒ (OPEN units IN topdec) : I

	If I ∈ dom(desc)
	and units ⊂ dom(desc)
	then desc ⊢ topdec { units } : I ⇒ (OPEN units IN topdec) : I

	If I ∈ dom(desc)
	then desc ⊢ PRIMITIVE : I ⇒ PRIMITIVE : I

	If units ⊂ dom(desc)
	and units' ⊂ dom(desc)
	and I ∈ dom(desc)
	then desc ⊢ COMPILED<object,units> topdec { units' } : I ⇒
		(object USING units) FROM ((OPEN units' IN topdec) : I)

	If units ⊂ dom(desc)
	and I ∈ dom(desc)
	then desc ⊢ COMPILED<object,units> { units' } : I ⇒
		((object USING units) OPENING units' : I)

desc ⊢ U : I

	If (U : I) ∈ desc
	then desc ⊢ U : I

	If (U = uexp) ∈ desc
	and ⊢ uexp : I
	then desc ⊢ U : I

⊢ uexp : I

	⊢ (usrc : I) : I

	⊢ (PRIMITIVE : I) : I

	⊢ (object USING units) FROM (usrc : I) : I

	⊢ ((object USING units) : I) : I

⊢ desc ↓ units

	⊢ • ↓ •

	If ⊢ desc ↓ units
	then ⊢ desc, U : I ↓ units, U

	If ⊢ desc ↓ units
	then ⊢ desc, U = uexp ↓ units, U

⊢ iexp₁ ≡ iexp₂

	If ⊢ iexp₁ → isrc
	and ⊢ iexp₂ → isrc
	then ⊢ iexp₁ ≡ iexp₂

	If ⊢ pinterface₁ ≡ pinterface₂ HS
	then ⊢ pinterface₁ ≡ pinterface₂

⊢ iexp → isrc

	⊢ isrc → isrc

	⊢ (pinterface USING units) FROM isrc → isrc

⊢ pinterface₁ ≡ pinterface₂ HS

	The rules are not written out here.
