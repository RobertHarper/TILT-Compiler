Number: 0066
Title:       Trace tables may be too large.
Keywords:    trace tables, reifier
Submitter:   David Swasey <swasey@cs.cmu.edu>
Date:        11/16/01
Version:     CVS
System:	     any
Severity:    minor
Problem:
	The following comments were written before I isolated bug
	0065.  They represent guesses only.  I'm leaving them because
	improving the reifier and measuring the size of trace tables
	might become important later.
Code:
Transcript:
Comments:
	With the opaque interpretation of datatypes, more types are
	held abstract than under the transparent interpretation.
	Accordingly, the reifier generates more TraceCompute
	annotations.  Several things can be done:

	1. Possible improvements to the reifier must be considered.
	   This pass generates poor code and yet it must follow, and
	   so can not benefit from, other optimizations.

	2. Some measurements should be performed.  We should quantify
	   the effect of the opaque interpretation on trace table
	   size.  Our measurements should include the Basis and as
	   much of the compiler as can be built under the opaque
	   interpretation.

	As an approach to (1), I added an additional "hoist, optimize,
	reify" pass after the second reification (just prior to
	closure conversion) and compared the before and after nil
	modules.  This heavy-weight cleanup of the nil code did not
	shrink the trace tables enough to pass the sanity check but it
	did uncover some problems with the reifier.

	After Reify2, we see lots of constructor bindings like

		STATIC reify_35703 = type_31898,

	where we presumably do TraceCompute(reify_35703) and could
	just as well have done TraceCompute(type_31898).  Some simple
	path compression seems to be in order.

	The code generated by reification could use cleanup such as
	hoisting, eliminating dead constructor bindings, and
	eliminating redundant constructor bindings.

	...
	    val hack_hoist      = makeEntry (true, "HackHoist")
	    val hack_reify      = makeEntry (true, "HackReify")
	    val hack_optimize   = makeEntry (true, "HackOptimize")
	... just prior to closure conversion ...
	    val nilmod = transform hack_hoist (Hoist.optimize, nilmod)
	    val nilmod = transform hack_optimize (Optimize.optimize {doDead = true, 
								     doProjection = SOME 50,
								     doCse = !do_cse, 
								     doUncurry = !do_uncurry},
						  nilmod)
	    val nilmod = transform hack_reify (Reify.reify_mod, nilmod)
Fix:
Test:
Owner: swasey
Status: closed
