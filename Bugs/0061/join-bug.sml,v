head	1.7;
access;
symbols;
locks; strict;
comment	@# @;


1.7
date	2001.11.02.16.59.37;	author swasey;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.02.16.56.03;	author swasey;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.02.16.55.49;	author swasey;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.02.16.48.56;	author swasey;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.02.16.34.18;	author swasey;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.02.16.14.12;	author swasey;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.02.16.09.52;	author swasey;	state Exp;
branches;
next	;


desc
@@


1.7
log
@*** empty log message ***
@
text
@(*$import *)

signature PARSER_DATA =
sig
    datatype 'a token = TOKEN
end

functor JoinWithArg (structure ParserData : PARSER_DATA) =
struct
end
@


1.6
log
@*** empty log message ***
@
text
@d4 3
a6 3
    sig
        datatype 'a token = TOKEN
    end
d8 1
a8 1
functor JoinWithArg (structure ParserData: PARSER_DATA) =
@


1.5
log
@*** empty log message ***
@
text
@d5 1
a5 1
        datatype ('a,'b) token = TOKEN
@


1.4
log
@*** empty log message ***
@
text
@d1 1
a1 1
(*$import Prelude TopLevel *)
d3 1
a3 1
signature TOKEN =
d8 1
a8 8
signature PARSER_DATA =
   sig
 
	structure Token : TOKEN

    end

functor JoinWithArg(structure ParserData: PARSER_DATA) =
a9 1
    structure Token = ParserData.Token (* error changes if this line is deleted *)
@


1.3
log
@*** empty log message ***
@
text
@a2 35
signature STREAM =
 sig type 'xa stream
     val streamify : (unit -> '_a) -> '_a stream
     val cons : '_a * '_a stream -> '_a stream
     val get : '_a stream -> '_a * '_a stream
 end

signature LR_TABLE =
    sig
        datatype ('a,'b) pairlist = EMPTY | PAIR of 'a * 'b * ('a,'b) pairlist
	datatype state = STATE of int
	datatype term = T of int
	datatype nonterm = NT of int
	datatype action = SHIFT of state
			| REDUCE of int
			| ACCEPT
			| ERROR
	type table
	
	val numStates : table -> int
	val numRules : table -> int
	val describeActions : table -> state ->
				(term,action) pairlist * action
	val describeGoto : table -> state -> (nonterm,state) pairlist
	val action : table -> state * term -> action
	val goto : table -> state * nonterm -> state
	val initialState : table -> state
	exception Goto of state * nonterm

	val mkLrTable : {actions : ((term,action) pairlist * action) array,
			 gotos : (nonterm,state) pairlist array,
			 numStates : int, numRules : int,
			 initialState : state} -> table
    end

d5 1
a5 3
	structure LrTable : LR_TABLE
        datatype ('a,'b) token = TOKEN of LrTable.term * ('a * 'b * 'b)
	val sameToken : ('a,'b) token * ('a,'b) token -> bool
a7 60
signature LR_PARSER =
    sig
	structure Stream: STREAM
	structure LrTable : LR_TABLE
	structure Token : TOKEN

	sharing LrTable = Token.LrTable

	exception ParseError

	val parse : {table : LrTable.table,
		     lexer : ('_b,'_c) Token.token Stream.stream,
		     arg: 'arg,
		     saction : int *
			       '_c *
				(LrTable.state * ('_b * '_c * '_c)) list * 
				'arg ->
				     LrTable.nonterm *
				     ('_b * '_c * '_c) *
				     ((LrTable.state *('_b * '_c * '_c)) list),
		     void : '_b,
		     ec : { is_keyword : LrTable.term -> bool,
			    noShift : LrTable.term -> bool,
			    preferred_change : (LrTable.term list * LrTable.term list) list,
			    errtermvalue : LrTable.term -> '_b,
			    showTerminal : LrTable.term -> string,
			    terms: LrTable.term list,
			    error : string * '_c * '_c -> unit
			   },
		     lookahead : int  (* max amount of lookahead used in *)
				      (* error correction *)
			} -> '_b *
			     (('_b,'_c) Token.token Stream.stream)
    end

signature LEXER =
   sig
       structure UserDeclarations :
	   sig
	        type ('a,'b) token
		type pos
		type svalue
	   end
	val makeLexer : (int -> string) -> unit -> 
         (UserDeclarations.svalue,UserDeclarations.pos) UserDeclarations.token
   end

signature ARG_LEXER =
   sig
       structure UserDeclarations :
	   sig
	        type ('a,'b) token
		type pos
		type svalue
		type arg
	   end
	val makeLexer : (int -> string) -> UserDeclarations.arg -> unit -> 
         (UserDeclarations.svalue,UserDeclarations.pos) UserDeclarations.token
   end

a10 9
	type pos

	type svalue

 	type arg
 
	type result

	structure LrTable : LR_TABLE
a11 11
	sharing Token.LrTable = LrTable

	structure Actions : 
	  sig
	      val actions : int * pos *
		   (LrTable.state * (svalue * pos * pos)) list * arg->
		         LrTable.nonterm * (svalue * pos * pos) *
			 ((LrTable.state *(svalue * pos * pos)) list)
	      val void : svalue
	      val extract : svalue -> result
	  end
a12 11
	structure EC :
	   sig
	     val is_keyword : LrTable.term -> bool
	     val noShift : LrTable.term -> bool
 	     val preferred_change : (LrTable.term list * LrTable.term list) list
	     val errtermvalue : LrTable.term -> svalue
	     val showTerminal : LrTable.term -> string
	     val terms: LrTable.term list
	   end

	val table : LrTable.table
d15 1
a15 60
signature PARSER =
    sig
        structure Token : TOKEN
	structure Stream : STREAM
	exception ParseError

	type pos

	type result

 	type arg
	
	type svalue

	val makeLexer : (int -> string) ->
			 (svalue,pos) Token.token Stream.stream

	val parse : int * ((svalue,pos) Token.token Stream.stream) *
		    (string * pos * pos -> unit) * arg ->
				result * (svalue,pos) Token.token Stream.stream

	val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token ->
				bool
     end

signature ARG_PARSER = 
    sig
        structure Token : TOKEN
	structure Stream : STREAM
	exception ParseError

	type arg
	type lexarg
	type pos
	type result
	type svalue

	val makeLexer : (int -> string) -> lexarg ->
			 (svalue,pos) Token.token Stream.stream
	val parse : int * ((svalue,pos) Token.token Stream.stream) *
		    (string * pos * pos -> unit) * arg ->
				result * (svalue,pos) Token.token Stream.stream

	val sameToken : (svalue,pos) Token.token * (svalue,pos) Token.token ->
				bool
     end


functor JoinWithArg(structure ParserData: PARSER_DATA
		    structure LrParser : LR_PARSER
		    structure Lex : ARG_LEXER
			where type ('a,'b) UserDeclarations.token = ('a,'b) ParserData.Token.token

		    sharing ParserData.LrTable = LrParser.LrTable
		    sharing ParserData.Token = LrParser.Token
		    sharing type Lex.UserDeclarations.svalue = ParserData.svalue
		    sharing type Lex.UserDeclarations.pos = ParserData.pos)

		 :> ARG_PARSER
		=
d17 1
a17 30
    structure Token = ParserData.Token
    structure Stream = LrParser.Stream

    exception ParseError = LrParser.ParseError

    type arg = ParserData.arg
    type lexarg = Lex.UserDeclarations.arg
    type pos = ParserData.pos
    type result = ParserData.result
    type svalue = ParserData.svalue

    val makeLexer = fn s => fn arg =>
		 LrParser.Stream.streamify (Lex.makeLexer s arg)
    val parse = fn (lookahead,lexer,error,arg) =>
	(fn (a,b) => (ParserData.Actions.extract a,b))
     (LrParser.parse {table = ParserData.table,
	        lexer=lexer,
		lookahead=lookahead,
		saction = ParserData.Actions.actions,
		arg=arg,
		void= ParserData.Actions.void,
	        ec = {is_keyword = ParserData.EC.is_keyword,
		      noShift = ParserData.EC.noShift,
		      preferred_change = ParserData.EC.preferred_change,
		      errtermvalue = ParserData.EC.errtermvalue,
		      error=error,
		      showTerminal = ParserData.EC.showTerminal,
		      terms = ParserData.EC.terms}}
      )
    val sameToken = Token.sameToken
@


1.2
log
@*** empty log message ***
@
text
@d1 189
a189 1
(*$import YaccBase TopLevel *)
@


1.1
log
@Initial revision
@
text
@d13 1
a13 7
		 :> ARG_PARSER  where Token = ParserData.Token
				where Stream = LrParser.Stream
				where type svalue = ParserData.svalue
				where type result = ParserData.result
				where type pos = ParserData.pos
				where type arg = ParserData.arg
				where type lexarg = Lex.UserDeclarations.arg
@
