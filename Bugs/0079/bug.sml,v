head	1.40;
access;
symbols;
locks; strict;
comment	@# @;


1.40
date	2002.06.25.15.26.31;	author swasey;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.25.15.24.11;	author swasey;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.20.14.42.49;	author swasey;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.20.14.40.26;	author swasey;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.20.14.39.10;	author swasey;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.20.14.37.01;	author swasey;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.20.14.35.46;	author swasey;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.20.14.34.45;	author swasey;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.20.14.32.15;	author swasey;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.20.14.31.08;	author swasey;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.20.14.29.31;	author swasey;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.20.14.28.02;	author swasey;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.20.14.26.25;	author swasey;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.20.14.24.47;	author swasey;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.20.14.21.21;	author swasey;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.20.14.14.00;	author swasey;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.20.14.12.45;	author swasey;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.20.14.12.21;	author swasey;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.20.14.10.47;	author swasey;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.20.14.10.25;	author swasey;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.20.13.59.42;	author swasey;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.19.17.43.01;	author swasey;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.19.17.37.21;	author swasey;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.19.17.21.31;	author swasey;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.19.17.13.30;	author swasey;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.19.16.07.05;	author swasey;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.19.15.26.37;	author swasey;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.19.14.59.56;	author swasey;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.19.14.47.22;	author swasey;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.19.14.39.01;	author swasey;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.19.13.19.25;	author swasey;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.19.13.01.30;	author swasey;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.19.12.32.46;	author swasey;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.19.10.27.55;	author swasey;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.18.17.04.47;	author swasey;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.18.17.01.03;	author swasey;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.18.16.35.02;	author swasey;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.18.08.38.35;	author swasey;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.18.08.31.23;	author swasey;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.18.08.28.28;	author swasey;	state Exp;
branches;
next	;


desc
@@


1.40
log
@*** empty log message ***
@
text
@(*$import Firstlude TiltPrim Prelude *)

val f	: int * int option -> unit
	= fn (_, x) => (case x
			  of NONE => ()
			   | _ => raise Subscript)

val g	: ('a -> unit) -> 'a -> unit
	= fn x => fn y => x y

val _	: unit
	= g f (0, NONE)	(* raises Subscript *)
@


1.39
log
@*** empty log message ***
@
text
@d11 2
a12 1
val _ = g f (0, NONE)	(* raises Subscript *)
@


1.38
log
@*** empty log message ***
@
text
@d3 4
a6 2
fun writeVec (fd:int,{sz=(NONE : int option)}) = ()
  | writeVec _ = raise Subscript
d8 2
a9 1
fun announce x y : unit = x y
d11 1
a11 1
val _ = announce writeVec (1, {sz=NONE})
@


1.37
log
@*** empty log message ***
@
text
@d3 1
a3 1
fun writeVec (fd:int,{sz=(NONE : int option)}) = 0
d6 1
a6 1
fun announce x y : int = x y
@


1.36
log
@*** empty log message ***
@
text
@d6 1
a6 1
fun announce x y = (x y)
@


1.35
log
@*** empty log message ***
@
text
@d3 1
a3 1
fun writeVec (fd,{sz=NONE}) = 0
@


1.34
log
@*** empty log message ***
@
text
@d4 1
a4 1
  | writeVec (fd,{sz=SOME i}) = raise Subscript
@


1.33
log
@*** empty log message ***
@
text
@d6 1
a6 1
fun announce s x y = (x y)
d8 1
a8 1
val _ = announce "writeVec" writeVec (1, {sz=NONE})
@


1.32
log
@*** empty log message ***
@
text
@d4 1
a4 1
  | writeVec (fd,{sz=SOME i}) = i
@


1.31
log
@*** empty log message ***
@
text
@d4 1
a4 4
  | writeVec (fd,{sz=SOME sz}) =
          if 0 <= sz
              then 1
              else 0
@


1.30
log
@*** empty log message ***
@
text
@d3 2
a4 2
fun writeVec (fd,{i, sz=NONE}) = 0
  | writeVec (fd,{i, sz=SOME sz}) =
d11 1
a11 1
val _ = announce "writeVec" writeVec (1, {i=0, sz=NONE})
@


1.29
log
@*** empty log message ***
@
text
@d5 1
a5 1
          if 0 <= i andalso 0 <= sz
@


1.28
log
@*** empty log message ***
@
text
@d3 1
a3 7
extern posix_io_writebuf : (int, char array, int, int, int) -->

fun writevec' (x : int, z : int) : int = Ccall(posix_io_writebuf,x,TiltPrim.unsafe_vector2array "die\n",4,z)
fun writeVec (fd,{i, sz=NONE}) =
          if 0 <= i
              then writevec'(fd, i)
              else 0
d6 1
a6 1
              then writevec'(fd, i)
@


1.27
log
@*** empty log message ***
@
text
@d9 1
a9 1
              else raise Subscript
d13 1
a13 1
              else raise Subscript
@


1.26
log
@*** empty log message ***
@
text
@d5 2
a6 4
structure POSIX_IO =
struct
    fun writevec' (x : int, z : int) : int = Ccall(posix_io_writebuf,x,TiltPrim.unsafe_vector2array "die\n",4,z)
    fun writeVec (fd,{i, sz=NONE}) =
d10 1
a10 1
      | writeVec (fd,{i, sz=SOME sz}) =
a13 1
  end (* structure POSIX_IO *)
d17 1
a17 1
val _ = announce "writeVec" POSIX_IO.writeVec (1, {i=0, sz=NONE})
@


1.25
log
@*** empty log message ***
@
text
@d7 4
a10 8
    fun char_vector_length (a : char vector) : int = TiltPrim.uint32toint32(TiltPrim.vector_length a)
    fun writearr' (x : int, v : char array, y : int, z : int) : int = Ccall(posix_io_writebuf,x,v,y,z)
    fun writevec' (x : int, v : char vector, y : int, z : int) : int = writearr'(x,TiltPrim.unsafe_vector2array v,y,z)
    fun writeVec (fd,{buf, i, sz=NONE}) = let
          val vlen = char_vector_length buf
          in
            if 0 <= i andalso i <= vlen
              then writevec'(fd, buf, vlen-i, i)
d12 3
a14 6
          end
      | writeVec (fd,{buf, i, sz=SOME sz}) = let
          val vlen = char_vector_length buf
          in
            if 0 <= i andalso 0 <= sz andalso i + sz <= vlen
              then writevec'(fd, buf, sz, i)
a15 1
          end
d20 1
a20 1
val _ = announce "writeVec" POSIX_IO.writeVec (1, {buf="die\n", i=0, sz=NONE})
@


1.24
log
@*** empty log message ***
@
text
@d26 1
a26 3
structure PosixPrimIO =
struct
	fun announce s x y = (x y)
d28 1
a28 4
	fun putV x = announce "writeVec" POSIX_IO.writeVec (1, x)
end;

val _ = PosixPrimIO.putV {buf="die\n", i=0, sz=NONE}
@


1.23
log
@*** empty log message ***
@
text
@d30 1
a30 1
	fun putV fd x = announce "writeVec" POSIX_IO.writeVec (fd, x)
d33 1
a33 1
val _ = PosixPrimIO.putV 1 {buf="die\n", i=0, sz=NONE}
@


1.22
log
@*** empty log message ***
@
text
@d27 2
a28 1
  struct
d30 2
a31 1
    fun announce s x y = (x y)
d33 1
a33 7
    fun mkWriter fd = let
	  fun putV x = announce "writeVec" POSIX_IO.writeVec (fd, x)
	  in  putV
	  end
  end;

val _ = PosixPrimIO.mkWriter 1 {buf="die\n", i=0, sz=NONE}
@


1.21
log
@*** empty log message ***
@
text
@d32 1
a32 3
	  val pos = ref 0
 	  fun incPos k = (pos := !pos + k; k)
	  fun putV x = incPos(announce "writeVec" POSIX_IO.writeVec (fd, x))
@


1.20
log
@*** empty log message ***
@
text
@d26 1
a26 1
functor PosixPrimIO() =
d39 1
a39 11
extern hack_print : (string, unit) -->
val _ = Ccall(hack_print,"die\n")

structure IO = PosixPrimIO()

val pv = IO.mkWriter 1
val text = "die\n"
val textlen = 4
val n = pv {buf=text, i=0, sz=NONE}
val _ = if n = textlen then ()
	else Ccall(hack_print,"writeVec partial\n")
@


1.19
log
@*** empty log message ***
@
text
@a4 7
structure POSIX_FileSys =
  struct
    datatype file_desc = FD of {fd : int}
    fun fdToWord (FD{fd,...}) = TiltPrim.int32touint32 fd
    val stdout = FD{fd=1}
  end

a7 1
    fun fs_intof fd = TiltPrim.uint32toint32(POSIX_FileSys.fdToWord fd)
d14 1
a14 1
              then writevec'(fs_intof fd, buf, vlen-i, i)
d21 1
a21 1
              then writevec'(fs_intof fd, buf, sz, i)
d44 1
a44 1
val pv = IO.mkWriter POSIX_FileSys.stdout
@


1.18
log
@*** empty log message ***
@
text
@d3 1
a3 7514
(* general-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature GENERAL =
  sig

    eqtype unit
    type exn

    exception Bind
    exception Chr
    exception Div
    exception Domain
    exception Fail of string
    exception Match
    exception Overflow
    exception Size
    exception Span
    exception Subscript

    val exnName : exn -> string
    val exnMessage: exn -> string

    datatype order = LESS | EQUAL | GREATER

    val !  : 'a ref -> 'a
    val := : 'a ref * 'a -> unit
    val o  : ('b -> 'c) * ('a -> 'b) -> 'a -> 'c

    val before : 'a * 'b -> 'a
    val ignore : 'a -> unit

  end


extern exnNameRuntime : (exn, string) -->
extern exnMessageRuntime : (exn, string) -->
(* general.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure General :> GENERAL where type unit = unit 
			       and type exn = exn
			       and type order = order =
  struct

    type unit = unit
    type exn = exn

    exception Bind = Bind
    exception Chr = Chr
    exception Div = Div
    exception Domain = Domain
    exception Fail = Fail
    exception Match = Match
    exception Overflow = Overflow
    exception Size = Size
    exception Span = Span
    exception Subscript = Subscript
    
    fun exnName exn = Ccall(exnNameRuntime,exn)
    fun exnMessage exn = Ccall(exnMessageRuntime,exn)

    datatype order = datatype order

    val ! = fn x => !x
    val op := = fn (x,y) => x := y
    val op o = op o
	
    val op before = (op before)
    val ignore = ignore

  end (* structure General *)
(* option-sig.sml
 *
 * COPYRIGHT (c) 1997 AT&T Labs Research.
 *)

signature OPTION =
  sig

    datatype 'a option = NONE | SOME of 'a
    exception Option

    val getOpt         : 'a option * 'a -> 'a
    val isSome         : 'a option -> bool
    val valOf          : 'a option -> 'a
    val filter         : ('a -> bool) -> 'a -> 'a option
    val join           : 'a option option -> 'a option
    val map            : ('a -> 'b) -> 'a option -> 'b option
    val mapPartial     : ('a -> 'b option) -> 'a option -> 'b option
    val compose        : ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option
    val composePartial : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option

  end;

(* option.sml
 *
 * COPYRIGHT (c) 1997 AT&T Labs Research.
 *)

structure Option :> OPTION where type 'a option = 'a option =
  struct

    datatype 'a option = datatype option
    exception Option = Option

    fun getOpt (SOME x, y) = x
      | getOpt (NONE, y) = y
    fun isSome (SOME _) = true
      | isSome NONE = false
    fun valOf (SOME x) = x
      | valOf _ = raise Option

    fun filter pred x = if (pred x) then SOME x else NONE
    fun join (SOME opt) = opt
      | join NONE = NONE
    fun map f (SOME x) = SOME(f x)
      | map f NONE = NONE
    fun mapPartial f (SOME x) = f x
      | mapPartial f NONE = NONE
    fun compose (f, g) x = map f (g x)
    fun composePartial (f, g) x = mapPartial f (g x)

  end;

(* pre-string.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Some common operations that are used by both the String and
 * Substring structures.
 *
 *)

structure PreString =
  struct

    val int32touint32 = TiltPrim.int32touint32
    val int32touint8 = TiltPrim.int32touint8
    val uint32toint32 = TiltPrim.uint32toint32
    val uint8touint32 = TiltPrim.uint8touint32

    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult

    val uminus = TiltPrim.uminus
    val uplus = TiltPrim.uplus

    val unsafe_vsub = TiltPrim.unsafe_vsub
    val vector_length = TiltPrim.vector_length
    val unsafe_sub = TiltPrim.unsafe_sub
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_array = TiltPrim.unsafe_array

    val unsafe_array2vector = TiltPrim.unsafe_array2vector
	
    local
(*
      structure C = InlineT.Char

      val op + = InlineT.DfltInt.+
      val op - = InlineT.DfltInt.-
      val op * = InlineT.DfltInt.*
      val op quot = InlineT.DfltInt.quot
      val op < = InlineT.DfltInt.<
      val op <= = InlineT.DfltInt.<=
      val op > = InlineT.DfltInt.>
      val op >= = InlineT.DfltInt.>=
      val op = = InlineT.=
      val unsafeSub = InlineT.CharVector.sub
      val unsafeUpdate = InlineT.CharVector.update
      val unsafeCreate = Assembly.A.create_s
      val maxSize = Core.max_length
      val size = InlineT.CharVector.length
*)
	val unsafeSub = unsafe_sub
	val unsafeUpdate = unsafe_update
	fun unsafeCreate (sz : int) : char array = unsafe_array(int32touint32 sz,#"\000")
	val maxOrd = 255
    in

    datatype substring = SS of (string * int * int)

  (* allocate an uninitialized string of given length (with a size check) *)
    fun create n = if n > 0 then unsafeCreate n else raise Size
(*
 if (InlineT.DfltInt.ltu(maxSize, n))
		       then raise General.Size
		   else unsafeCreate n
*)

  (* a vector of single character strings *)
    val chars : string vector =
	let
	    val a = unsafe_array (int32touint32 (maxOrd+1),"")
	    fun next i = if (i <= maxOrd)
			     then let val s = unsafeCreate 1
				      val _ = unsafeUpdate(s, 0w0, int32touint8 i)
				      val _ = unsafeUpdate(a, int32touint32 i, unsafe_array2vector s)
				  in  next(i+1)
				  end
			 else unsafe_array2vector a
	in  next 0
	end

    fun unsafeSubstring (_, _, 0w0) = ""
      | unsafeSubstring (s : string, i, 0w1) = unsafe_vsub (chars, uint8touint32 (unsafe_vsub (s, i)))
      | unsafeSubstring (s, i, n) = 
	let
	    val ss = unsafeCreate (uint32toint32 n)
	    fun copy j = if (j = n)
			     then unsafe_array2vector ss
			 else (unsafeUpdate(ss, j, unsafe_vsub(s, uplus(i,j))); copy(uplus(j,0w1)))
	in  copy 0w0
	end

    fun size (x : string) : int = TiltPrim.uint32toint32(TiltPrim.vector_length x)
	
  (* concatenate a pair of non-empty strings *)
    fun concat2 (x, y) = 
	let
	    val xl = size x 
	    val yl = size y
	    val ss = create(xl+yl)
	    val xl = int32touint32 xl
	    val yl = int32touint32 yl
	    fun copyx n = if (n = xl)
			      then ()
			  else (unsafeUpdate(ss, n, unsafe_vsub(x, n)); copyx(uplus(n,0w1)))
	    fun copyy n = if (n = yl)
			      then ()
			  else (unsafeUpdate(ss, uplus(xl,n), unsafe_vsub(y,n)); copyy(uplus(n,0w1)))
	in
	    copyx 0w0; copyy 0w0;
	    unsafe_array2vector ss
	end

  (* given a reverse order list of strings and a total length, return
   * the concatenation of the list.
   *)
    fun revConcat (0, _) = ""
      | revConcat (1, lst : string list) = let
	  fun find ("" :: r) = find r
	    | find (s :: _) = s
	    | find _ = "" (** impossible **)
	  in
	    find lst
	  end
      | revConcat (totLen : int, lst : string list) = 
	  let val ss = create totLen
	      fun copy ([], _) = ()
		| copy (s::r, i) = 
		  let
		      val len = vector_length s
		      val i = uminus(i,len)
		      fun copy' j = if (j = len)
					then ()
				    else (
					  unsafeUpdate(ss, uplus(i,j), unsafe_vsub(s, j));
					  copy'(uplus(j,0w1)))
		  in
		      copy' 0w0;
		      copy (r, i)
		  end
	  in  copy (lst, int32touint32 totLen);  
	      unsafe_array2vector ss
	  end

  (* map a translation function across the characters of a substring *)
    fun translate (tr, s, i, n) = let
	  val stop = uplus(i,n)
	  fun mkList (j, totLen, lst) = if ult(j,stop)
		then let val s' = tr (unsafe_vsub (s, j))
		  in
		    mkList (uplus(j,0w1), totLen + size s', s' :: lst)
		  end
		else revConcat (totLen, lst)
	  in
	    mkList (i, 0, [])
	  end

  (* implode a non-empty list of characters into a string where both the
   * length and list are given as arguments.
   *)
    fun implode (len, cl) = 
	let
	    val ss = create len
	    fun copy ([], _) = unsafe_array2vector ss
	      | copy (c::r, i) = (unsafe_update(ss, i, c); copy(r, uplus(i,0w1)))
	in  copy (cl, 0w0)
	end

  (* implode a reversed non-empty list of characters into a string where both the
   * length and list are given as arguments.
   *)
    fun revImplode (len, cl) = let
	  val ss = create len
	  fun copy ([], _) = unsafe_array2vector ss
	    | copy (c::r, i) = (unsafe_update(ss, i, c); copy(r, uminus(i,0w1)))
	  in  copy (cl, int32touint32(len-1))
	  end

    fun isPrefix (s1, s2, i2, n2) = let
	  val n1 = vector_length s1
	  fun eq (i, j) =
		(ugte(i,n1))
		orelse ((unsafe_vsub(s1, i) = unsafe_vsub(s2, j)) andalso eq(uplus(i,0w1), uplus(j,0w1)))
	  in
	      ugte(n2,n1) andalso eq (0w0, i2)
	  end

    fun collate cmpFn (s1 : string, i1, n1, s2 : string, i2, n2) = let
	  val (n, order) =
		if (n1 = n2) then (n1, EQUAL)
		else if (n1 < n2) then (n1, LESS)
		else (n2, GREATER)
	  val n = int32touint32 n
	  fun cmp' i = if (i = n)
		then order
		else let
		  val c1 = unsafe_vsub(s1, uplus(i1,i))
		  val c2 = unsafe_vsub(s2, uplus(i2,i))
		  in
		    case (cmpFn(c1, c2)) 
		     of EQUAL => cmp' (uplus(i,0w1))
		      | order => order
		    (* end case *)
		  end
	  in  cmp' 0w0
	  end

    fun cmp (s1, i1, n1, s2, i2, n2) = let
	  fun cmpFn (c1, c2) =
		if (c1 = c2) then EQUAL
		else if ((c1 > c2)) then GREATER
		else LESS
	  in
	    collate cmpFn (s1, i1, n1, s2, i2, n2)
	  end

    end (* local *)

    (* getNChars : (char, 'a) reader -> ('a * int) -> (char list * 'a) option *)
    fun getNChars (getc : 'a -> (char * 'a) option) (cs, n) = let
          fun rev ([], l2) = l2
            | rev (x::l1, l2) = rev(l1, x::l2)
          fun get (cs, 0, l) = SOME(rev(l, []), cs)
            | get (cs, i, l) = (case getc cs
                 of NONE => NONE
                  | (SOME(c, cs')) => get (cs', i-1, c::l)
                (* end case *))
          in
            get (cs, n, [])
          end

  end; (* PreString *)


signature STRING_CVT =
  sig

    datatype radix = BIN | OCT | DEC | HEX

    datatype realfmt
      = SCI of int option
      | FIX of int option
      | GEN of int option
      | EXACT

    type ('a, 'b) reader = 'b -> ('a * 'b) option

    val padLeft  : char -> int -> string -> string
    val padRight : char -> int -> string -> string

    val splitl : (char -> bool) -> (char, 'a) reader -> 'a -> string * 'a
    val takel  : (char -> bool) -> (char, 'a) reader -> 'a -> string
    val dropl  : (char -> bool) -> (char, 'a) reader -> 'a -> 'a
    val skipWS : (char, 'a) reader -> 'a -> 'a

    type cs
    val scanString : ((char, cs) reader -> ('a, cs) reader) -> string -> 'a option

  end


(* string-cvt.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure StringCvt :> STRING_CVT =
  struct
      
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32

    val unsafe_array = TiltPrim.unsafe_array
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_vsub = TiltPrim.unsafe_vsub
    val vector_length = TiltPrim.vector_length

    val unsafe_array2vector = TiltPrim.unsafe_array2vector

  (* get radix and realfmt types from type-only structure *)

    datatype radix = BIN | OCT | DEC | HEX
    datatype realfmt
      = EXACT
      | SCI of int option
      | FIX of int option
      | GEN of int option
    type ('a, 'b) reader = 'b -> ('a * 'b) option

    local
      fun fillStr (c, s, i, n) = let
	    val stop = i+n
	    fun fill j = if (j < stop)
		  then (unsafe_update(s, int32touint32 j, c); 
			fill(j+1))
		  else ()
	    in
	      fill i
	    end
      fun cpyStr (src : string, srcLen, dst : char array, start) = let
	    fun cpy (i, j) = if (i < srcLen)
		  then (unsafe_update(dst, int32touint32 j, unsafe_vsub(src, int32touint32 i));
			cpy (i+1, j+1))
		  else ()
	    in
	      cpy (0, start)
	    end
    in
	fun padLeft padChr wid s = 
	    let
		val len = PreString.size s
		val pad = wid - len
	    in
		if (pad > 0)
		    then let
			     val s' = unsafe_array(int32touint32 wid,#"\000")
			 in
			     fillStr (padChr, s', 0, pad);
			     cpyStr (s, len, s', pad);
			     unsafe_array2vector s'
			 end
		else s
	    end
	fun padRight padChr wid s = 
	    let
		val len = PreString.size s
		val pad = wid - len
	    in
		if (pad > 0)
		    then let
			     val s' = unsafe_array(int32touint32 wid,#"\000")
			 in
			     fillStr (padChr, s', len, pad);
			     cpyStr (s, len, s', 0);
			     unsafe_array2vector s'
			 end
		else s
	    end
    end (* local *)


    fun splitl pred getc rep = let
	  fun lp (n, chars, rep) = (case (getc rep)
		 of NONE => (PreString.revImplode(n, chars), rep)
		  | SOME(c, rep) => if (pred c)
		      then lp(n+1, c::chars, rep)
		      else (PreString.revImplode(n, chars), rep)
		(* end case *))
	  in
	    lp (0, [], rep)
	  end
    fun takel pred getc rep = let
	  fun lp (n, chars, rep) = (case (getc rep)
		 of NONE => PreString.revImplode(n, chars)
		  | SOME(c, rep) => if (pred c)
		      then lp(n+1, c::chars, rep)
		      else PreString.revImplode(n, chars)
		(* end case *))
	  in
	    lp (0, [], rep)
	  end
    fun dropl pred getc = let
	  fun lp rep = (case (getc rep)
		 of NONE => rep
		  | SOME(c, rep') => if (pred c) then lp rep' else rep
		(* end case *))
	  in
	    lp
	  end

    fun skipWS (getc : 'a -> (char * 'a) option) = let
          fun isWS (#" ") = true
            | isWS (#"\t") = true
            | isWS (#"\n") = true
            | isWS _ = false
          fun lp cs = (case (getc cs)
                 of (SOME(c, cs')) => if (isWS c) then lp cs' else cs
                  | NONE => cs
                (* end case *))
          in
            lp
          end

  (* the cs type is the type used by scanString to represent a stream of
   * characters; we use the current index in the string being scanned.
   *)
    type cs = int
     fun scanString (scanFn : (char, cs) reader -> ('a, cs) reader) s =
	 let
	     val n = uint32toint32(vector_length s)
	     fun getc i = 
		 if (i < n) then SOME(unsafe_vsub(s, int32touint32 i), i+1) else NONE
	 in
	     case (scanFn getc 0) of
		 NONE => NONE
	       | SOME(x, _) => SOME x
	 end
  end

(* bool-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature BOOL =
  sig

    datatype bool = false | true
    val not : bool -> bool

    val fromString : string -> bool option
    val scan : (char, 'a) StringCvt.reader -> (bool, 'a) StringCvt.reader
    val toString   : bool -> string

  end

(* bool.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *)

structure Bool :> BOOL where type bool = bool =
  struct

    datatype bool = datatype bool

    val not = not

  (* NOTE: this should probably accept a wider range of arguments, but the
   * spec hasn't been written yet.
   *)
    fun scan (getc : (char, 'a) StringCvt.reader) cs = (
	  case (getc (StringCvt.skipWS getc cs))
	   of (SOME(#"t", cs')) => (case (PreString.getNChars getc (cs', 3))
		 of (SOME([#"r", #"u", #"e"], cs'')) => SOME(true, cs'')
		  | _ => NONE
		(* end case *))
	    | (SOME(#"f", cs')) => (case (PreString.getNChars getc (cs', 4))
		 of (SOME([#"a", #"l", #"s", #"e"], cs'')) => SOME(false, cs'')
		  | _ => NONE
		(* end case *))
	    | _ => NONE
	  (* end case *))

    fun toString true = "true"
      | toString false = "false"
    val fromString = StringCvt.scanString scan

  end

(* list-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *)

signature LIST =
  sig

    datatype 'a list = nil | :: of 'a * 'a list

    exception Empty

    val null : 'a list -> bool 
    val length : 'a list -> int 
    val @@    : 'a list * 'a list -> 'a list
    val hd   : 'a list -> 'a                (* raises Empty *)
    val tl   : 'a list -> 'a list           (* raises Empty *)
    val last : 'a list -> 'a                (* raises Empty *)

    val getItem : 'a list -> ('a * 'a list) option

    val nth  : 'a list * int -> 'a       (* raises Subscript *)
    val take : 'a list * int -> 'a list  (* raises Subscript *)
    val drop : 'a list * int -> 'a list  (* raises Subscript *)

    val rev : 'a list -> 'a list 

    val concat    : 'a list list -> 'a list
    val revAppend : 'a list * 'a list -> 'a list

    val app        : ('a -> unit) -> 'a list -> unit
    val map        : ('a -> 'b) -> 'a list -> 'b list
    val mapPartial : ('a -> 'b option) -> 'a list -> 'b list

    val find      : ('a -> bool) -> 'a list -> 'a option
    val filter    : ('a -> bool) -> 'a list -> 'a list
    val partition : ('a -> bool) -> 'a list -> ('a list * 'a list)

    val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
    val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b

    val exists : ('a -> bool) -> 'a list -> bool
    val all    : ('a -> bool) -> 'a list -> bool

    val tabulate : int * (int -> 'a) -> 'a list   (* raises Size *)

  end (* signature LIST *)

(* list.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure List :> LIST where type 'a list = 'a list =
  struct

(*
    val op +  = InlineT.DfltInt.+
    val op -  = InlineT.DfltInt.-
    val op <  = InlineT.DfltInt.<
    val op <= = InlineT.DfltInt.<=
    val op >  = InlineT.DfltInt.>
    val op >= = InlineT.DfltInt.>=
    val op =  = InlineT.=
*)
    datatype list = datatype list

    exception Empty = Empty

    fun null [] = true | null _ = false

    fun hd (h::_) = h | hd _ = raise Empty
    fun tl (_::t) = t | tl _ = raise Empty
    fun last [] = raise Empty
      | last [x] = x
      | last (_::r) = last r

    fun getItem [] = NONE
      | getItem (x::r) = SOME(x, r)

    fun nth (l,n) = let
          fun loop ((e::_),0) = e
            | loop ([],_) = raise Subscript
            | loop ((_::t),n) = loop(t,n-1)
          in
            if n >= 0 then loop (l,n) else raise Subscript
          end

    fun take (l, n) = let
          fun loop (l, 0) = []
            | loop ([], _) = raise Subscript
            | loop ((x::t), n) = x :: loop (t, n-1)
          in
            if n >= 0 then loop (l, n) else raise Subscript
          end

    fun drop (l, n) = let
          fun loop (l,0) = l
            | loop ([],_) = raise Subscript
            | loop ((_::t),n) = loop(t,n-1)
          in
            if n >= 0 then loop (l,n) else raise Subscript
          end

    fun length l = let 
          fun loop(acc,[]) = acc
            | loop(acc, _::x) = loop(acc+1,x)
          in loop(0,l) end

(*
    fun rev l = let 
          fun loop ([], acc) = acc
            | loop (a::r, acc) = loop(r, a::acc)
          in
	    loop (l, [])
	  end
*)
    val rev = rev
	
    fun op @@(x,[]) = x
      | op @@(x,l) = let 
          fun f([],l) = l
            | f([a],l) = a::l
            | f([a,b],l) = a::b::l
            | f([a,b,c],l) = a::b::c::l
            | f(a::b::c::d::r,l) = a::b::c::d::f(r,l)
          in f(x,l) end

    fun concat [] = []
      | concat (l::r) = l @@ concat r

    fun revAppend ([],l) = l
      | revAppend (h::t,l) = revAppend(t,h::l)

    fun app f = let 
          fun a2 (e::r) = (f e; a2 r) | a2 [] = () 
          in a2 end

    fun map f = let 
          fun m [] = []
            | m [a] = [f a]
            | m [a,b] = [f a, f b]
            | m [a,b,c] = [f a, f b, f c]
            | m (a::b::c::d::r) = f a :: f b :: f c :: f d :: m r
          in m end

    fun mapPartial pred l = let
          fun mapp ([], l) = rev l
            | mapp (x::r, l) = (case (pred x)
                 of SOME y => mapp(r, y::l)
                  | NONE => mapp(r, l)
                (* end case *))
          in
            mapp (l, [])
          end

    fun find pred [] = NONE
      | find pred (a::rest) = if pred a then SOME a else (find pred rest)

    fun filter pred [] = []
      | filter pred (a::rest) = if pred a then a::(filter pred rest) 
                                else (filter pred rest)

    fun partition pred l = let
          fun loop ([],trueList,falseList) = (rev trueList, rev falseList)
            | loop (h::t,trueList,falseList) = 
                if pred h then loop(t, h::trueList, falseList)
                else loop(t, trueList, h::falseList)
          in loop (l,[],[]) end

    fun foldr f b = let
          fun f2 [] = b
            | f2 (a::t) = f(a,f2 t)
          in f2 end

    fun foldl f b l = let
          fun f2 ([],b) = b
            | f2 (a::r,b) = f2(r,f(a,b))
          in f2 (l,b) end

    fun exists pred = let 
          fun f [] = false
            | f (h::t) = pred h orelse f t
          in f end
    fun all pred = let 
          fun f [] = true
            | f (h::t) = pred h andalso f t
          in f end

    fun tabulate (len, genfn) = 
          if len < 0 then raise Size
          else let
            fun loop n = if n = len then []
                         else (genfn n)::(loop(n+1))
            in loop 0 end

  end (* structure List *)

(* num-format.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * The word to string conversion for the largest word and int types.
 * All of the other fmt functions can be implemented in terms of them.
 *
 *)

structure NumFormat : sig

    val fmtWord : StringCvt.radix -> word -> string
    val fmtInt  : StringCvt.radix -> int -> string

  end = struct

    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32

    val && = TiltPrim.&&
    val >> = TiltPrim.>>

    val udiv = TiltPrim.udiv
    val umult = TiltPrim.umult
    val uminus = TiltPrim.uminus

    val ult = TiltPrim.ult

    val unsafe_vsub = TiltPrim.unsafe_vsub
(*
    structure W = InlineT.Word32
    structure I = InlineT.Int31
    structure I32 = InlineT.Int32

    val op < = W.<
    val op - = W.-
    val op * = W.*
    val op div = W.div
*)

    val plus = (op +) : int * int -> int
    val less = (op <) : int * int -> bool
    val negate = ~ : int -> int

    val op < = ult
    val op - = uminus
    val op * = umult
    val op div = udiv
    val w2i = uint32toint32
    val i2w = int32touint32


    fun mkDigit (w : word) = unsafe_vsub("0123456789abcdef", w)

    fun wordToBin w = let
	  fun mkBit w = if (&&(w, 0w1) = 0w0) then #"0" else #"1"
	  fun f (0w0, n, l) = (plus(n : int, 1), #"0" :: l)
	    | f (0w1, n, l) = (plus(n : int, 1), #"1" :: l)
	    | f (w, n, l) = f(>>(w, 1), plus(n, 1), (mkBit w) :: l)
	  in
	    f (w, 0, [])
	  end
    fun wordToOct w = let
	  fun f (w, n, l) = if (w < 0w8)
		then (plus(n, 1), (mkDigit w) :: l)
		else f(>>(w, 3), plus(n : int, 1), mkDigit(&&(w, 0wx7)) :: l)
	  in
	    f (w, 0, [])
	  end
    fun wordToDec w = let
	  fun f (w, n, l) = if (w < 0w10)
		then (plus(n, 1), (mkDigit w) :: l)
		else let val j = w div 0w10
		  in
		    f (j,  plus(n, 1), mkDigit(w - 0w10*j) :: l)
		  end
	  in
	    f (w, 0, [])
	  end
    fun wordToHex w = let
	  fun f (w, n, l) = if (w < 0w16)
		then (plus(n, 1), (mkDigit w) :: l)
		else f(>>(w, 4), plus(n, 1), mkDigit(&&(w, 0wxf)) :: l)
	  in
	    f (w, 0, [])
	  end

    fun fmtW StringCvt.BIN = wordToBin
      | fmtW StringCvt.OCT = wordToOct
      | fmtW StringCvt.DEC = wordToDec
      | fmtW StringCvt.HEX = wordToHex

    fun fmtWord radix = PreString.implode o (fmtW radix)

    fun fmtInt radix i = 
      if i2w i = 0wx80000000 then "~2147483648"
      else let
	  val w32 = i2w(if less(i, 0) then negate(i) else i)
          val (n, digits) = fmtW radix w32
	in
	  if less(i, 0) then PreString.implode(plus(n,1), #"~"::digits)
	  else PreString.implode(n, digits)
	end
  end;

(* char-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature CHAR =
  sig

    eqtype char
    eqtype string

    val minChar : char
    val maxChar : char
    val maxOrd  : int

    val ord : char -> int
    val chr : int -> char

    val succ : char -> char
    val pred : char -> char

    val <  : char * char -> bool
    val <= : char * char -> bool
    val >  : char * char -> bool
    val >= : char * char -> bool

    val compare : char * char -> order

    val contains : string -> char -> bool
    val notContains : string -> char -> bool
	
    val toLower : char -> char
    val toUpper : char -> char

    val isAlpha    : char -> bool   (* isUpper orelse isLower *)
    val isAlphaNum : char -> bool   (* isAlpha orelse isDigit *)
    val isAscii    : char -> bool   (* ord c < 128 *)
    val isCntrl    : char -> bool
    val isDigit    : char -> bool   (* contains "0123456789" *)
    val isGraph    : char -> bool   (* (not isSpace) andalso isPrint *)
    val isHexDigit : char -> bool   (* isDigit orelse contains "abcdefABCDEF" *)
    val isLower    : char -> bool   (* contains "abcdefghijklmnopqrstuvwxyz" *)
    val isPrint    : char -> bool   (* any printable character (incl. #" ") *)
    val isSpace    : char -> bool   (* contains " \t\r\n\v\f" *)
    val isPunct    : char -> bool
    val isUpper    : char -> bool   (* contains "ABCDEFGHIJKLMNOPQRSTUVWXYZ" *)

    val fromString  : string -> char option
    val scan : (char, 'a) StringCvt.reader -> (char, 'a) StringCvt.reader
    val toString    : char -> string
    val fromCString : string -> char option
    val toCString   : char -> string

  end; (* CHAR *)

(* char.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure Char :> CHAR where type char = char
                         and type string = string = 
  struct

    val int32touint32 = TiltPrim.int32touint32
    val && = TiltPrim.&&
    val uplus = TiltPrim.uplus
    val ult = TiltPrim.ult
    val unsafe_sub = TiltPrim.unsafe_sub
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_vsub = TiltPrim.unsafe_vsub
    val unsafe_array = TiltPrim.unsafe_array
;(*
    structure C = InlineT.Char

    val op + = InlineT.DfltInt.+
    val op - = InlineT.DfltInt.-
    val op * = InlineT.DfltInt.*

    val itoc : int -> char = InlineT.cast
    val ctoi : char -> int = InlineT.cast
*)
    val itoc = TiltPrim.int32touint8
    val ctoi = ord

    type char = char
    type string = string

    val minChar : char	= itoc 0
    val maxOrd		= 255
    val maxChar	: char	= itoc maxOrd

    fun chr (i : int) : char = if 0 <= i andalso i <= maxOrd then itoc i
			       else raise General.Chr
    val ord = ord

    fun pred (c : char) : char = let
	  val c' = (ctoi c - 1)
	  in
	    if (c' < 0) then raise General.Chr else (itoc c')
	  end
    fun succ (c : char) : char = let
	  val c' = (ctoi c + 1)
	  in
	    if (maxOrd < c') then raise General.Chr else (itoc c')
	  end


    val (op <)  = (op <  : char * char -> bool)
    val (op <=) = (op <= : char * char -> bool)
    val (op >)  = (op >  : char * char -> bool)
    val (op >=) = (op >= : char * char -> bool)


    fun compare (c1 : char, c2 : char) =
	if (c1 = c2) then EQUAL
	else if (c1 < c2) then LESS
	     else GREATER

  (* testing character membership *)
    local
      fun ord' c = int32touint32(ord c)
      fun mkArray (s, sLen) = 
	  let
	      val sLen = int32touint32 sLen
	      val ca = unsafe_array (int32touint32 (maxOrd+1),#"\000")
	      fun ins i = if ult(i,sLen)
			      then (unsafe_update (ca, ord'(unsafe_vsub(s, i)), #"\001");
				    ins(uplus(i,0w1)))
			  else ()
	      val _ = ins 0w0
	  in  ca
	  end
    in
	fun contains "" = (fn c => false)
	  | contains s = 
	    let val sLen = PreString.size s
	    in
		if (sLen = 1)
		    then let val c' = unsafe_vsub(s, 0w0)
			 in fn c => (c = c') end
		else let val cv = mkArray (s, sLen)
		     in fn c => (unsafe_sub(cv, ord' c) <> #"\000") 
		     end
	    end
	fun notContains "" = (fn c => true)
	  | notContains s = 
	    let val sLen = PreString.size s
	    in
		if (sLen = 1)
		    then let val c' = unsafe_vsub(s,0w0)
			 in fn c => (c <> c') end
		else let val cv = mkArray (s, sLen)
		     in fn c => (unsafe_sub(cv, ord' c) = #"\000") 
		     end
	    end
    end (* local *)

  (* For each character code we have an 8-bit vector, which is interpreted
   * as follows:
   *   0x01  ==  set for upper-case letters
   *   0x02  ==  set for lower-case letters
   *   0x04  ==  set for digits
   *   0x08  ==  set for white space characters
   *   0x10  ==  set for punctuation characters
   *   0x20  ==  set for control characters
   *   0x40  ==  set for hexadecimal characters
   *   0x80  ==  set for SPACE
   *)
    val ctypeTbl = "\
	    \\032\032\032\032\032\032\032\032\032\040\040\040\040\040\032\032\
	    \\032\032\032\032\032\032\032\032\032\032\032\032\032\032\032\032\
	    \\136\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\
	    \\068\068\068\068\068\068\068\068\068\068\016\016\016\016\016\016\
	    \\016\065\065\065\065\065\065\001\001\001\001\001\001\001\001\001\
	    \\001\001\001\001\001\001\001\001\001\001\001\016\016\016\016\016\
	    \\016\066\066\066\066\066\066\002\002\002\002\002\002\002\002\002\
	    \\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\032\
	    \\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
	    \\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
	    \\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
	    \\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
	    \\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
	    \\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
	    \\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
	    \\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
	  \"
    fun inSet (c : char, s : word) = let
	  val m = int32touint32(ord(unsafe_vsub(ctypeTbl, int32touint32 (ord c))))
	  in  &&(m, s) <> 0w0
	  end

  (* predicates on integer coding of Ascii values *)
    fun isAlpha c	= inSet(c, 0wx03)
    fun isUpper c	= inSet(c, 0wx01)
    fun isLower c	= inSet(c, 0wx02)
    fun isDigit c	= inSet(c, 0wx04)
    fun isHexDigit c	= inSet(c, 0wx40)
    fun isAlphaNum c	= inSet(c, 0wx07)
    fun isSpace c	= inSet(c, 0wx08)
    fun isPunct c	= inSet(c, 0wx10)
    fun isGraph c	= inSet(c, 0wx17)
    fun isPrint c	= inSet(c, 0wx97)
    fun isCntrl c	= inSet(c, 0wx20)
    fun isAscii c    	= c < chr 128

    val offset = ctoi #"a" - ctoi #"A"
    fun toUpper c = if (isLower c) then itoc(ctoi c - offset) else c
    fun toLower c = if (isUpper c) then itoc(ctoi c + offset) else c

  (* conversions between characters and printable representations *)
    fun scan getc rep = let
	  fun get2 rep = (case (getc rep)
		 of (SOME(c1, rep')) => (case (getc rep')
		       of (SOME(c2, rep'')) => SOME(c1, c2, rep'')
			| _ => NONE
		      (* end case *))
		  | _ => NONE
		(* end case *))
	  in
	    case (getc rep)
	     of NONE => NONE
	      | (SOME(#"\\", rep')) => (case (getc rep')
		   of NONE => NONE
		    | (SOME(#"\\", rep'')) => (SOME(#"\\", rep''))
		    | (SOME(#"\"", rep'')) => (SOME(#"\"", rep''))
		    | (SOME(#"n", rep'')) => (SOME(#"\n", rep''))
		    | (SOME(#"t", rep'')) => (SOME(#"\t", rep''))
		    | (SOME(#"^", rep'')) => (case (getc rep'')
			 of NONE => NONE
	    		  | (SOME(c, rep''')) =>
			      if ((#"@@" <= c) andalso (c <= #"_"))
			        then SOME(chr(ord c - ord #"@@"), rep''')
			        else NONE
			(* end case *))
		    | (SOME(d1, rep'')) => if (isDigit d1)
			then (case (get2 rep'')
			   of SOME(d2, d3, rep''') => let
				fun cvt d = (ord d - ord #"0")
				in
				  if (isDigit d2 andalso isDigit d3)
				    then SOME(
				      chr(100*(cvt d1)+10*(cvt d2)+(cvt d3)),
				      rep''')
				    else NONE
			        end
			    | NONE => NONE
			  (* end case *))
			else NONE
		  (* end case *))
	      | (SOME(#"\"", rep')) => NONE	(* " *)
	      | (SOME(c, rep')) => if (isPrint c) then (SOME(c, rep')) else NONE
	    (* end case *)
	  end  

    val fromString = StringCvt.scanString scan

    val itoa = (NumFormat.fmtInt StringCvt.DEC) (* o Int.fromInt *)

    fun toString #"\a" = "\\a"
      | toString #"\b" = "\\b"
      | toString #"\t" = "\\t"
      | toString #"\n" = "\\n"
      | toString #"\v" = "\\v"
      | toString #"\f" = "\\f"
      | toString #"\r" = "\\r"
      | toString #"\"" = "\\\""
      | toString #"\\" = "\\\\"
      | toString c =
	  if (isPrint c)
	    then unsafe_vsub (PreString.chars, int32touint32(ord c))
(** NOTE: we should probably recognize the control characters **)
	    else let
	      val c' = ord c
	      in
		if (c > chr 32)
		  then PreString.concat2("\\", itoa c')
		  else PreString.concat2("\\^",
		    unsafe_vsub (PreString.chars, int32touint32(c'+64)))
	      end

    fun fromCString s = raise TiltExn.LibFail "Char.fromCString not implemented"

    fun toCString #"\a" = "\\a"
      | toCString #"\b" = "\\b"
      | toCString #"\t" = "\\t"
      | toCString #"\n" = "\\n"
      | toCString #"\v" = "\\v"
      | toCString #"\f" = "\\f"
      | toCString #"\r" = "\\r"
      | toCString #"\"" = "\\\""
      | toCString #"\\" = "\\\\"
      | toCString #"?" = "\\?"
      | toCString #"'" = "\\'"
      | toCString c = if (isPrint c)
	  then unsafe_vsub (PreString.chars, int32touint32(ord c))
	  else PreString.concat2("\\", itoa (ord c))


  end (* Char *)
(* string-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature STRING =
  sig
    eqtype string
    structure Char : CHAR
	(* sharing type string = Char.string -- Holds for TILT but not part of this signature *)

    val maxSize : int

    val size      : string -> int
    val sub       : string * int -> Char.char
    val extract   : string * int * int option -> string
    val substring : string * int * int -> string
    val concat    : string list -> string
    val ^         : string * string -> string
    val str       : Char.char -> string
    val implode   : Char.char list -> string
    val explode   : string -> Char.char list

    val map       : (Char.char -> Char.char) -> string -> string
    val translate : (Char.char -> string) -> string -> string
    val tokens    : (Char.char -> bool) -> string -> string list
    val fields    : (Char.char -> bool) -> string -> string list

    val isPrefix : string -> string -> bool
    val compare  : string * string -> order
    val collate  : (Char.char * Char.char -> order) -> string * string -> order

    val <  : string * string -> bool
    val <= : string * string -> bool
    val >  : string * string -> bool
    val >= : string * string -> bool

    val fromString  : string -> string option
    val toString    : string -> string
    val fromCString : string -> string option
    val toCString   : string -> string

  end

(* string.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure String :> STRING where type string = string
			     and type Char.char = char
			     and type Char.string = string =
  struct
      
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
    val uint8touint32 = TiltPrim.uint8touint32
	
    val unsafe_array = TiltPrim.unsafe_array
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_vsub = TiltPrim.unsafe_vsub
    val vector_length = TiltPrim.vector_length
	
    val unsafe_array2vector = TiltPrim.unsafe_array2vector
	
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
	
    val uplus = TiltPrim.uplus

(*
    val op + = InlineT.DfltInt.+
    val op - = InlineT.DfltInt.-
    val op < = InlineT.DfltInt.<
    val op <= = InlineT.DfltInt.<=
    val op > = InlineT.DfltInt.>
    val op >= = InlineT.DfltInt.>=
    val op = = InlineT.=
    val unsafeSub = InlineT.CharVector.sub
    val unsafeUpdate = InlineT.CharVector.update
*)

    type string = string
    structure Char = Char

    val maxSize = 1024 * 1024

  (* the length of a string *)
    val i2w = int32touint32
    val w2i = uint32toint32
    fun size(x : string) : int = uint32toint32(vector_length x)


  (* allocate an uninitialized string of given length *)
	fun create sz : char array = if (sz>0)
					 then unsafe_array(i2w sz,#"\000")
				     else raise Size


  (* convert a character into a single character string *)
    fun str (c : Char.char) : string =
	  unsafe_vsub(PreString.chars, uint8touint32 c)

  (* get a character from a string *)
    fun sub(x : string, i : int) = 
	let val index = int32touint32 i
	in  if (ugte(index, vector_length x))
		then raise Subscript
	    else unsafe_vsub(x,index)
	end

    fun substring (s, i, n) =
	  if ((i < 0) orelse (n < 0) orelse (size s < i+n))
	    then raise General.Subscript
	    else PreString.unsafeSubstring (s, i2w i, i2w n)

    fun extract (v : string, base, optLen) = let
	  val len = size v
	  val base' = i2w base
	  fun newVec n = let
		val newV : char array = create n
		val n = i2w n
		fun fill (i : word) = if ult(i,n)
		      then let val temp : word = uplus(base',i)
			       val c : char = unsafe_vsub(v,temp)
			       val i' : word = uplus(i,0w1)
			  in  (unsafe_update(newV, i, c);
			       fill i')
			   end
		      else ()
		in  fill 0w0; unsafe_array2vector newV
		end
	  in
	    case (base, optLen)
	     of (0, NONE) => v
	      | (_, SOME 0) => if ((base < 0) orelse (len < base))
		    then raise General.Subscript
		    else ""
	      | (_, NONE) => if ((base < 0) orelse (len < base))
		      then raise General.Subscript
		    else if (base = len)
		      then ""
		      else newVec (len - base)
	      | (_, SOME 1) =>
		  if ((base < 0) orelse (len < base+1))
		    then raise General.Subscript
		    else str(unsafe_vsub(v, i2w base))
	      | (_, SOME n) =>
		  if ((base < 0) orelse (n < 0) orelse (len < (base+n)))
		    then raise General.Subscript
		    else newVec n
	    (* end case *)
	  end

    fun op ^ ("", s) = s
      | op ^ (s, "") = s
      | op ^ (x, y) = PreString.concat2 (x, y)

  (* concatenate a list of strings together *)
    fun concat [s] = s
      | concat (sl : string list) = let
	fun length (i, []) = i
	  | length (i, s::rest) = length(i+size s, rest)
	in
	  case length(0, sl)
	   of 0 => ""
	    | 1 => let
		fun find ("" :: r) = find r
		  | find (s :: _) = s
		  | find _ = "" (** impossible **)
		in
		  find sl
		end
	    | totLen => let
		val ss = create totLen
		fun copy ([], _) = ()
		  | copy (s::r, i) = let
		      val len = i2w(size s)
		      fun copy' j = if (j = len)
			    then ()
			    else (
			      unsafe_update(ss, uplus(i,j), 
					    unsafe_vsub(s, j));
			      copy'(uplus(j,0w1)))
		      in
			copy' 0w0;
			copy (r, uplus(i,len))
		      end
		in
		  copy (sl, 0w0);  unsafe_array2vector ss
		end
	  (* end case *)
	end (* concat *)

  (* implode a list of characters into a string *)
    fun implode [] = ""
      | implode cl =  let
	  fun length ([], n) = n
	    | length (_::r, n) = length (r, n+1)
	  in
	    PreString.implode (length (cl, 0), cl)
	  end

  (* explode a string into a list of characters *)
    fun explode s = let
	  fun f(l, ~1) = l
	    | f(l,  i) = f(unsafe_vsub(s, i2w i) :: l, i-1)
	  in
	    f(nil, size s - 1)
	  end

    fun map f vec = (case (size vec)
	   of 0 => ""
	    | len => let
		val newVec = create len
		val len = i2w len
		fun mapf i = if ult(i,len)
		      then (unsafe_update(newVec, i, 
					 f(unsafe_vsub(vec, i)));
			    mapf(uplus(i,0w1)))
		      else ()
		in  mapf 0w0; unsafe_array2vector newVec
		end
	  (* end case *))

  (* map a translation function across the characters of a string *)
    fun translate tr s = PreString.translate (tr, s, 0w0, i2w (size s))

  (* tokenize a string using the given predicate to define the delimiter
   * characters.
   *)
    fun tokens isDelim s = let
	  val n = size s
	  fun substr (i, j, l) = if (i = j)
		then l
		else PreString.unsafeSubstring(s, i2w i, i2w(j-i))::l
	  fun scanTok (i, j, toks) = if (j < n)
		  then if (isDelim (unsafe_vsub (s, i2w j)))
		    then skipSep(j+1, substr(i, j, toks))
		    else scanTok (i, j+1, toks)
		  else substr(i, j, toks)
	  and skipSep (j, toks) = if (j < n)
		  then if (isDelim (unsafe_vsub (s, i2w j)))
		    then skipSep(j+1, toks)
		    else scanTok(j, j+1, toks)
		  else toks
	  in
	    rev (scanTok (0, 0, []))
	  end
    fun fields isDelim s = let
	  val n = size s
	  fun substr (i, j, l) = PreString.unsafeSubstring(s, i2w i, i2w(j-i))::l
	  fun scanTok (i, j, toks) = if (j < n)
		  then if (isDelim (unsafe_vsub (s, i2w j)))
		    then scanTok (j+1, j+1, substr(i, j, toks))
		    else scanTok (i, j+1, toks)
		  else substr(i, j, toks)
	  in
	    rev (scanTok (0, 0, []))
	  end

  (* String comparisons *)
    fun isPrefix s1 s2 = PreString.isPrefix (s1, s2, 0w0, i2w(size s2))
    fun compare (a, b) = PreString.cmp (a, 0w0, size a, b, 0w0, size b)
    fun collate cmpFn (a, b) = PreString.collate cmpFn (a, 0w0, size a, b, 0w0, size b)

  (* String greater or equal *)
    fun sgtr (a, b) = let
	  val al = size a and bl = size b
	  val n = if (al < bl) then al else bl
	  fun cmp i = if (i = n)
		then (al > bl)
		else let
		  val ai = unsafe_vsub(a,i2w i)
		  val bi = unsafe_vsub(b,i2w i)
		  in
		    Char.>(ai, bi) orelse ((ai = bi) andalso cmp(i+1))
		  end
	  in
	    cmp 0
	  end

    fun op <= (a,b) = if sgtr(a,b) then false else true
    fun op < (a,b) = sgtr(b,a)
    fun op >= (a,b) = b <= a
    val op > = sgtr

    fun fromString s = let
	  val len = i2w(size s)
	  fun getc i = if ult(i,len)
		then SOME(unsafe_vsub(s, i), uplus(i,0w1))
		else NONE
	  val scanChar = Char.scan getc
	  fun accum (i, chars) = (case (scanChar i)
		 of NONE => if ult(i,len)
		      then NONE (* bad format *)
		      else SOME(implode(rev chars))
		  | (SOME(c, i')) => accum(i', c::chars)
		(* end case *))
	  in
	    accum (0w0, [])
	  end
    val toString = translate Char.toString

    fun fromCString s = raise TiltExn.LibFail "String.fromCString not implemented"
    val toCString = translate Char.toCString

  end (* structure String *)	   
(* substring-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature SUBSTRING =
  sig
    structure String : STRING
	(* sharing type String.string = String.Char.string -- Holds for TILT but not part of this signature *)
    type substring

    val base : substring -> String.string * int * int

    val string : substring -> String.string

    val extract : String.string * int * int option -> substring

    val substring : String.string * int * int -> substring
    val all : String.string -> substring

    val isEmpty : substring -> bool

    val getc  : substring -> (String.Char.char * substring) option
    val first : substring -> String.Char.char option
    val triml : int -> substring -> substring
    val trimr : int -> substring -> substring

    val slice   : substring * int * int option -> substring
    val sub     : substring * int -> String.Char.char
    val size    : substring -> int
    val concat  : substring list -> String.string
    val explode : substring -> String.Char.char list

    val isPrefix : String.string -> substring -> bool
    val compare  : substring * substring -> order
    val collate  : (String.Char.char * String.Char.char -> order) -> substring * substring -> order

    val splitl  : (String.Char.char -> bool) -> substring -> substring * substring
    val splitr  : (String.Char.char -> bool) -> substring -> substring * substring
    val splitAt : substring * int -> substring * substring

    val dropl  : (String.Char.char -> bool) -> substring -> substring
    val dropr  : (String.Char.char -> bool) -> substring -> substring
    val takel  : (String.Char.char -> bool) -> substring -> substring
    val taker  : (String.Char.char -> bool) -> substring -> substring
	
    val position : String.string -> substring -> substring * substring

    val span : substring * substring -> substring

    val translate : (String.Char.char -> String.string) -> substring -> String.string

    val tokens : (String.Char.char -> bool) -> substring -> substring list
    val fields : (String.Char.char -> bool) -> substring -> substring list

    val foldl : (String.Char.char * 'a -> 'a) -> 'a -> substring -> 'a
    val foldr : (String.Char.char * 'a -> 'a) -> 'a -> substring -> 'a
    val app   : (String.Char.char -> unit) -> substring -> unit

  end

(* substring.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure Substring :> SUBSTRING where type substring = PreString.substring
				   and type String.string = string
				   and type String.Char.char = char
				   and type String.Char.string = string =
  struct

    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
    val unsafe_vsub = TiltPrim.unsafe_vsub
	
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
	
    val uminus = TiltPrim.uminus
    val uplus = TiltPrim.uplus
(*
    val op + = InlineT.DfltInt.+
    val op - = InlineT.DfltInt.-
    val op < = InlineT.DfltInt.<
    val op <= = InlineT.DfltInt.<=
    val op > = InlineT.DfltInt.>
    val op >= = InlineT.DfltInt.>=
    val op = = InlineT.=
    val unsafeSub = InlineT.CharVector.sub
*)

    val i2w = int32touint32
    val w2i = uint32toint32

  (* list reverse *)
    fun rev ([], l) = l
      | rev (x::r, l) = rev (r, x::l)

    structure String = String
    datatype substring = datatype PreString.substring
    fun base (PreString.SS arg) = arg

    fun string (PreString.SS(s,st,sz)) = PreString.unsafeSubstring(s,i2w st,i2w sz)

				   
    fun substring (s, i, n) =
	  if ((0 <= i) andalso (0 <= n) andalso (i+n <= String.size s))
	    then PreString.SS(s, i, n)
	    else raise General.Subscript
		
    fun extract (s, i, NONE) = if ((0 <= i) andalso (i <= String.size s))
				   then PreString.SS(s, i, String.size s - i)
			       else raise General.Subscript
      | extract (s, i, SOME n) = substring (s, i, n)

    fun all s = PreString.SS(s, 0, String.size s)

    fun isEmpty (PreString.SS(_, _, 0)) = true
      | isEmpty _ = false

    fun getc (PreString.SS(s, i, 0)) = NONE
      | getc (PreString.SS(s, i, n)) = SOME(unsafe_vsub(s, i2w i), PreString.SS(s, i+1, n-1))
    fun first (PreString.SS(s, i, 0)) = NONE
      | first (PreString.SS(s, i, n)) = SOME(unsafe_vsub(s, i2w i))
    fun triml k (PreString.SS(s, i, n)) =
	  if (k < 0) then raise Subscript
	  else if (k >= n) then PreString.SS(s, i+n, 0)
	  else PreString.SS(s, i+k, n-k)
    fun trimr k (PreString.SS(s, i, n)) =
	  if (k < 0) then raise Subscript
	  else if (k >= n) then PreString.SS(s, i, 0)
	  else PreString.SS(s, i, n-k)

    fun sub (PreString.SS(s, i, n), j) =
	  if (j >= n)
	    then raise General.Subscript
	    else unsafe_vsub(s, i2w(i+j))
    fun size (PreString.SS(_, _, n)) = n
    fun slice (PreString.SS(s, i, n), j, SOME m) =
	  if ((0 <= j) andalso (0 <= m) andalso (j+m <= n))
	    then PreString.SS(s, i+j, m)
	    else raise Subscript
      | slice (PreString.SS(s, i, n), j, NONE) =
	  if (0 <= j) andalso (j <= n)
	    then PreString.SS(s, i+j, n-j)
	    else raise Subscript

  (* concatenate a list of substrings together *)
    fun concat ssl = let
	fun length (len, sl, []) = (len, sl)
	  | length (len, sl, (PreString.SS(s, i, n)::rest)) =
	      length(len+n, PreString.unsafeSubstring(s, i2w i, i2w n)::sl, rest)
	in
	  PreString.revConcat (length (0, [], ssl))
	end
	  
  (* explode a substring into a list of characters *)
    fun explode (PreString.SS(s, i, n)) = let
	  fun f(l, j) = if ult(j,i2w i)
		then l
		else f(unsafe_vsub(s, j) :: l, uminus(j,0w1))
	  in
	    f(nil, i2w((i + n) - 1))
	  end

  (* Substring comparisons *)
    fun isPrefix s1 (PreString.SS(s2, i2, n2)) = PreString.isPrefix (s1, s2,i2w  i2, i2w n2)
    fun compare (PreString.SS(s1, i1, n1), PreString.SS(s2, i2, n2)) =
	  PreString.cmp (s1, i2w i1, n1, s2, i2w i2, n2)
    fun collate cmpFn (PreString.SS(s1, i1, n1), PreString.SS(s2, i2, n2)) =
	  PreString.collate cmpFn (s1, i2w i1, n1, s2, i2w i2, n2)

    fun splitAt (PreString.SS(s, i, n), k) =
	  if (n < k)
	    then raise Subscript
	    else (PreString.SS(s, i, k), PreString.SS(s, i+k, n-k))

    local
      fun scanl chop pred (PreString.SS(s, i, n)) = let
	    val stop = i2w(i+n)
	    fun scan j = if ((j <> stop) andalso pred(unsafe_vsub(s, j)))
		  then scan(uplus(j,0w1))
		  else j
	    in
	      chop (s, i, n, w2i(scan (i2w(i - i))))
	    end
      fun scanr chop pred (PreString.SS(s, i, n)) = let
	    val stop = i2w(i-1)
	    fun scan j = if ((j <> stop) andalso pred(unsafe_vsub(s, j)))
		  then scan(uminus(j,0w1))
		  else j
	    val k : int = (w2i (scan (i2w (i+n-1)))) - i + 1
	    in
	      chop (s, i, n, k)
	    end
    in
    val splitl = scanl (fn (s, i, n, k) => (PreString.SS(s, i, k), PreString.SS(s, i+k, n-k)))
    val splitr = scanr (fn (s, i, n, k) => (PreString.SS(s, i, k), PreString.SS(s, i+k, n-k)))
    val dropl  = scanl (fn (s, i, n, k) => PreString.SS(s, i+k, n-k))
    val dropr  = scanr (fn (s, i, n, k) => PreString.SS(s, i, k))
    val takel  = scanl (fn (s, i, n, k) => PreString.SS(s, i, k))
    val taker  = scanr (fn (s, i, n, k) => PreString.SS(s, i+k, n-k))
    end (* local *)
	



  (* find the position of the first occurrence of s in the substring.
   * NOTE: some day we might want to implement KMP matching for this
   *)
    fun position s (PreString.SS (s', i, n)) = let
	  val len = String.size s
	  val len' = i2w len
	  fun eq (j, k) = ugte(j,len') orelse
		((unsafe_vsub(s, j) = unsafe_vsub(s', k)) andalso 
		 eq (uplus(j,0w1),uplus(k,0w1)))
	  val stop = i+n-len
	  fun cmp k =
		if (k > stop) then i+n (* failure *)
		else if eq(0w0, i2w k) then k
		else cmp(k+1)
	  val indx = cmp i
	  in
	    (PreString.SS(s', i, indx-i), PreString.SS(s', indx, i+n-indx))
	  end

    fun span (PreString.SS(s1, i1, n1), PreString.SS(s2, i2, n2)) =
	  if ((s1 = s2) andalso (i1 < i2+n2))
	    then PreString.SS(s1, i1, (i2+n2)-i1)
	    else raise General.Span

    fun translate tr (PreString.SS(s, i, n)) =
	  PreString.translate (tr, s, i2w i, i2w n)

    fun tokens isDelim (PreString.SS(s, i, n)) = let
	  val stop = i+n
	  fun substr (i, j, l) =
		if (i = j) then l else PreString.SS(s, i, j-i)::l
	  fun scanTok (i, j, toks) = if (j < stop)
		  then if (isDelim (unsafe_vsub (s, i2w j)))
		    then skipSep(j+1, substr(i, j, toks))
		    else scanTok (i, j+1, toks)
		  else substr(i, j, toks)
	  and skipSep (j, toks) = if (j < stop)
		  then if (isDelim (unsafe_vsub (s, i2w j)))
		    then skipSep(j+1, toks)
		    else scanTok(j, j+1, toks)
		  else toks
	  in
	    rev (scanTok (i, i, []), [])
	  end
    fun fields isDelim (PreString.SS(s, i, n)) = let
	  val stop = i+n
	  fun substr (i, j, l) = PreString.SS(s, i, j-i)::l
	  fun scanTok (i, j, toks) = if (j < stop)
		  then if (isDelim (unsafe_vsub (s, i2w j)))
		    then scanTok (j+1, j+1, substr(i, j, toks))
		    else scanTok (i, j+1, toks)
		  else substr(i, j, toks)
	  in
	    rev (scanTok (i, i, []), [])
	  end

    fun foldl f init (PreString.SS(s, i, n)) = let
	  val stop = i+n
	  fun iter (j, accum) = if (j < stop)
		then iter (j+1, f (unsafe_vsub(s, i2w j), accum))
		else accum
	  in
	    iter (i, init)
	  end
    fun foldr f init (PreString.SS(s, i, n)) = let
	  fun iter (j, accum) = if (j >= i)
		then iter (j-1, f (unsafe_vsub(s, i2w j), accum))
		else accum
	  in
	    iter (i+n-1, init)
	  end
    fun app f (PreString.SS(s, i, n)) = let
	  val stop = i+n
	  fun iter j = if (j < stop)
		then (f (unsafe_vsub(s, i2w j)); iter (j+1))
		else ()
	  in
	    iter i
	  end

  end;
structure PreInt = 
    struct
	type int = int
	    
	fun imod(a : int, b : int) =
	    let val temp = TiltPrim.irem(a,b)
	    in if ((b>0 andalso temp>=0) orelse
		   (b<0 andalso temp<=0))
		   then temp
	       else temp+b
	    end

	fun idiv(a : int, b : int) =
	    let val temp = TiltPrim.iquot(a,b)
	    in  (* same if sign of a and b agree *)
		if ((a>=0 andalso b>0) orelse (a<=0 andalso b<0))
		    then temp
		else 
		    if (b * temp = a)   (* same if exact div *)
			then temp
		    else temp - 1       (* here's where they differ *)
	    end
	
	(* Note ineg includes overflow check. *)
	fun iabs (a : int) : int = if TiltPrim.igt (a, 0) then a else TiltPrim.ineg a
	    
    end

structure PreLargeInt = 
    struct
	type int = int
    end

extern real_logb : (real, int) -->
extern real_scalb : (real * int, real) -->
extern sqrt : (real, real) -->
extern exp : (real, real) -->
extern ln : (real, real) -->
extern log10 : (real, real) -->
extern sin : (real, real) -->
extern cos : (real, real) -->
extern tan : (real, real) -->
extern atan : (real, real) -->
extern asin : (real, real) -->
extern acos : (real, real) -->
extern tanh : (real, real) -->
extern sinh : (real, real) -->
extern cosh : (real, real) -->
extern setRoundingMode : (int, int) -->
extern getRoundingMode : (int, int) -->

structure PreLargeReal =
    struct
	type real = real
    end

structure PreReal =
    struct
	type real = real
    end
structure PreWord = 
    struct
	type word = word
    end

structure PreLargeWord = 
    struct
	type word = word
    end


structure PreVector :
    sig
	val maxLen : int
	val checkLen : int -> unit
	val arrayFromList' : int * 'a list -> 'a array (* known length *)
	val arrayFromList : 'a list -> 'a array
	val vectorFromList' : int * 'a list -> 'a vector (* known length *)
	val vectorFromList : 'a list -> 'a vector
    end =
struct

    fun list_length l =
	let
	    fun len ([], n) = n
	      | len ([_], n) = n+1
	      | len (_::_::r, n) = len(r, n+2)
	in  len (l, 0)
	end
    fun list_hd' (h :: _) = h		(* list_hd' nil does not behave like List.hd nil *)
	    
    val maxLen = 1024 * 1024
    fun checkLen n = if maxLen < n then raise Size else ()
    
    fun arrayFromList'(n,l) = 
	let val _ = checkLen n
	in
	    if (n = 0)
		then TiltPrim.empty_array
	    else let val e = list_hd' l
		     val ar = TiltPrim.unsafe_array(TiltPrim.int32touint32 n, e)
		     fun loop [] _ = ()
		       | loop (a::b) n = (TiltPrim.unsafe_update(ar,n,a);
					  loop b (TiltPrim.uplus(n,0w1)))
		     val _ = loop l 0w0
		 in  ar
		 end
	end

    fun arrayFromList l = arrayFromList' (list_length l, l)

    fun vectorFromList' arg = TiltPrim.unsafe_array2vector(arrayFromList' arg)

    fun vectorFromList arg = TiltPrim.unsafe_array2vector(arrayFromList arg)
end
(* num-scan.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * The string conversion for the largest int and word types.
 * All of the other scan functions can be implemented in terms of them.
 *
 *)

structure NumScan : sig

    val scanWord : StringCvt.radix
	  -> (char, 'a) StringCvt.reader -> (PreLargeWord.word, 'a) StringCvt.reader
    val scanInt  : StringCvt.radix
	  -> (char, 'a) StringCvt.reader -> (PreLargeInt.int, 'a) StringCvt.reader
    val scanReal : (char, 'a) StringCvt.reader -> (PreLargeReal.real, 'a) StringCvt.reader
	(** should be to LargeReal.real **)

  end = struct
  
    val && = TiltPrim.&&
    val << = TiltPrim.<<
	
    type int32 = TiltPrim.int32
    type word32 = TiltPrim.uint32
	
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
    val unsafe_vsub = TiltPrim.unsafe_vsub
	
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
	
    val uminus = TiltPrim.uminus
    val uplus = TiltPrim.uplus
    val umult = TiltPrim.umult
(*
    structure W = InlineT.Word32
    structure I = InlineT.Int31
    structure I32 = InlineT.Int32
    structure R = InlineT.Real64
    type word = word32
*)
    val iplus : int * int -> int = op +
    val iminus : int * int -> int = op -
    val imult : int * int -> int = op *
    val iless : int * int -> bool = op <
    val ineg : int -> int = ~
    val rplus : real* real -> real = op +
    val rmult : real* real -> real = op *
    val rneg : real -> real = ~
    val op <  = ult
    val op >= = ugte
    val op +  = uplus
    val op -  = uminus
    val op *  = umult

    val largestWordDiv10 : word = 0w429496729	(* 2^32-1 divided by 10 *)
    val largestWordMod10 : word = 0w5		(* remainder *)

    val largestNegInt32 : word = 0wx80000000
    val largestPosInt32 : word = 0wx7fffffff
    val minInt32 : int32 = ~2147483648

  (* A table for mapping digits to values.  Whitespace characters map to
   * 128, "+" maps to 129, "-","~" map to 130, "." maps to 131, and the
   * characters 0-9,A-Z,a-z map to their * base-36 value.  All other
   * characters map to 255.
   *)
    local
      val cvtTable = "\
	    \\255\255\255\255\255\255\255\255\255\128\128\255\255\255\255\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	    \\128\255\255\255\255\255\255\255\255\255\255\129\255\130\131\255\
	    \\000\001\002\003\004\005\006\007\008\009\255\255\255\255\255\255\
	    \\255\010\011\012\013\014\015\016\017\018\019\020\021\022\023\024\
	    \\025\026\027\028\029\030\031\032\033\034\035\255\255\255\255\255\
	    \\255\010\011\012\013\014\015\016\017\018\019\020\021\022\023\024\
	    \\025\026\027\028\029\030\031\032\033\034\035\255\255\255\130\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	    \\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
	  \"
(*      val ord = InlineT.Char.ord *)
    in
    fun code (c : char) = (* W.fromInt(ord(InlineT.CharVector.sub(cvtTable, ord c))) *)
	int32touint32(ord(String.sub(cvtTable, ord c)))
    val wsCode : word = 0w128		(* code for whitespace *)
    val plusCode : word = 0w129		(* code for #"+" *)
    val minusCode : word = 0w130	(* code for #"-" and #"~" *)
    val ptCode : word = 0w131		(* code for #"." *)
    val eCode : word = 0w14		(* code for #"e" and #"E" *)
    val wCode : word = 0w32		(* code for #"w" and #"W" *)
    val xCode : word = 0w33		(* code for #"X" and #"X" *)
    end (* local *)

    type prefix_pat = {
	wOkay : bool,		(* true if 0[wW] prefix is okay; if this is
				 * true, then signs (+, -, ~) are not okay.
				 *)
	xOkay : bool,		(* true if 0[xX] prefix is okay *)
	isDigit : word -> bool	(* returns true for allowed digits *)
      }

    fun scanPrefix (p : prefix_pat) getc cs = let
	  fun getNext cs = (case (getc cs)
		 of NONE => NONE
		  | (SOME(c, cs)) => SOME(code c, cs)
		(* end case *))
	  fun skipWS cs = (case (getNext cs)
		 of NONE => NONE
		  | (SOME(c, cs')) =>
		      if (c = wsCode) then skipWS cs' else SOME(c, cs')
		(* end case *))
	  fun getOptSign NONE = NONE
	    | getOptSign (next as SOME(c, cs)) =
		if (#wOkay p)
		  then getOpt0 (false, SOME(c, cs))
		else if (c = plusCode)
		  then getOpt0 (false, getNext cs)
		else if (c = minusCode)
		  then getOpt0 (true, getNext cs)
		  else getOpt0 (false, next)
	  and getOpt0 (neg, NONE) = NONE
	    | getOpt0 (neg, SOME(c, cs)) =
		if ((c = 0w0) andalso ((#wOkay p) orelse (#xOkay p)))
		  then getOptW (neg, (c, cs), getNext cs)
		  else finish (neg, (c, cs))
	  and getOptW (neg, savedCS, NONE) = finish (neg, savedCS)
	    | getOptW (neg, savedCS, arg as SOME(c, cs)) =
		if ((c = wCode) andalso (#wOkay p))
		  then getOptX (neg, savedCS, getNext cs)
		  else getOptX (neg, savedCS, arg)
	  and getOptX (neg, savedCS, NONE) = finish (neg, savedCS)
	    | getOptX (neg, savedCS, arg as SOME(c, cs)) =
		if ((c = xCode) andalso (#xOkay p))
		  then chkDigit (neg, savedCS, getNext cs)
		  else chkDigit (neg, savedCS, arg)
	  and chkDigit (neg, savedCS, NONE) = finish (neg, savedCS)
	    | chkDigit (neg, savedCS, SOME(c, cs)) =
		if ((#isDigit p) c)
		  then SOME{neg=neg, next = c, rest = cs}
		  else finish (neg, savedCS)
	  and finish (neg, (c, cs)) =
		if ((#isDigit p) c)
		  then SOME{neg=neg, next = c, rest = cs}
		  else NONE
	  in
	    getOptSign (skipWS cs)
	  end

  (* for power of 2 bases (2, 8 & 16), we can check for overflow by looking
   * at the hi (1, 3 or 4) bits.
   *)
    fun chkOverflow mask w =
	  if (&&(mask, w) = 0w0) then () else raise Overflow

    fun isBinDigit d = (d < 0w2)
    fun isOctDigit d = (d < 0w8)
    fun isDecDigit d = (d < 0w10)
    fun isHexDigit d = (d < 0w16)

    fun binPat wOkay = {wOkay=wOkay, xOkay=false, isDigit=isBinDigit}
    fun octPat wOkay = {wOkay=wOkay, xOkay=false, isDigit=isOctDigit}
    fun decPat wOkay = {wOkay=wOkay, xOkay=false, isDigit=isDecDigit}
    fun hexPat wOkay = {wOkay=wOkay, xOkay=true, isDigit=isHexDigit}

    fun scanBin isWord getc cs = (case (scanPrefix (binPat isWord) getc cs)
	   of NONE => NONE
	    | (SOME{neg, next, rest}) => let
		val chkOverflow = chkOverflow 0wx80000000
		fun cvt (w, rest) = (case (getc rest)
		       of NONE => SOME{neg=neg, word=w, rest=rest}
			| SOME(c, rest') => let val d = code c
			    in
			      if (isBinDigit d)
				then (
				  chkOverflow w;
				  cvt(<<(w, 1) + d, rest'))
				else SOME{neg=neg, word=w, rest=rest}
			    end
		      (* end case *))
		in
		  cvt (next, rest)
		end
	  (* end case *))

    fun scanOct isWord getc cs = (case (scanPrefix (octPat isWord) getc cs)
	   of NONE => NONE
	    | (SOME{neg, next, rest}) => let
		val chkOverflow = chkOverflow 0wxE0000000
		fun cvt (w, rest) = (case (getc rest)
		       of NONE => SOME{neg=neg, word=w, rest=rest}
			| SOME(c, rest') => let val d = code c
			    in
			      if (isOctDigit d)
				then (
				  chkOverflow w;
				  cvt(<<(w, 3) + d, rest'))
				else SOME{neg=neg, word=w, rest=rest}
			    end
		      (* end case *))
		in
		  cvt (next, rest)
		end
	  (* end case *))

    fun scanDec isWord getc cs = (case (scanPrefix (decPat isWord) getc cs)
	   of NONE => NONE
	    | (SOME{neg, next, rest}) => let
		fun cvt (w, rest) = (case (getc rest)
		       of NONE => SOME{neg=neg, word=w, rest=rest}
			| SOME(c, rest') => let val d = code c
			    in
			      if (isDecDigit d)
				then (
				  if ((w >= largestWordDiv10)
				  andalso ((largestWordDiv10 < w)
				    orelse (largestWordMod10 < d)))
				    then raise Overflow
				    else ();
				  cvt (0w10*w+d, rest'))
				else SOME{neg=neg, word=w, rest=rest}
			    end
		      (* end case *))
		in
		  cvt (next, rest)
		end
	  (* end case *))

    fun scanHex isWord getc cs = (case (scanPrefix (hexPat isWord) getc cs)
	   of NONE => NONE
	    | (SOME{neg, next, rest}) => let
		val chkOverflow = chkOverflow 0wxF0000000
		fun cvt (w, rest) = (case (getc rest)
		       of NONE => SOME{neg=neg, word=w, rest=rest}
			| SOME(c, rest') => let val d = code c
			    in
			      if (isHexDigit d)
				then (
				  chkOverflow w;
				  cvt((<<(w, 4) + d), rest'))
				else SOME{neg=neg, word=w, rest=rest}
			    end
		      (* end case *))
		in
		  cvt (next, rest)
		end
	  (* end case *))

    fun finalWord scanFn getc cs = (case (scanFn true getc cs)
	   of NONE => NONE
	    | (SOME{neg, word, rest}) => SOME(word, rest)
	  (* end case *))

    fun scanWord StringCvt.BIN = finalWord scanBin
      | scanWord StringCvt.OCT = finalWord scanOct
      | scanWord StringCvt.DEC = finalWord scanDec
      | scanWord StringCvt.HEX = finalWord scanHex


(*
      val fromword32 = W.toLargeIntX 
       val fromword32' = W.toIntX 
*)
	val fromword32 = uint32toint32
	val fromword32' = uint32toint32

    fun finalInt scanFn getc cs = (case (scanFn false getc cs)
	   of NONE => NONE
	    | (SOME{neg=true, word, rest}) =>
		if (word < largestNegInt32) then
		   SOME(ineg(fromword32 word), rest)
		else if (largestNegInt32 < word) then
		   raise Overflow
		else 
		   SOME(minInt32, rest)
	    | (SOME{word, rest, ...}) =>
		if (largestPosInt32 < word) then
		   raise Overflow
	        else 
	           SOME(fromword32 word, rest)
	  (* end case *))


    fun scanInt StringCvt.BIN = finalInt scanBin
      | scanInt StringCvt.OCT = finalInt scanOct
      | scanInt StringCvt.DEC = finalInt scanDec
      | scanInt StringCvt.HEX = finalInt scanHex
  
  (* scan a string of decimal digits (starting with d), and return their
   * value as a real number.  Also return the number of digits, and the
   * rest of the stream.
   *)
    fun fscan10 getc (d, cs) = let
	  fun wordToReal w = real(fromword32' w)
	  fun scan (accum, n, cs) = (case (getc cs)
		 of (SOME(c, cs')) => let val d = code c
		      in
			if (isDecDigit d)
			  then scan(rplus(rmult(10.0, accum), wordToReal d), iplus(n, 1), cs')
			  else SOME(accum, n, cs)
		      end
		  | NONE => SOME(accum, n, cs)
		(* end case *))
	  in
	    if (isDecDigit d) then scan(wordToReal d, 1, cs) else NONE
	  end

    local
      val negTbl = PreVector.vectorFromList [
	      1.0E~0, 1.0E~1, 1.0E~2, 1.0E~3, 1.0E~4,
	      1.0E~5, 1.0E~6, 1.0E~7, 1.0E~8, 1.0E~9
	    ]
      val posTbl = PreVector.vectorFromList [
	      1.0E0, 1.0E1, 1.0E2, 1.0E3, 1.0E4,
	      1.0E5, 1.0E6, 1.0E7, 1.0E8, 1.0E9
	    ]
      fun scale (tbl, step10 : real) = let
	    fun f (r, 0) = r
	      | f (r, exp) = if (iless(exp, 10))
		  then (rmult(r, unsafe_vsub(tbl, int32touint32 exp)))
		  else f (rmult(step10, r), iminus(exp, 10))
	    in
	      f
	    end
    in
    val scaleUp = scale (posTbl, 1.0E10)
    val scaleDown = scale (negTbl, 1.0E~10)
    end

    fun scanReal getc cs = let
	  fun scan10 cs = (case (getc cs)
		 of (SOME(c, cs)) => fscan10 getc (code c, cs)
		  | NONE => NONE
		(* end case *))
	  fun getFrac rest = (case (scan10 rest)
		 of SOME(frac, n, rest) => (SOME(scaleDown(frac, n)), rest)
		  | NONE => (NONE, rest)
		(* end case *))
	  fun combine (SOME whole, SOME frac) = rplus(whole, frac)
	    | combine (SOME whole, NONE) = whole
	    | combine (NONE, SOME frac) = frac
	    | combine _ = raise Option.Option
	  fun negate (true, num) = rneg num
	    | negate (false, num) = num
	  fun scanExp cs = (case (getc cs)
		 of SOME(c, cs) => let
		      val d = code c
		      fun scan (accum, cs) = (case (getc cs)
			     of SOME(c, cs') => let val d = code c
				  in
				    if (isDecDigit d)
				      then scan (iplus(imult(accum, 10), fromword32' d), cs')
				      else (accum, cs)
				  end
			      | NONE => (accum, cs)
			    (* end case *))
		      in
			if (isDecDigit d)
			  then SOME (scan (fromword32' d, cs))
			  else NONE
		      end
		  | NONE => NONE
		(* end case *))
	  fun getExp cs = (case (getc cs)
		 of (SOME(c, cs)) => if (code c = eCode)
		      then (case (getc cs)
			 of SOME(c, cs') => let
			      val (isNeg, cs) = if (code c = minusCode)
				    then (true, cs')
				    else (false, cs)
			      in
			        case scanExp cs
				 of SOME(exp, cs) => SOME(isNeg, exp, cs)
				  | NONE => NONE
				(* end case *)
			      end
			  | NONE => NONE
			(* end case *))
		      else NONE
		  | NONE => NONE
		(* end case *))
	  in
	    case (scanPrefix (decPat false) getc cs)
	     of NONE => NONE
	      | (SOME{neg, next, rest}) => let
		  val (whole, hasPt, rest) = if (next = ptCode)
			then (NONE, true, rest)
			else let
			  val (whole, rest) = (case fscan10 getc (next, rest)
				 of SOME(whole, _, rest) => (SOME whole, rest)
				  | NONE => (NONE, rest)
				(* end case *))
			  in
			    case (getc rest)
			     of SOME(#".", rest) => (whole, true, rest)
			      | _ => (whole, false, rest)
			    (* end case *)
			  end
		  val (frac, rest) = if hasPt then getFrac rest else (NONE, rest)
		  val num = negate (neg, combine (whole, frac))
		  in
		    case (getExp rest)
		     of (SOME(isNeg, exp, rest)) =>
			  if isNeg
			    then SOME(scaleDown(num, exp), rest)
			    else SOME(scaleUp(num, exp), rest)
		      | NONE => SOME(num, rest)
		    (* end case *)
		  end
	    (* end case *)
	  end
	    handle Option => NONE

  end;




(* integer-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)



signature INTEGER =
  sig

    eqtype int

    val toLarge   : int -> PreLargeInt.int
    val fromLarge : PreLargeInt.int -> int
	
    val toInt     : int -> PreInt.int
    val fromInt   : PreInt.int -> int

    val precision : PreInt.int option
    val minInt : int option
    val maxInt : int option

    val ~ : int -> int
    val * : int * int -> int
    val div : int * int -> int
    val mod : int * int -> int
    val quot : int * int -> int
    val rem : int * int -> int
    val + : int * int -> int
    val - : int * int -> int
	
    val compare : int * int -> order
    val >  : int * int -> bool
    val >= : int * int -> bool
    val <  : int * int -> bool
    val <= : int * int -> bool

    val abs : int -> int
    val min : int * int -> int
    val max : int * int -> int

    val sign     : int -> PreInt.int
    val sameSign : int * int -> bool

    val fmt  : StringCvt.radix -> int -> string
    val toString   : int -> string
    val fromString : string -> int option
    val scan : StringCvt.radix -> (char, 'a) StringCvt.reader -> (int, 'a) StringCvt.reader

  end;



(* int32.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure Int32 :> INTEGER where type int = int =
  struct
    val quot = TiltPrim.iquot
    val andb = TiltPrim.andb
    val xorb = TiltPrim.xorb
(*
    structure I32 = InlineT.Int32

    type int = int32
*)
    type int = int

    val precision = SOME 32

    val minIntVal : int = ~2147483648
    val minInt : int option = SOME minIntVal
    val maxInt : int option = SOME 2147483647
(*
    val op *    : int * int -> int  = I32.*
    val op quot : int * int -> int  = I32.quot
    val op +    : int * int -> int  = I32.+
    val op -    : int * int -> int  = I32.-
    val ~       : int -> int = I32.~
    val op <    : int * int -> bool = I32.<
    val op <=   : int * int -> bool = I32.<=
    val op >    : int * int -> bool = I32.>
    val op >=   : int * int -> bool = I32.>=
    val op =    : int * int -> bool = I32.=
    val op <>   : int * int -> bool = I32.<>
*)

    val op *    : int * int -> int  = *
    val op quot : int * int -> int  = quot
    val op +    : int * int -> int  = +
    val op -    : int * int -> int  = -
    val ~       : int -> int = ~
    val op <    : int * int -> bool = <
    val op <=   : int * int -> bool = <=
    val op >    : int * int -> bool = >
    val op >=   : int * int -> bool = >=
    val op =    : int * int -> bool = =
    val op <>   : int * int -> bool = <>
    nonfix * quot + - < <= > >= = <>

  (* min, max, abs, rem, div, and mod should be inlined. 
   *     ... but this is not the time!
   *)
    fun min(a:int, b:int):int = if <(a,b) then a else b
    fun max(a:int, b:int):int = if >(a,b) then a else b
    fun op rem(a:int,b:int):int =  -(a, *(b, quot(a, b)))
(*
    fun abs(a:int):int = if >(a, 0) then ~(a) else a
    fun op div(a:int, b:int):int = if >=(b, 0)
	  then if >=(a, 0)
	    then quot(a, b) 
	    else -(quot(+(a, 1), b), 1)
	  else if >(a,0)
	    then -(quot(-(a, 1), b), 1)
	    else quot(a, b)

    fun op mod(a:int, b:int):int = if >=(b, 0)
	  then if >=(a, 0)
	    then -(a, *(quot(a, b), b))
	    else -(a, +( *(quot(+(a,1), b), b), b))
	  else if >(a, 0)
	    then -(a, +( *(quot(-(a,1), b), b), b))
	  else if =(a, ~2147483648) andalso =(b, ~1)
	    then 0
	    else -(a, * (quot(a, b), b))
*)
    val abs = PreInt.iabs
    val op div = PreInt.idiv
    val op mod = PreInt.imod
	
    fun sign(0) = 0
      | sign i = if <(i, 0) then ~1 else 1

    fun sameSign(i, j) = let val x : int = andb(xorb(i, j), minIntVal)
			 in  =(x,0)
			 end


    fun compare (i:int, j:int) =
	  if (<(i, j)) then General.LESS
	  else if (>(i, j)) then General.GREATER
	  else General.EQUAL

    val scan = NumScan.scanInt
    val fmt = NumFormat.fmtInt
    val toString = fmt StringCvt.DEC
    val fromString = StringCvt.scanString (scan StringCvt.DEC) 

(*
    val toInt : int -> Int.int = toInt
    val fromInt : Int.int -> int = fromInt
    val toLarge : int -> LargeInt.int = toLarge
    val fromLarge : LargeInt.int -> int = fromLarge
*)
    fun toInt (x : int) : PreInt.int = x
    fun fromInt (x : PreInt.int) : int = x
    fun toLarge (x : int) : PreLargeInt.int = x
    fun fromLarge (x : PreInt.int) : int = x

  end

structure Int = Int32
structure Position = Int32
structure LargeInt = Int32
structure SysInt = Int32
signature MATH =
  sig
    type real

    val pi : real
    val e  : real
    val sqrt  : real -> real
    val sin   : real -> real
    val cos   : real -> real
    val tan   : real -> real
    val asin  : real -> real
    val acos  : real -> real
    val atan  : real -> real
    val atan2 : real * real -> real
    val exp   : real -> real
    val pow   : real * real -> real
    val ln    : real -> real
    val log10 : real -> real
    val sinh  : real -> real
    val cosh  : real -> real
    val tanh  : real -> real
  end




structure Math64 :> MATH where type real = real =
  struct
    val float_eq = TiltPrim.float_eq
    val floor = TiltPrim.float2int
	
    (* div and mod will eventually be overloaded to work at multiple types *)
    val div = PreInt.idiv
    val mod = PreInt.imod

    type real = real

    val pi = 3.14159265358979323846
    val e  = 2.7182818284590452354

    (* eta expansion to distingush between ML arrows and external arrows *)
    val sqrt  : real -> real = fn arg => Ccall(sqrt, arg)
    val sin   : real -> real = fn arg => Ccall(sin, arg)
    val cos   : real -> real = fn arg => Ccall(cos, arg)
    val tan   : real -> real = fn arg => Ccall(tan, arg)
    val asin  : real -> real = fn arg => Ccall(asin, arg)
    val acos  : real -> real = fn arg => Ccall(acos, arg)
    val atan  : real -> real = fn arg => Ccall(atan, arg)
    val exp   : real -> real = fn arg => Ccall(exp, arg)
    val ln    : real -> real = fn arg => Ccall(ln, arg)
    val log10 : real -> real = fn arg => Ccall(log10, arg)
    val sinh  : real -> real = fn arg => Ccall(sinh, arg)
    val cosh  : real -> real = fn arg => Ccall(cosh, arg)
    val tanh  : real -> real = fn arg => Ccall(tanh, arg)

    (* the following copied from math64.sml -- we neeed atan2 and pow since
       we don't have multi-arg call to C yet *)
    infix 4 ==
    val (op ==) = float_eq
    local
	val one = 1.0
	val PIo2   =  1.5707963267948966192E0
	val PI = pi
	fun atanpy y = (* y>=0 *)
	    if y>one then PIo2 - atan(one/y) else atan(y)

	fun atan2pypx(x,y) = 
	    if y>x then PIo2 - atan(x/y) else atan(y/x)

	fun atan2py(x,y) = 
	    if x >= 0.0 then atan2pypx(x,y) 
	    else if x == 0.0 andalso y == 0.0 then 0.0
		 else PI - atan2pypx(~x,y)

    in  fun atan y = (* miraculously handles inf's and nan's correctly *)
	if y<=0.0 then ~(atanpy(~y)) else atanpy y
	fun atan2(y,x) = (* miraculously handles inf's and nan's correctly *)
	    if y>=0.0 then atan2py(x,y) else ~(atan2py(x,~y))
    end

    local
	val zero = 0.0
	fun copysign(a,b) = (case (a<zero, b<zero)
				 of (true,true) => a
			       | (false,false) => a
			       | _ => ~a)
	fun isNaN x = not(x==x)
	val plusInfinity = 1E300 * 1E300
	val minusInfinity = ~plusInfinity
	val NaN = 0.0 / 0.0
	
        (* This is the IEEE double-precision maxint; won't work accurately on VAX *)
	val maxint = 4503599627370496.0

	(* realround(x) returns x rounded to some nearby integer, almost always
	 * the nearest integer.
	 *  May be applied to inf's and nan's.
	 *)
	fun realround x = if x>=0.0 then x+maxint-maxint else x-maxint+maxint

	fun isInt y = realround(y)-y == 0.0
	fun isOddInt(y) = isInt((y-1.0)*0.5)
	fun intpow(x,0) = 1.0
	  | intpow(x,y) = let val h = y div 2
			      val z = intpow(x,h)
			      val zz = z*z
			  in if y=(h+h) then zz else x*zz
			  end
	(* may be applied to inf's and nan's *)
	fun abs x = if x < zero then ~x else x
    in
	fun pow(x : real,y : real) = 
	    if y>0.0
		then if y<plusInfinity 
			 then if x > minusInfinity
			 then if x > 0.0
				then exp(y*ln(x))
				else if x == 0.0
			          then if isOddInt(y)
				       then x
				       else 0.0
			          else if isInt(y)
				       then intpow(x,floor(y+0.5))
				       else NaN
			 else if isNaN x
			  then x
			  else if isOddInt(y)
				then x
				else plusInfinity
		   else let val ax = abs(x)
			 in if ax>1.0 then plusInfinity
			    else if ax<1.0 then 0.0
			    else NaN
                        end
               else if y < 0.0
	         then if y>minusInfinity
		   then if x > minusInfinity
			then if x > 0.0
		             then exp(y*ln(x))
			     else if x==0.0 
			          then if isOddInt(y)
		  		     then copysign(plusInfinity,x)
			             else plusInfinity
				  else if isInt(y)
				       then 1.0 / intpow(x, floor(~y+0.5))
				       else NaN
			else if isNaN x
			 then x
			 else if isOddInt(y)
			     then ~0.0
			     else 0.0
		   else let val ax = abs(x)
			 in if ax>1.0 then 0.0
			    else if ax<1.0 then plusInfinity
			    else NaN
                        end
               else if isNaN y
		 then y
	       else 1.0
    end
  end
structure Math = Math64
(* sigs/ieee-real-sig.sml
 *
 * COPYRIGHT (c) 1996 AT&T Bell Laboratories.
 *)

signature IEEE_REAL =
  sig

    exception Unordered

    datatype real_order = LESS | EQUAL | GREATER | UNORDERED

    datatype nan_mode = QUIET | SIGNALLING

    datatype float_class
      = NAN of nan_mode
      | INF
      | ZERO
      | NORMAL
      | SUBNORMAL

    datatype rounding_mode
      = TO_NEAREST
      | TO_NEGINF
      | TO_POSINF
      | TO_ZERO

    val setRoundingMode : rounding_mode -> unit
    val getRoundingMode : unit -> rounding_mode

    type decimal_approx = {
	kind : float_class,
	sign : bool,
	digits : int list,
	exp : int
      }

    val toString   : decimal_approx -> string
    val fromString : string -> decimal_approx option

  end;


(* ieee-real.sml
 *
 * COPYRIGHT (c) 1996 AT&T Bell Laboratories.
 *)

structure IEEEReal :> IEEE_REAL =
  struct

  (* this may cause portability problems to 64-bit systems *)
(*    structure Int = Int31 *)

    exception Unordered

    datatype real_order = LESS | EQUAL | GREATER | UNORDERED

    datatype nan_mode = QUIET | SIGNALLING

    datatype float_class
      = NAN of nan_mode
      | INF
      | ZERO
      | NORMAL
      | SUBNORMAL

    datatype rounding_mode
      = TO_NEAREST
      | TO_NEGINF
      | TO_POSINF
      | TO_ZERO

    fun intToRM 0 = TO_NEAREST
      | intToRM 1 = TO_ZERO
      | intToRM 2 = TO_POSINF
      | intToRM 3 = TO_NEGINF

(*
    val ctlRoundingMode : int option -> int =
	    CInterface.c_function "SMLNJ-Math" "ctlRoundingMode"
    fun setRoundingMode' m = (ctlRoundingMode (SOME m); ()) 
*)
    fun setRoundingMode' m = (Ccall(setRoundingMode,m); ())
    fun getRoundingMode'() = Ccall(getRoundingMode,0)

    fun setRoundingMode TO_NEAREST	= setRoundingMode' 0
      | setRoundingMode TO_ZERO		= setRoundingMode' 1
      | setRoundingMode TO_POSINF	= setRoundingMode' 2
      | setRoundingMode TO_NEGINF	= setRoundingMode' 3
    (* dummy arg *)
    fun getRoundingMode () = intToRM (getRoundingMode' ())

    type decimal_approx = {
	kind : float_class,
	sign : bool,
	digits : int list,
	exp : int
      }

    fun toString {kind, sign, digits, exp} = let
	  fun fmtExp 0 = []
	    | fmtExp i = ["E", Int.toString i]
	  fun fmtDigits ([], tail) = tail
	    | fmtDigits (d::r, tail) = (Int.toString d) :: fmtDigits(r, tail)
	  in
	    case (sign, kind, digits)
	     of (true, ZERO, _) => "~0.0"
	      | (false, ZERO, _) => "0.0"
	      | (true, NORMAL, []) => "~0.0"
	      | (true, SUBNORMAL, []) => "~0.0"
	      | (false, NORMAL, []) => "0.0"
	      | (false, SUBNORMAL, []) => "0.0"
	      | (true, NORMAL, _) =>
		  String.concat("~0." :: fmtDigits(digits, fmtExp exp))
	      | (true, SUBNORMAL, _) =>
		  String.concat("~0." :: fmtDigits(digits, fmtExp exp))
	      | (false, NORMAL, _) =>
		  String.concat("0." :: fmtDigits(digits, fmtExp exp))
	      | (false, SUBNORMAL, _) =>
		  String.concat("0." :: fmtDigits(digits, fmtExp exp))
	      | (true, INF, _) => "~inf"
	      | (false, INF, _) => "inf"
	      | (_, NAN _, []) => "nan"
	      | (_, NAN _, _) => String.concat("nan(" :: fmtDigits(digits, [")"]))
	    (* end case *)
	  end

(** TODO: implement fromString **)
    fun fromString s = NONE

  end;


(* real-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)



signature REAL =
  sig
    type real

    structure Math : MATH
      (* sharing type real = Math.real -- holds for TILT structures but non-standard *)

    val radix     : PreInt.int
    val precision : PreInt.int
	(* the number of digits (each 0..radix-1) in mantissa *)

    val maxFinite    : real   (* maximum finite number *)
(*** these cause problems on the alpha? ***)
    val minPos       : real   (* minimum non-zero positive number *)
    val minNormalPos : real   (* minimum non-zero normalized number *)

    val posInf : real
    val negInf : real

    val + : real * real -> real
    val - : real * real -> real
    val * : real * real -> real
    val / : real * real -> real
    val *+ : real * real * real -> real
    val *- : real * real * real -> real
    val ~ : real -> real

    val abs      : real -> real
    val min      : real * real -> real
    val max      : real * real -> real

    val sign     : real -> int
    val signBit  : real -> bool
    val sameSign : real * real -> bool
    val copySign : real * real -> real

    val compare : real * real -> order
    val compareReal : real * real -> IEEEReal.real_order

    val < : real * real -> bool
    val <= : real * real -> bool
    val > : real * real -> bool
    val >= : real * real -> bool

    val == : real * real -> bool
    val != : real * real -> bool
    val ?= : real * real -> bool
    val unordered : real * real -> bool

    val isFinite : real -> bool
    val isNan : real -> bool
    val isNormal : real -> bool

    val class : real -> IEEEReal.float_class

    val fmt  : StringCvt.realfmt -> real -> string
    val toString   : real -> string
    val fromString : string -> real option
    val scan : (char, 'a) StringCvt.reader -> (real, 'a) StringCvt.reader

    val toManExp : real -> {man: real, exp: int}
    val fromManExp : {man: real, exp: int} -> real

    val split : real -> {whole: real, frac: real}
    val realMod : real -> real

    val rem : real * real -> real
    val nextAfter  : real * real -> real
    val checkFloat : real -> real

    val realFloor : real -> real
    val realCeil  : real -> real
    val realTrunc : real -> real

    val floor : real -> PreInt.int
    val ceil  : real -> PreInt.int
    val trunc : real -> PreInt.int
    val round : real -> PreInt.int

    val toInt : IEEEReal.rounding_mode -> real -> int
    val toLargeInt : IEEEReal.rounding_mode -> real -> PreLargeInt.int

    val fromInt  : PreInt.int -> real
    val fromLargeInt  : PreLargeInt.int -> real

    val toLarge : real -> PreLargeReal.real
    val fromLarge: IEEEReal.rounding_mode -> PreLargeReal.real -> real

    val toDecimal   : real -> IEEEReal.decimal_approx
    val fromDecimal : IEEEReal.decimal_approx -> real

  end;

(* real-format.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Code for converting from real (IEEE 64-bit floating-point) to string.
 * This ought to be replaced with David Gay's conversion algorithm.
 *
 *)

structure RealFormat : sig

    val fmtReal : StringCvt.realfmt -> real -> string
(** The type should be:
    val fmtReal : StringCvt.realfmt -> LargeReal.real -> string
 **)

  end = struct
    val float_eq = TiltPrim.float_eq
    val float_neq = TiltPrim.float_neq
    val floor = TiltPrim.float2int
    val int32touint32 = TiltPrim.int32touint32
    val unsafe_vsub = TiltPrim.unsafe_vsub
	
    infix 4 == !=
(*
    val op +  = InlineT.Real64.+
    val op -  = InlineT.Real64.-
    val op *  = InlineT.Real64.*
    val op /  = InlineT.Real64./
    val op ~  = InlineT.Real64.~
    val op <  = InlineT.Real64.<
    val op >  = InlineT.Real64.>
    val op >= = InlineT.Real64.>=
    val op == = InlineT.Real64.==
    val floor = Assembly.A.floor
    val real  = InlineT.real
   structure I = InlineT.DfltInt *)

    val plus : int * int -> int = op +
    val minus : int * int -> int = op -
    val negate : int -> int = ~
    val gt : int * int -> bool = op >
    val lt : int * int -> bool = op <
    val gte : int * int -> bool = op >=
    val lte : int * int -> bool = op <=

    val ~ : real -> real = ~
    val op + : real * real -> real = op +
    val op - : real * real -> real = op -
    val op * : real * real -> real = op *
    val op / : real * real -> real = op /
    val op >  : real * real -> bool = op >
    val op <  : real * real -> bool = op <
    val op >= : real * real -> bool = op >=
    val op <= : real * real -> bool = op <=
    val op == : real * real -> bool = float_eq
    val op != : real * real -> bool = float_neq


    val op^  = String.^
    val implode = String.implode
    val concat = String.concat
    val size = String.size


    fun inc i = plus(i, 1)
    fun dec i = minus(i, 1)
    fun min (i, j) = if lt(i, j) then i else j
    fun max (i, j) = if gt(i, j) then i else j

    val atoi = (NumFormat.fmtInt StringCvt.DEC)

    fun zeroLPad (s, wid) = StringCvt.padLeft #"0" wid s
    fun zeroRPad (s, wid) = StringCvt.padRight #"0" wid s

    fun mkDigit d = unsafe_vsub("0123456789abcdef", int32touint32 d)

  (* decompose a non-zero real into a list of at most maxPrec significant digits
   * (the first digit non-zero), and integer exponent. The return value
   *   (a::b::c..., exp)
   * is produced from real argument
   *   a.bc... * (10 ^^ exp)
   * If the list would consist of all 9's, the list consisting of 1 followed by
   * all 0's is returned instead.
   *)
    val maxPrec = 15
    fun decompose (f, e, precisionFn) = let
	  fun scaleUp (x, e) =
		if (x < 1.0) then scaleUp(10.0*x, dec e) else (x, e)
	  fun scaleDn (x, e) =
		if (x >= 10.0) then scaleDn(0.1*x, inc e) else (x, e)
	  fun mkdigits (f, 0) = ([], if f < 5.0 then 0 else 1)
	    | mkdigits (f, i) = let 
		val d = floor f
		val (digits, carry) = mkdigits (10.0 * (f - real d), dec i)
		val (digit, c) = (case (d, carry)
		       of (9, 1) => (0, 1)
			| _ => (plus(d, carry), 0)
		      (* end case *))
		in
		  (digit::digits, c)
		end
	  val (f, e) = if (f < 1.0)
		  then scaleUp (f, e)
		else if (f >= 10.0)
		  then scaleDn (f, e)
		  else (f, e)
	  val (digits, carry) = mkdigits(f, max(0, min(precisionFn e, maxPrec)))
	  in
	    case carry
	     of 0 => (digits, e)
	      | _ => (1::digits, inc e)
	    (* end case *)
          end

    fun realFFormat (r, prec) = let
	  fun pf e = plus(e, inc prec)
	  fun rtoa (digits, e) = let
		fun doFrac (_, 0, n, l) = PreString.revImplode(n, l)
		  | doFrac ([], p, n, l) = doFrac([], dec p, inc n, #"0"::l)
		  | doFrac (hd::tl, p, n, l) =
		      doFrac(tl, dec p, inc n, (mkDigit hd) :: l)
		fun doWhole ([], e, n, l) = if gte(e, 0)
			then doWhole ([], dec e, inc n, #"0" :: l)
		      else if prec = 0
			then PreString.revImplode(n, l)
			else doFrac ([], prec, inc n, #"." :: l)
		  | doWhole (arg as (hd::tl), e, n, l) = if gte(e, 0)
			then doWhole(tl, dec e, inc n, (mkDigit hd) :: l)
		      else if prec = 0
			then PreString.revImplode(n, l)
			else doFrac(arg, prec, inc n, #"." :: l)
		fun doZeros (_, 0, n, l) = PreString.revImplode(n, l)
		  | doZeros (1, p, n, l) = doFrac(digits, p, n, l)
		  | doZeros (e, p, n, l) = doZeros(dec e, dec p, inc n, #"0" :: l)
		in
		  if gte(e, 0)
		    then doWhole(digits, e, 0, [])
		  else if (prec = 0)
		    then "0"
		    else doZeros (negate e, prec, 2, [#".", #"0"])
		end
	  in
	    if lt(prec, 0) then raise General.Size else ();
	    if (r < 0.0)
	      then {sign = "~", mantissa = rtoa(decompose(~r, 0, pf))}
	    else if (r > 0.0)
	      then {sign="", mantissa = rtoa(decompose(r, 0, pf))}
	    else if (prec = 0)
	      then {sign="", mantissa = "0"}
	      else {sign="", mantissa = zeroRPad("0.", plus(prec, 2))}
	  end (* realFFormat *)

    fun realEFormat (r, prec) = let
	  fun pf _ = inc prec
	  fun rtoa (sign, (digits, e)) = let
		fun mkRes (m, e) = {sign = sign, mantissa = m, exp = e}
		fun doFrac (_, 0, l)  = implode(List.rev l)
		  | doFrac ([], n, l) = zeroRPad(implode(List.rev l), n)
		  | doFrac (hd::tl, n, l) = doFrac (tl, dec n, (mkDigit hd) :: l)
		in
		  if (prec = 0)
		    then mkRes(String.str(mkDigit(List.hd digits)), e)
		    else mkRes(
		      doFrac(List.tl digits, prec, [#".", mkDigit(List.hd digits)]), e)
		end
	  in
	    if lt(prec, 0) then raise General.Size else ();
	    if (r < 0.0)
	      then rtoa ("~", decompose(~r, 0, pf))
	    else if (r > 0.0)
	      then rtoa ("", decompose(r, 0, pf))
	    else if (prec = 0)
	      then {sign = "", mantissa = "0", exp = 0}
	      else {sign = "", mantissa = zeroRPad("0.", plus(prec, 2)), exp = 0}
	  end (* realEFormat *)

    fun realGFormat (r, prec) = let
	  fun pf _ = prec
	  fun rtoa (sign, (digits, e)) = let
		fun mkRes (w, f, e) = {sign = sign, whole = w, frac = f, exp = e}
		fun doFrac [] = []
		  | doFrac (0::tl) = (case doFrac tl
		       of [] => []
			| rest => #"0" :: rest
		      (* end case *))
		  | doFrac (hd::tl) = (mkDigit hd) :: (doFrac tl)
		fun doWhole ([], e, wh) =
		      if gte(e, 0)
			then doWhole([], dec e, #"0"::wh)
			else mkRes(implode(List.rev wh), "", NONE)
		  | doWhole (arg as (hd::tl), e, wh) =
		      if gte(e, 0)
			then doWhole(tl, dec e, (mkDigit hd)::wh)
			else mkRes(implode(List.rev wh), implode(doFrac arg), NONE)
		in
		  if lt(e, ~4) orelse gte(e, prec)
		    then mkRes(
		      String.str(mkDigit(List.hd digits)),
		      implode(doFrac(List.tl digits)), SOME e)
		  else if gte(e, 0)
		    then doWhole(digits, e, [])
		    else let
		      val frac = implode(doFrac digits)
		      in
			mkRes("0", zeroLPad(frac, plus(size frac, minus(~1, e))), NONE)
		      end
		end
	  in
	    if lt(prec, 1) then raise General.Size else ();
	    if (r < 0.0)
	      then rtoa("~", decompose(~r, 0, pf))
	    else if (r > 0.0)
	      then rtoa("", decompose(r, 0, pf))
	      else {sign="", whole="0", frac="", exp=NONE}
	  end (* realGFormat *)

   val infinity = let fun bigger x = let val y = x*x 
				     in if y>x then bigger y else x
				     end
                   in bigger 100.0
                  end

   fun fmtInfNan x =
        if x==infinity then "inf"
        else if x == ~infinity then "~inf"
        else "nan"

  (* convert a real number to a string of the form [~]d.dddE[~]dd, where
   * the precision (number of fractional digits) is specified by the
   * second argument.
   *)
    fun realToSciStr prec r = 
	if ~infinity < r andalso r < infinity
	then let
	  val {sign, mantissa, exp} = realEFormat (r, prec)
	  in
	    concat[sign, mantissa, "E", atoi exp]
	  end
        else fmtInfNan r

  (* convert a real number to a string of the form [~]ddd.ddd, where
   * the precision (number of fractional digits) is specified by the
   * second argument.
   *)
    fun realToFixStr prec x = 
	if ~infinity < x andalso x < infinity
	then let
	  val {sign, mantissa} = realFFormat (x, prec)
	  in
	    sign^mantissa
	  end
        else fmtInfNan x

      fun realToGenStr prec r = 
	if ~infinity < r andalso r < infinity
	then let
  	  val {sign, whole, frac, exp} = realGFormat(r, prec)
 	  val (frac,expStr) = (case exp
 		 of NONE => if (frac = "")
		      then (".0", "")
		      else ("." ^ frac, "")
 		  | (SOME e) => let
		      val expStr = if lt(e, 0)
			    then "e~" ^ zeroLPad(atoi(negate e), 2)
			    else "e" ^ zeroLPad(atoi e, 2)
 		      in
 			((if (frac = "") then "" else ("." ^ frac)), expStr)
 		      end
  		(* end case *))
  	  in
  	    concat[sign, whole, frac, expStr]
  	  end
        else fmtInfNan r

    fun fmtReal (StringCvt.SCI NONE) = realToSciStr 6
      | fmtReal (StringCvt.SCI(SOME prec)) = realToSciStr prec
      | fmtReal (StringCvt.FIX NONE) = realToFixStr 6
      | fmtReal (StringCvt.FIX(SOME prec)) = realToFixStr prec
      | fmtReal (StringCvt.GEN NONE) = realToGenStr 12
      | fmtReal (StringCvt.GEN(SOME prec)) = realToGenStr prec

  end

(* real64.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure Real64 :> REAL where type real = real
			   and type Math.real = real = 
  struct
    val abs_float = TiltPrim.fabs
    val float_eq = TiltPrim.float_eq
    val float_neq = TiltPrim.float_neq
(*    structure I = InlineT.DfltInt *)

    structure Math = Math64
    val real_logb  : real -> int = fn arg => Ccall(real_logb, arg)

    infix 4 == !=
    type real = real

    val plus : int * int -> int = op +
    val minus : int * int -> int = op -
    val negate : int -> int = ~
    val gt : int * int -> bool = op >
    val lt : int * int -> bool = op <

    val ~ : real -> real = ~
    val op + : real * real -> real = op +
    val op - : real * real -> real = op -
    val op * : real * real -> real = op *
    val op / : real * real -> real = op /
    fun *+(a,b,c) = a*b+c
    fun *-(a,b,c) = a*b-c
	
    val op >  : real * real -> bool = op >
    val op <  : real * real -> bool = op <
    val op >= : real * real -> bool = op >=
    val op <= : real * real -> bool = op <=
    val op == : real * real -> bool = float_eq
    val op != : real * real -> bool = float_neq

    fun unordered(x,y) = Bool.not(x>y orelse x <= y)
    fun ?= (x, y) = (x == y) orelse unordered(x, y)

    fun real_scalb (x, k) = raise TiltExn.LibFail "scalb and real_scalb not implemented: multiarg C fun..."

  (* The next three values are computed laboriously, partly to
   * avoid problems with inaccurate string->float conversions
   * in the compiler itself.
   *)
    val maxFinite = let
	  fun f(x,i) = if i=1023 then x else f(x*2.0, plus(i, 1))
	  val y = f(1.0,0)
	  fun g(z, y, 0) = z
	    | g(z, y, i) = g(z+y, y*0.5, minus(i, 1))
	  in
	    g(0.0,y,53)
	  end

    val minNormalPos = let
	  fun f(x) = let
		val y = x * 0.5
		in
		  if real_logb y = ~1023 then x else f y
		end
	  in
	    f 1.0
	  end

    val minPos = let
	  fun f(x) = let
		val y = x * 0.5
		in
		  if y == 0.0 then x else f y
                end
	  in
	    f minNormalPos
	  end


    val posInf = maxFinite * maxFinite
    val negInf = ~posInf

    fun isFinite x = negInf < x andalso x < posInf
    fun isNan x = Bool.not(x==x)
    fun isNormal x = (case real_logb x
	   of ~1023 => (x != 0.0)
	    | 1024 => false
	    | _ => true
	  (* end case *))

    local
	val SOME minInt = Int32.minInt
	val minInt = TiltPrim.int2float minInt
	val minInt' = minInt - 1.0
	    
	val SOME maxInt = Int32.maxInt
	val maxInt = TiltPrim.int2float maxInt
	val maxInt' = maxInt + 1.0

	fun wrap f (r : real) : int =
	    if r == 0.0 then 0
	    else if isNan r then raise General.Domain
		 else if isNormal r then f r
		      else raise General.Overflow
    in
	val floor = wrap (fn r =>
			  if r < minInt orelse r >= maxInt'
			      then raise General.Overflow
			  else
			      let val a = TiltPrim.float2int r
			      in  if (TiltPrim.int2float a) <= r then a
				  else TiltPrim.iminus(a,1)
			      end)
	val trunc = wrap (fn r =>
			  if r <= minInt' orelse r >= maxInt'
			      then raise General.Overflow
			  else TiltPrim.float2int r)
	val ceil = wrap (fn r =>
			 if r <= minInt' orelse r > maxInt
			     then raise General.Overflow
			 else
			     let val a = TiltPrim.float2int r
			     in  if (TiltPrim.int2float a) >= r then a
				 else TiltPrim.iplus(a,1)
			     end)
	fun round r = floor (r + 0.5)
    end
    val abs : real -> real = abs_float
    val fromInt : int -> real = real

    (* bug: operates correctly but slowly *)
    fun fromLargeInt(x : Int32.int) =
       let val i = Int32.quot(x,2)
           val j = Int32.-(x,Int32.+(i,i))
           val i' = Int32.toInt i
	   val j' = Int32.toInt j
        in fromInt(i')*2.0+fromInt(j')
       end    

     (* bug: only one rounding mode implemented *)
    fun toInt IEEEReal.TO_NEGINF = floor
      | toInt _ = raise TiltExn.LibFail "toInt supports only NEGINF rounding mode now"

      (* bug: doesn't support full range of large ints *)
    fun toLargeInt mode x = Int32.fromInt(toInt mode x)

    fun toLarge x = x
    fun fromLarge _ x = x       

    fun sign x = if (x < 0.0) then ~1 else if (x > 0.0) then 1 
                  else if isNan x then raise General.Domain else 0
    fun signBit x = (* Bug: negative zero not handled properly *)
	real_scalb(x, negate(real_logb x)) < 0.0

    fun sameSign (x, y) = signBit x = signBit y

    fun copySign(x,y) = (* may not work if x is Nan *)
           if sameSign(x,y) then x else ~x

    fun compare(x,y) = if x<y then General.LESS else if x>y then General.GREATER
                       else if x == y then General.EQUAL 
			    else raise IEEEReal.Unordered
    
    fun compareReal(x,y) = 
           if x<y then IEEEReal.LESS else if x>y then IEEEReal.GREATER
                       else if x == y then IEEEReal.EQUAL 
			    else IEEEReal.UNORDERED
    

(** This proably needs to be reorganized **)
    fun class x =  (* does not distinguish between quiet and signalling NaN *)
      if signBit x
       then if x>negInf then if x == 0.0 then IEEEReal.ZERO
	                     else if real_logb x = ~1023
			          then IEEEReal.SUBNORMAL
			          else IEEEReal.NORMAL
	                else if x==x then IEEEReal.INF
			             else IEEEReal.NAN IEEEReal.QUIET
       else if x<posInf then if x == 0.0 then IEEEReal.ZERO
	                     else if real_logb x = ~1023
			          then IEEEReal.SUBNORMAL
			          else IEEEReal.NORMAL
	                else if x==x then IEEEReal.INF
			             else IEEEReal.NAN IEEEReal.QUIET

    val radix = 2
    val precision = 52

    val two_to_the_54 = 18014398509481984.0

    val two_to_the_neg_1000 =
      let fun f(i,x) = if i=0 then x else f(minus(i,1), x*0.5)
       in f(1000, 1.0)
      end

    fun toManExp x = 
      case real_logb x
	of ~1023 => if x==0.0 then {man=x,exp=0}
		    else let val {man=m,exp=e} = toManExp(x*1048576.0)
		              in {man=m,exp=minus(e,20)}
			 end
         | 1024 => {man=x,exp=0}
         | i => {man=real_scalb(x,negate i),exp=i}

    fun fromManExp {man=m,exp=e:int} =
      if (m >= 0.5 andalso m <= 1.0  orelse m <= ~0.5 andalso m >= ~1.0)
	then if gt(e, 1020)
	  then if gt(e, 1050) then if m>0.0 then posInf else negInf
	       else let fun f(i,x) = if i=0 then x else f(minus(i,1),x+x)
		       in f(minus(e,1020),  real_scalb(m,1020))
		      end
	  else if lt(e, negate 1020)
	       then if lt(e, negate 1200) then 0.0
		 else let fun f(i,x) = if i=0 then x else f(minus(i,1), x*0.5)
		       in f(minus(1020,e), real_scalb(m,negate 1020))
		      end
	       else real_scalb(m,e)  (* This is the common case! *)
      else let val {man=m',exp=e'} = toManExp m
            in fromManExp{man=m', exp=plus(e',e)}
           end

  (* This is the IEEE double-precision maxint *)
    val maxint = 4503599627370496.0


    local
    (* realround mode x returns x rounded to the nearest integer using the
     * given rounding mode.
     * May be applied to inf's and nan's.
     *)
      fun realround mode x = let
            val saveMode = IEEEReal.getRoundingMode ()
            in
              IEEEReal.setRoundingMode mode;
              if x>=0.0 then x+maxint-maxint else x-maxint+maxint
                before IEEEReal.setRoundingMode saveMode
            end
    in
    val realFloor = realround IEEEReal.TO_NEGINF
    val realCeil = realround IEEEReal.TO_POSINF
    val realTrunc = realround IEEEReal.TO_ZERO
    end
(*
    fun realFloor _ = raise TiltExn.LibFail "Real.realFloor unimplemented"
    fun realCeil _ = raise TiltExn.LibFail "Real.realCeil unimplemented"
    fun realTrunc _ = raise TiltExn.LibFail "Real.realTrunc unimplemented"
*)

  (* realround(x) returns x rounded to some nearby integer, almost always
   * the nearest integer.
   *  May be applied to inf's and nan's.
   *)
    fun realround x = if x>=0.0 then x+maxint-maxint else x-maxint+maxint

  (* whole and split could be implemented more efficiently if we had
   * control over the rounding mode; but for now we don't.
   *)
    fun whole x = if x>0.0 
		    then if x > 0.5
		      then x-0.5+maxint-maxint
		      else whole(x+1.0)-1.0
	          else if x<0.0
                    then if x < ~0.5
		      then x+0.5-maxint+maxint
		      else whole(x-1.0)+1.0
	          else x

    fun split x = let val w = whole x 
                      val f = x-w
		   in if abs(f)==1.0
		     then {whole=w+f,frac=0.0}
		     else {whole=w, frac=f} 
		  end

    fun realMod x = let
	  val f = x - whole x
	  in
	    if abs f == 1.0 then 0.0 else f
	  end
    nonfix rem
    fun rem(x,y) = y * #frac(split(x/y))

    fun checkFloat x = if x>negInf andalso x<posInf then x
                       else if isNan x then raise General.Div
			 else raise General.Overflow

(** NOTE logb and scalb are also defined in math64.sml; do we need both??? **)
    fun logb x = (case real_logb x
	   of ~1023 => (* denormalized number *)
		minus(real_logb(x * two_to_the_54), 54)
	    | i => i
	  (* end case *))

(*
  (* This function is IEEE double-precision specific;
     we do not apply it to inf's and nan's *)
    fun scalb (x, k) = if lessu(I.+(k,1022),2046)
	  then Assembly.A.scalb(x,k)
          else let val k1 = I.div(k, 2)
	    in
	      scalb(scalb(x, k1), I.-(k, k1))
	    end
*)
    fun scalb (x, k) = raise TiltExn.LibFail "scalb and real_scalb not implemented: multiarg C fun..."
(*
if lt(plus(k,1022),2046)
	  then Assembly.A.scalb(x,k)
          else let val k1 = div(k, 2)
	    in
	      scalb(scalb(x, k1), minus(k, k1))
	    end
*)
  
    fun nextAfter _ = raise TiltExn.LibFail "Real.nextAfter unimplemented"

    fun min(x,y) = if x<y orelse isNan y then x else y
    fun max(x,y) = if x>y orelse isNan y then x else y

    fun toDecimal _ = raise TiltExn.LibFail "Real.toDecimal unimplemented"
    fun fromDecimal _ = raise TiltExn.LibFail "Real.fromDecimal unimplemented"

    val fmt = RealFormat.fmtReal
    val toString = fmt (StringCvt.GEN NONE)
    val scan = NumScan.scanReal
    val fromString = StringCvt.scanString scan

  end (* Real64 *)

structure Real = Real64
structure LargeReal = Real64
(* word-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)


signature WORD = 
  sig
    eqtype word

    val wordSize : int

    val toLargeWord   : word -> PreLargeWord.word
    val toLargeWordX  : word -> PreLargeWord.word
    val fromLargeWord : PreLargeWord.word -> word

    val toLargeInt   : word -> PreLargeInt.int
    val toLargeIntX  : word -> PreLargeInt.int
    val fromLargeInt : PreLargeInt.int -> word

    val toInt   : word -> int
    val toIntX  : word -> int
    val fromInt : int -> word

    val orb  : word * word -> word
    val xorb : word * word -> word
    val andb : word * word -> word
    val notb : word -> word

    val << : word * PreWord.word -> word
    val >> : word * PreWord.word -> word
    val ~>> : word * PreWord.word -> word

    val + : word * word -> word
    val - : word * word -> word
    val * : word * word -> word
    val div : word * word -> word
    val mod : word * word -> word

    val compare : word * word -> order
    val >  : word * word -> bool
    val <  : word * word -> bool
    val >= : word * word -> bool
    val <= : word * word -> bool

    val min : word * word -> word
    val max : word * word -> word

    val fmt : StringCvt.radix -> word -> string
    val toString   : word -> string
    val fromString : string -> word option
    val scan : StringCvt.radix -> (char, 'a) StringCvt.reader -> (word, 'a) StringCvt.reader

  end;


(* word8.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure Word8 :> WORD where type word = TiltPrim.uint8 =
  struct
    val !! = TiltPrim.!!
    val && = TiltPrim.&&
    val << = TiltPrim.<<
    val >> = TiltPrim.>>
    val ^^ = TiltPrim.^^
    val || = TiltPrim.||
    val ~>> = TiltPrim.~>>
	
    val andbyte = TiltPrim.andbyte
    val orbyte = TiltPrim.orbyte
	
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
    val uint32touint8 = TiltPrim.uint32touint8
    val uint8toint32 = TiltPrim.uint8toint32
    val uint8touint32 = TiltPrim.uint8touint32
	
    val ugt = TiltPrim.ugt
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
    val ulte = TiltPrim.ulte
	
    val udiv = TiltPrim.udiv
    val uminus = TiltPrim.uminus
    val umod = TiltPrim.umod
    val uplus = TiltPrim.uplus
	
    type word32 = TiltPrim.uint32
    type word8 = TiltPrim.uint8
(*
    structure W8 = InlineT.Word8
    structure W31 = InlineT.Word31
    structure LW = Word32
*)
    type word = word8

    val wordMask = 0w255
    val wordSize = 8
    val wordSizeW = 0w8
    val wordShift = uminus(0w31, wordSizeW)
    val wordShifti = 31 - wordSize


    val toi32 = uint32toint32
    val tow32 = uint8touint32
    val tow8 = uint32touint8
    fun adapt arg = tow8(&& (arg, 0wxFF))

    fun sextend (w8 : word8) : word32 = 
	let val w32 = uint8touint32 w8
	    val neg = &&(w32, 0w128)
	    val mask = int32touint32(~>>(uint32toint32(<<(neg, 24)), 23))
	in  ||(w32, mask)
	end

    val toInt   : word -> int = uint8toint32
    fun toIntX  (x : word) : int = uint32toint32(sextend x)
    fun fromInt (x : int) : word = uint32touint8(&& (wordMask, int32touint32 x))

    val toLargeInt   : word -> int = toInt
    val toLargeIntX  : word -> int = toIntX
    val fromLargeInt : int -> word = fromInt

    val toLargeWord : word -> PreLargeWord.word = uint8touint32
    fun toLargeWordX (x : word) : PreLargeWord.word = sextend x
    fun fromLargeWord (x : PreLargeWord.word) : word = uint32touint8(&& (x, wordMask))

(*
    val toInt   : word -> int = W8.toInt
    val toIntX  : word -> int = W8.toIntX
    val fromInt : int -> word = W8.fromInt

    val toLargeWord : word -> PreLargeWord.word = W8.toLargeWord
    val toLargeWordX = W8.toLargeWordX
    val fromLargeWord = W8.fromLargeWord

    val toLargeInt  : word -> LargeInt.int = LW.toLargeInt o toLargeWord
    val toLargeIntX : word -> LargeInt.int = W8.toLargeIntX
    val fromLargeInt: LargeInt.int -> word = W8.fromLargeInt
*)



  (** These should be inline functions **)
    fun lshift (w : word, k) = adapt(if ulte(wordSizeW, k)
					 then 0w0
				     else <<(tow32 w, toi32 k))
    fun rshiftl (w : word, k) = adapt(if ulte(wordSizeW, k)
					  then 0w0
				      else >> (tow32 w, toi32 k))
    fun rshifta (w : word, k) = adapt(int32touint32
				      (if ulte(wordSizeW, k)
					   then ~>>(toi32(<< (tow32 w, wordShifti)), 31)
				       else ~>>(toi32 (<< (tow32 w, wordShifti)),
						toi32 (uplus(wordShift, k)))))
    nonfix << >> ~>> + - * div mod <= = >= < >
    val << = lshift
    val >> = rshiftl
    val ~>> = rshifta

    val orb  : word * word -> word = orbyte
    val andb : word * word -> word = andbyte
    fun xorb (x : word, y : word) : word = adapt(^^(tow32 x, tow32 y))
    fun notb (x : word) : word = adapt (!! (tow32 x))

    fun + (x : word, y : word) : word = adapt(uplus(tow32 x, tow32 y))
    fun - (x : word, y : word) : word = adapt(uminus(tow32 x, tow32 y))
    fun * (x : word, y : word) : word = adapt(uplus(tow32 x, tow32 y))
    fun div (x : word, y : word) : word = tow8(udiv(tow32 x, tow32 y))
    fun mod (x : word, y : word) : word = tow8(umod(tow32 x, tow32 y))

    fun compare (w1, w2) =
      let val w1 = tow32 w1
	  val w2 = tow32 w2
      in if (ult(w1, w2)) then LESS
	 else if (ugt(w1, w2)) then GREATER
	      else EQUAL
      end

    fun > (x : word, y: word) = ugt(tow32 x, tow32 y)
    fun >= (x : word, y: word) = ugte(tow32 x, tow32 y)
    fun < (x : word, y: word) = ult(tow32 x, tow32 y)
    fun <= (x : word, y: word) = ulte(tow32 x, tow32 y)

    fun min (w1, w2) = if <(w1,w2) then w1 else w2
    fun max (w1, w2) = if >(w1,w2) then w1 else w2

    fun fmt radix = (NumFormat.fmtWord radix) o toLargeWord 
    val toString = fmt StringCvt.HEX

    fun scan radix = let
	  val scanLarge = NumScan.scanWord radix
	  fun scan getc cs = (case (scanLarge getc cs)
		 of NONE => NONE
		  | (SOME(w, cs')) => if ugt(w, 0w255)
		      then raise Overflow
		      else SOME(fromLargeWord w, cs')
		(* end case *))
	  in
	    scan
	  end
    val fromString = StringCvt.scanString (scan StringCvt.HEX)

  end  (* structure Word8 *)


(* word32.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)


structure Word32 :> WORD where type word = word =
  struct
    val !! = TiltPrim.!!
    val && = TiltPrim.&&
    val << = TiltPrim.<<
    val >> = TiltPrim.>>
    val ^^ = TiltPrim.^^
    val || = TiltPrim.||
    val ~>> = TiltPrim.~>>
	
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
    val ugt = TiltPrim.ugt
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
    val ulte = TiltPrim.ulte
	
    val udiv = TiltPrim.udiv
    val umod = TiltPrim.umod
    val uminus = TiltPrim.uminus
    val umult = TiltPrim.umult
    val uplus = TiltPrim.uplus

    type word = TiltPrim.uint32

    val wordSize = 32
    val wordSizeW = 0w32

    (* the X versions treat the word as signed *)
    fun toInt   (x : word) : int = if (ult(x,0wx7fffffff)) 
				       then uint32toint32 x else raise Overflow
    fun toIntX  (x : word) : int = uint32toint32 x
    fun fromInt (x : int) : word = int32touint32 x

    val toLargeInt   : word -> int = toInt
    val toLargeIntX  : word -> int = toIntX
    val fromLargeInt : int -> word = fromInt

    fun toLargeWord (x : word) : PreLargeWord.word = x
    fun toLargeWordX (x : word) : PreLargeWord.word = x
    fun fromLargeWord (x : PreLargeWord.word) : word = x

    val toi32 = uint32toint32



  (** These should be inline functions **)
    fun lshift (w : word, k) = if ulte(wordSizeW, k)
					 then 0w0
				     else <<(w, toi32 k)
    fun rshiftl (w : word, k) = if ulte(wordSizeW, k)
					  then 0w0
				      else >>(w, toi32 k)
    fun rshifta (w : word, k) = int32touint32
				      (if ulte(wordSizeW, k)
					   then ~>>(toi32 w, 31)
				       else ~>>(toi32 w, toi32 k))

    nonfix << >> ~>> + - * div mod <= = >= < > || && ^^
    val << = lshift
    val >> = rshiftl
    val ~>> = rshifta

    val orb  : word * word -> word = ||
    val xorb  : word * word -> word = ^^
    val andb : word * word -> word = &&
    val notb : word -> word = !! 

    val +  : (word * word -> word) = uplus
    val -  : (word * word -> word) = uminus
    val *  : (word * word -> word) = umult
    val div  : (word * word -> word) = udiv
    val mod  : (word * word -> word) = umod


    fun compare (w1, w2) =
      if (ult(w1, w2)) then LESS
	 else if (ugt(w1, w2)) then GREATER
	      else EQUAL

    val >  : (word * word -> bool) = ugt
    val >=  : (word * word -> bool) = ugte
    val <  : (word * word -> bool) = ult
    val <=  : (word * word -> bool) = ulte

    fun min (w1, w2) = if <(w1,w2) then w1 else w2
    fun max (w1, w2) = if >(w1,w2) then w1 else w2

    fun fmt radix = (NumFormat.fmtWord radix)
    val toString = fmt StringCvt.HEX

    val scan = NumScan.scanWord
    val fromString = StringCvt.scanString (NumScan.scanWord StringCvt.HEX)

  end  (* structure Word32 *)
structure Word = Word32
structure LargeWord = Word32
structure SysWord = Word32

(* Word31.word is kept abstract.  It would be bad if
 *    val x : Word31.word = 0wxFFFFFFFF;
 * could typecheck.
 *)

structure Word31 :> WORD =
struct

    structure W = Word32

    type word = W.word                  (* invariant: bit 31 is 0 *)

    val wordSize = 31

    fun bit30 (w : word) = W.andb (0wx40000000, w)
    fun bit31 (w : word) = W.andb (0wx80000000, w)

    fun extend w = W.orb(w, W.<<(bit30 w, 0w1))
    fun drop w = W.andb(0wx7fffffff, w)

    fun trapOverflow (w : word) = if bit31 w = 0w0 then w
				  else raise Overflow

    val toLargeWord = W.toLargeWord
    val toLargeWordX = W.toLargeWordX o extend
    val fromLargeWord = drop o W.fromLargeWord

    val toLargeInt = W.toLargeInt
    val toLargeIntX = W.toLargeIntX o extend
    val fromLargeInt = drop o W.fromLargeInt

    val toInt = W.toInt
    val toIntX = W.toInt o extend
    val fromInt = drop o W.fromInt

    val orb = W.orb
    val xorb = W.xorb
    val andb = W.andb
    val notb = drop o W.notb

    val << = drop o W.<<
    val >> = W.>>
    fun ~>> (i, n) = drop (W.~>> (extend i, n))

    val op+ = drop o W.+
    val op- = drop o W.-
    val op* = drop o W.*
    val op div = W.div
    val op mod = W.mod

    val compare = W.compare
    val op>  = W.>
    val op<  = W.<
    val op>= = W.>=
    val op<= = W.<=

    val max = W.max
    val min = W.min
	
    val fmt = W.fmt
    val toString = W.toString

    fun fromString s = (case W.fromString s
			  of NONE => NONE
			   | SOME r => SOME (trapOverflow r))
	
    fun scan radix getc src = (case W.scan radix getc src
				 of NONE => NONE
				  | SOME (r, rest) => SOME (trapOverflow r, rest))
end
(* array-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature ARRAY =
  sig
    eqtype 'a array
    type 'a vector

    val maxLen   : int

    val array    : int * 'a -> 'a array
    val fromList : 'a list -> 'a array
    val tabulate : int * (int -> 'a) -> 'a array

    val length   : 'a array -> int
    val sub      : 'a array * int -> 'a
    val update   : 'a array * int * 'a -> unit
    val extract  : 'a array * int * int option -> 'a vector

    val copy : {
	    src : 'a array, si : int, len : int option,
	    dst : 'a array, di : int
	  } -> unit
    val copyVec : {
	    src : 'a vector, si : int, len : int option,
	    dst : 'a array, di : int
	  } -> unit

    val appi    : (int * 'a -> unit) -> 'a array * int * int option -> unit
    val app     : ('a -> unit) -> 'a array -> unit
	
    val foldli  : (int * 'a * 'b -> 'b) -> 'b -> 'a array * int * int option -> 'b
    val foldri  : (int * 'a * 'b -> 'b) -> 'b -> 'a array * int * int option -> 'b
	
    val foldl   : ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
    val foldr   : ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
	
    val modifyi : (int * 'a -> 'a) -> 'a array * int * int option -> unit
    val modify  : ('a -> 'a) -> 'a array -> unit

  end

(* array.sml
 *
 * COPYRIGHT (c) 1994 AT&T Bell Laboratories.
 *
 *)

structure Array :> ARRAY where type 'a array = 'a array
			   and type 'a vector = 'a vector =
  struct
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32

    val array_length = TiltPrim.array_length
    val empty_array = TiltPrim.empty_array
    val empty_vector = TiltPrim.empty_vector
    val unsafe_array = TiltPrim.unsafe_array
    val unsafe_sub = TiltPrim.unsafe_sub
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_vsub = TiltPrim.unsafe_vsub
    val vector_length = TiltPrim.vector_length

    val unsafe_array2vector = TiltPrim.unsafe_array2vector

    val ugt = TiltPrim.ugt
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
    val ulte = TiltPrim.ulte

    val uminus = TiltPrim.uminus
    val uplus = TiltPrim.uplus

    val maxLen = PreVector.maxLen
    val checkLen = PreVector.checkLen
    val fromList' = PreVector.arrayFromList'
    val fromList = PreVector.arrayFromList

    type 'a array = 'a array
    type 'a vector = 'a vector

    val array0 : 'a array = empty_array
    val vector0 : 'a vector = empty_vector

    fun array (0, _) = array0
      | array (n, init) = (checkLen n;
			   unsafe_array(int32touint32 n, init))

    fun rev ([], l) = l
      | rev (x::r, l) = rev (r, x::l)

    fun tabulate (0, _) = array0
      | tabulate (n, f) : 'a array = 
          let val a = array(n, f 0)
	      val n = int32touint32 n
              fun tab i = 
                if ult(i,n) then (unsafe_update(a, i, f (uint32toint32 i)); 
				  tab(uplus(i,0w1)))
                else a
           in tab 0w1
          end

    fun length (ar : 'a array) : int = uint32toint32(array_length ar)
    fun sub (a : 'a array, index :int) : 'a =
	let val index = int32touint32 index
	in  if (ugte(index, array_length a))
		then raise Subscript
	    else unsafe_sub(a,index)
	end
    fun update (a, index :int, e : 'a) : unit =
	let val index = int32touint32 index
	in  if (ugte(index, array_length a))
		then raise Subscript
	    else unsafe_update(a,index,e)
	end

    fun extract (v, base : int, optLen : int option) = let
	  val len = length v
	  fun newVec (n : int) = let
		fun tab (~1, l) = unsafe_array2vector(fromList'(n,l))
		  | tab (i, l) = tab(i-1, (unsafe_sub(v, int32touint32(base+i)))::l)
		in  tab (n-1, [])
		end
	  in
	    case (base, optLen)
	     of (0, NONE) => if (0 < len) then newVec len else vector0
	      | (_, SOME 0) => if ((base < 0) orelse (len < base))
		  then raise General.Subscript
		  else vector0
	      | (_, NONE) => if ((base < 0) orelse (len < base))
		    then raise General.Subscript
		  else if (len = base)
		    then vector0
		    else newVec (len - base)
	      | (_, SOME n) =>
		  if ((base < 0) orelse (n < 0) orelse (len < (base+n)))
		    then raise General.Subscript
		    else newVec n
	    (* end case *)
	  end

    fun copy {src, si=si', len, dst, di} = 
        let

            val (sstop', dstop') = 
                let val srcLen = length src
                in  case len
                    of NONE => if ((si' < 0) orelse (srcLen < si'))
                                   then raise Subscript
                               else (srcLen, di+srcLen-si')
                  | (SOME n) => if ((n < 0) orelse (si' < 0) orelse (srcLen < si'+n))
                                    then raise Subscript
                                else (si'+n, di+n)
                (* end case *)
                end

            val sstop = int32touint32 sstop'
            val dstop = int32touint32 dstop'
            val si = int32touint32 si'
            fun copyUp (j, k) = if ult(j,sstop)
                                    then (unsafe_update(dst, k, unsafe_sub(src, j));
                                          copyUp (uplus(j,0w1),uplus(k,0w1)))
                                else ()

        (* check to continue *after* update; otherwise we might underflow j  - Tom 7 *)
            fun copyDown (j, k) = 
                let in
                    unsafe_update(dst, k, unsafe_sub(src, j));
                    if ult(si,j) then copyDown (uminus(j, 0w1),
                                                uminus(k, 0w1))
                    else ()
                end

        in  if ((di < 0) orelse (length dst < dstop'))
                then raise Subscript
            else if (si' < di) then
                if (0w0 = sstop) then () 
                else copyDown (uminus(sstop,0w1), uminus(dstop,0w1))
              else copyUp (si, int32touint32 di)
        end


    fun copyVec {src, si, len, dst, di} = let
	  val (sstop', dstop') = let
		val srcLen = uint32toint32(vector_length src)
		in
		  case len
		   of NONE => if ((si < 0) orelse (srcLen < si))
		        then raise Subscript
		        else (srcLen, di+srcLen-si)
		    | (SOME n) => if ((n < 0) orelse (si < 0) orelse (srcLen < si+n))
		        then raise Subscript
		        else (si+n, di+n)
		  (* end case *)
		end
	  val sstop = int32touint32 sstop'
	  val dstop = int32touint32 dstop'
	  fun copyUp (j, k) = if ult(j,sstop)
		then (unsafe_update(dst, k, unsafe_vsub(src, j));
		      copyUp (uplus(j,0w1),uplus(k,0w1)))
		else ()
	  in
	    if ((di < 0) orelse (length dst < dstop'))
	      then raise Subscript
	      else copyUp (int32touint32 si, int32touint32 di)
	  end

    fun app f arr = let
	  val len = array_length arr
	  fun app i = if ult(i,len)
			  then (f (unsafe_sub(arr, i)); app(uplus(i,0w1)))
		      else ()
	  in
	    app 0w0
	  end

    fun foldl f init arr = let
	  val len = array_length arr
	  fun fold (i, accum) = if ult(i,len)
				    then fold (uplus(i,0w1), f (unsafe_sub(arr, i), accum))
				else accum
	  in
	    fold (0w0, init)
	  end

    fun chkSlice (vec, i, NONE) = let val len = length vec
	  in
	    if (len < i)
	      then raise Subscript
	      else (vec, int32touint32 i, int32touint32 len)
	  end
      | chkSlice (vec, i, SOME n) = let val len = length vec
	  in
	    if ((0 <= i) andalso (0 <= n) andalso (i+n <= len))
	      then (vec, int32touint32 i, int32touint32(i+n))
	      else raise Subscript
	  end

    fun foldr f init arr = 
	let
	    fun fold (i, accum) = 
		let val accum' = f (unsafe_sub(arr, i), accum)
		in  if (i = 0w0)
			then accum'
		    else fold (uminus(i,0w1), accum')
		end
	    val len = length arr
	in  if len = 0 then init else fold (int32touint32(len - 1), init)
	end


    fun modify f arr = let
	  val len = array_length arr
	  fun modify' i = if ult(i,len)
			      then (unsafe_update(arr, i, f (unsafe_sub(arr, i)));
				    modify'(uplus(i,0w1)))
		else ()
	  in
	    modify' 0w0
	  end



    fun appi f slice = let
	  val (vec, start, stop) = chkSlice slice
	  fun app i = if ult(i,stop)
		then (f (uint32toint32 i, unsafe_sub(vec, i)); app(uplus(i,0w1)))
		else ()
	  in
	    app start
	  end

    fun mapi f slice = let
	  val (vec, start, stop) = chkSlice slice
	  val len = uminus(stop,start)
	  fun mapf (i, l) = if ult(i,stop)
		then mapf (uplus(i,0w1), f (uint32toint32 i, unsafe_sub(vec, i)) :: l)
		else fromList'(uint32toint32 len, rev(l, []))
	  in
	    if ugt(len,0w0)
	      then mapf (start, [])
	      else array0
	  end

    fun foldli f init slice = let
	  val (vec, start, stop) = chkSlice slice
	  fun fold (i, accum) = if ult(i,stop)
				    then fold (uplus(i,0w1), f (uint32toint32 i, 
								unsafe_sub(vec, i), accum))
				else accum
	  in  fold (start, init)
	  end

    fun foldri f init slice = let
	  val (vec, start, stop) = chkSlice slice
	  fun fold (i, accum) = if ugt(i,start)
		then let val i' = uminus(i,0w1)
		     in fold (i', f (uint32toint32 i', unsafe_sub(vec, i), accum))
		     end
		else accum
	  in
	    fold (stop, init)
	  end

    fun modifyi f slice = let
	  val (arr, start, stop) = chkSlice slice
	  fun modify' i = if ult(i,stop)
		then (unsafe_update(arr, i,
				    f (uint32toint32 i, unsafe_sub(arr, i)));
		      modify'(uplus(i,0w1)))
		else ()
	  in
	    modify' start
	  end


  end (* structure Array *)


(* vector-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature VECTOR = 
  sig
    eqtype 'a vector

    val maxLen   : int

    val fromList : 'a list -> 'a vector
    val tabulate : int * (int -> 'a) -> 'a vector

    val length   : 'a vector -> int
    val sub      : 'a vector * int -> 'a 
    val extract  : 'a vector * int * int option -> 'a vector
    val concat   : 'a vector list -> 'a vector

    val mapi   : (int * 'a -> 'b) -> 'a vector * int * int option -> 'b vector
    val map    : ('a -> 'b) -> 'a vector -> 'b vector
	
    val appi   : (int * 'a -> unit) -> 'a vector * int * int option -> unit
    val app    : ('a -> unit) -> 'a vector -> unit
	
    val foldli : (int * 'a * 'b -> 'b) -> 'b -> 'a vector * int * int option -> 'b
    val foldri : (int * 'a * 'b -> 'b) -> 'b -> 'a vector * int * int option -> 'b

    val foldl  : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
    val foldr  : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b

  end

(* vector.sml
 *
 * COPYRIGHT (c) 1994 AT&T Bell Laboratories.
 *
 *)

structure Vector :> VECTOR where type 'a vector = 'a vector =
  struct

    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
    val empty_vector = TiltPrim.empty_vector
    val unsafe_array = TiltPrim.unsafe_array
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_vsub = TiltPrim.unsafe_vsub
    val vector_length = TiltPrim.vector_length
	
    val unsafe_array2vector = TiltPrim.unsafe_array2vector
    val unsafe_vector2array = TiltPrim.unsafe_vector2array
	
    val ugt = TiltPrim.ugt
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
	
    val uminus = TiltPrim.uminus
    val uplus = TiltPrim.uplus

    val maxLen = PreVector.maxLen
    val checkLen = PreVector.checkLen
    val fromList' = PreVector.vectorFromList'
    val fromList = PreVector.vectorFromList

    type 'a vector = 'a vector

    val vector0 : 'a vector = empty_vector

    fun tabulate(n,f) = unsafe_array2vector(Array.tabulate(n,f))
    fun length (a : 'a vector) : int = uint32toint32(vector_length a)
    fun sub (a : 'a vector, index :int) : 'a =
	let val index = int32touint32 index
	in  if (ugte(index, vector_length a))
		then raise Subscript
	    else unsafe_vsub(a,index)
	end


  (* a utility function *)
    fun rev ([], l) = l
      | rev (x::r, l) = rev (r, x::l)

    fun extract (v : 'a vector, base : int, optLen : int option) = 
	Array.extract (unsafe_vector2array v, base, optLen)

    fun concat [v] = v
      | concat vl = let
	(* get the total length and flatten the list *)
	  fun len ([], n, l) = (checkLen n; (n, rev(l, [])))
	    | len (v::r, n, l) = let
		val n' = length v
		fun explode (i, l) = if (i < n')
		      then explode(i+1, unsafe_vsub(v, int32touint32 i)::l)
		      else l
		in
		  len (r, n + n', explode(0, l))
		end
	  in
	    case len (vl, 0, [])
	     of (0, _) => vector0
	      | (n, l) => fromList'(n, l)
	    (* end case *)
	  end

    fun map f vec = let
          val len = vector_length vec
          fun mapf (i, l) = if ult(i,len)
                then mapf (uplus(i,0w1), f (unsafe_vsub(vec, i)) :: l)
                else fromList'(uint32toint32 len, rev(l, []))
          in
            if ugt(len,0w0)
              then mapf (0w0, [])
              else vector0
          end

    fun chkSlice (vec, i, NONE) = let val len = length vec
	  in
	    if (len < i)
	      then raise Subscript
	      else (vec, int32touint32 i, int32touint32 len)
	  end
      | chkSlice (vec, i, SOME n) = let val len = length vec
	  in
	    if ((0 <= i) andalso (0 <= n) andalso (i+n <= len))
	      then (vec, int32touint32 i, int32touint32(i+n))
	      else raise Subscript
	  end
     fun mapi f slice = let
          val (vec, start, stop) = chkSlice slice
          val len = uminus(stop,start)
          fun mapf (i, l) = if ult(i,stop)
                then mapf (uplus(i,0w1), f (uint32toint32 i, unsafe_vsub(vec, i)) :: l)
                else fromList'(uint32toint32 len, rev(l, []))
          in
            if ugt(len,0w0)
              then mapf (start, [])
              else vector0
          end

    fun app f vec = Array.app f (unsafe_vector2array vec)
    fun foldl f init vec = Array.foldl f init (unsafe_vector2array vec)
    fun foldr f init vec = Array.foldr f init (unsafe_vector2array vec)
    fun appi f (vec,start,len) = Array.appi f (unsafe_vector2array vec,start,len)
    fun foldli f acc (vec,start,len) = Array.foldli f acc (unsafe_vector2array vec,start,len)
    fun foldri f acc (vec,start,len) = Array.foldri f acc (unsafe_vector2array vec,start,len)




  end  (* Vector *)


(* mono-vector-sig.sml
 *
 * COPYRIGHT (c) 1994 AT&T Bell Laboratories.
 *
 * Generic interface for monomorphic vector structures.
 *
 *)

signature MONO_VECTOR =
  sig

    type vector
    type elem

    val maxLen : int

  (* vector creation functions *)
    val fromList : elem list -> vector
    val tabulate : int * (int -> elem) -> vector

    val length   : vector -> int
    val sub      : vector * int -> elem
    val extract  : vector * int * int option -> vector
    val concat   : vector list -> vector

    val mapi   : (int * elem -> elem) -> vector * int * int option -> vector
    val map    : (elem -> elem) -> vector -> vector
	
    val appi   : (int * elem -> unit) -> vector * int * int option -> unit
    val app    : (elem -> unit) -> vector -> unit
	
    val foldli : (int * elem * 'a -> 'a) -> 'a -> vector * int * int option -> 'a
    val foldri : (int * elem * 'a -> 'a) -> 'a -> vector * int * int option -> 'a

    val foldl  : (elem * 'a -> 'a) -> 'a -> vector -> 'a
    val foldr  : (elem * 'a -> 'a) -> 'a -> vector -> 'a

  end

(* mono-array-sig.sml
 *
 * COPYRIGHT (c) 1994 AT&T Bell Laboratories.
 *
 * Generic interface for monomorphic array structures.
 *
 *)

signature MONO_ARRAY =
  sig

    eqtype array
    type elem
    structure Vector : MONO_VECTOR
	(* sharing type Vector.elem = elem -- Holds for TILT but not part of this signature *)

    val maxLen : int

  (* array creation functions *)
    val array    : int * elem -> array
    val fromList : elem list -> array
    val tabulate : int * (int -> elem) -> array

    val length   : array -> int
    val sub      : array * int -> elem
    val update   : array * int * elem -> unit
    val extract  : array * int * int option -> Vector.vector

    val copy : {
	    src : array, si : int, len : int option,
	    dst : array, di : int
	  } -> unit
    val copyVec : {
	    src : Vector.vector, si : int, len : int option,
	    dst : array, di : int
	  } -> unit

    val appi    : (int * elem -> unit) -> array * int * int option -> unit
    val app     : (elem -> unit) -> array -> unit
	
    val foldli  : (int * elem * 'a -> 'a) -> 'a -> array * int * int option -> 'a
    val foldri  : (int * elem * 'a -> 'a) -> 'a -> array * int * int option -> 'a
	  
    val foldl   : (elem * 'a -> 'a) -> 'a -> array -> 'a
    val foldr   : (elem * 'a -> 'a) -> 'a -> array -> 'a
	
    val modifyi : (int * elem -> elem) -> array * int * int option -> unit

    val modify  : (elem -> elem) -> array -> unit

  end

(* word8-vector.sml specialized copy of vector.sml
 *
 * COPYRIGHT (c) 1994 AT&T Bell Laboratories.
 *
 *)

structure Word8Vector :> MONO_VECTOR where type elem = char
				       and type vector = char vector =
  struct

    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
    val empty_vector = TiltPrim.empty_vector
    val unsafe_array = TiltPrim.unsafe_array
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_vsub = TiltPrim.unsafe_vsub
    val vector_length = TiltPrim.vector_length
	
    val unsafe_array2vector = TiltPrim.unsafe_array2vector
    val unsafe_vector2array = TiltPrim.unsafe_vector2array
	
    val ugt = TiltPrim.ugt
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
	
    val uminus = TiltPrim.uminus
    val uplus = TiltPrim.uplus
	
    type elem = char
    type vector = char vector

    val maxLen = Vector.maxLen

    fun checkLen n = if maxLen < n then raise General.Size else ()
    val vector0 : vector = empty_vector

    fun fromList'(n,l) = 
	let val _ = checkLen n
	in
	    if (n = 0)
		then vector0
	    else let val ar = unsafe_array(int32touint32 n, List.hd l)
		     fun loop [] _ = ()
		       | loop (a::b) n = (unsafe_update(ar,n,a);
					  loop b (uplus(n,0w1)))
		     val _ = loop l 0w0
		 in  unsafe_array2vector ar
		 end
	end

    fun fromList l = unsafe_array2vector(Array.fromList l)
    fun tabulate(n,f) = unsafe_array2vector(Array.tabulate(n,f))

    fun length (a : vector) : int = uint32toint32(vector_length a)
    fun sub (a : vector, index :int) =
	let val index = int32touint32 index
	in  if (ugte(index, vector_length a))
		then raise Subscript
	    else unsafe_vsub(a,index)
	end


  (* a utility function *)
    fun rev ([], l) = l
      | rev (x::r, l) = rev (r, x::l)

    fun extract (v : vector, base : int, optLen : int option) = 
	Array.extract (unsafe_vector2array v, base, optLen)

    fun concat [v] = v
      | concat vl = let
	(* get the total length and flatten the list *)
	  fun len ([], n, l) = (checkLen n; (n, rev(l, [])))
	    | len (v::r, n, l) = let
		val n' = length v
		fun explode (i, l) = if (i < n')
		      then explode(i+1, unsafe_vsub(v, int32touint32 i)::l)
		      else l
		in
		  len (r, n + n', explode(0, l))
		end
	  in
	    case len (vl, 0, [])
	     of (0, _) => vector0
	      | (n, l) => fromList'(n, l)
	    (* end case *)
	  end

    fun map f vec = let
          val len = vector_length vec
          fun mapf (i, l) = if ult(i,len)
                then mapf (uplus(i,0w1), f (unsafe_vsub(vec, i)) :: l)
                else fromList'(uint32toint32 len, rev(l, []))
          in
            if ugt(len,0w0)
              then mapf (0w0, [])
              else vector0
          end

    fun chkSlice (vec, i, NONE) = let val len = length vec
	  in
	    if (len < i)
	      then raise Subscript
	      else (vec, int32touint32 i, int32touint32 len)
	  end
      | chkSlice (vec, i, SOME n) = let val len = length vec
	  in
	    if ((0 <= i) andalso (0 <= n) andalso (i+n <= len))
	      then (vec, int32touint32 i, int32touint32(i+n))
	      else raise Subscript
	  end
     fun mapi f slice = let
          val (vec, start, stop) = chkSlice slice
          val len = uminus(stop,start)
          fun mapf (i, l) = if ult(i,stop)
                then mapf (uplus(i,0w1), f (uint32toint32 i, unsafe_vsub(vec, i)) :: l)
                else fromList'(uint32toint32 len, rev(l, []))
          in
            if ugt(len,0w0)
              then mapf (start, [])
              else vector0
          end

    fun app f vec = Array.app f (unsafe_vector2array vec)
    fun foldl f init vec = Array.foldl f init (unsafe_vector2array vec)
    fun foldr f init vec = Array.foldr f init (unsafe_vector2array vec)
    fun appi f (vec,start,len) = Array.appi f (unsafe_vector2array vec,start,len)
    fun foldli f acc (vec,start,len) = Array.foldli f acc (unsafe_vector2array vec,start,len)
    fun foldri f acc (vec,start,len) = Array.foldri f acc (unsafe_vector2array vec,start,len)




  end  (* Vector *)


(* array.sml
 *
 * COPYRIGHT (c) 1994 AT&T Bell Laboratories.
 *
 *)

structure Word8Array :> MONO_ARRAY where type elem = char
				     and type array = char array 
				     and type Vector.vector = char vector
				     and type Vector.elem = char =
  struct

    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
    val array_length = TiltPrim.array_length
    val empty_array = TiltPrim.empty_array
    val empty_vector = TiltPrim.empty_vector
    val unsafe_array = TiltPrim.unsafe_array
    val unsafe_sub = TiltPrim.unsafe_sub
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_vsub = TiltPrim.unsafe_vsub
    val vector_length = TiltPrim.vector_length
	
    val unsafe_array2vector = TiltPrim.unsafe_array2vector
	
    val uminus = TiltPrim.uminus
    val uplus = TiltPrim.uplus
	
    val ugt = TiltPrim.ugt
    val ugte = TiltPrim.ugte
    val ult = TiltPrim.ult
    val ulte = TiltPrim.ulte
	
    type elem = char
    type array = char array
    structure Vector = Word8Vector

    val maxLen = Array.maxLen

    val array0 : array = empty_array
    val vector0 : Vector.vector = empty_vector

    fun array (0, _) = array0
      | array (n, init) = 
	if (maxLen < n) 
	    then raise General.Size 
	else unsafe_array(int32touint32 n, init)

    fun checkLen n = if maxLen < n then raise General.Size else ()
    fun rev ([], l) = l
      | rev (x::r, l) = rev (r, x::l)
    fun fromList'(n,l) = 
	let val _ = checkLen n
	in
	    if (n = 0)
		then array0
	    else let val ar = unsafe_array(int32touint32 n, List.hd l)
		     fun loop [] _ = ()
		       | loop (a::b) n = (unsafe_update(ar,n,a);
					  loop b (uplus(n,0w1)))
		     val _ = loop l 0w0
		 in  ar
		 end
	end
    fun fromList l = 
	let
	    fun len ([], n) = n
	      | len ([_], n) = n+1
	      | len (_::_::r, n) = len(r, n+2)
	    val n = len (l, 0)
	in  fromList'(n,l)
	end

    fun tabulate (0, _) = array0
      | tabulate (n, f) : array = 
          let val a = array(n, f 0)
	      val n = int32touint32 n
              fun tab i = 
                if ult(i,n) then (unsafe_update(a, i, f (uint32toint32 i)); 
				  tab(uplus(i,0w1)))
                else a
           in tab 0w1
          end

    fun length (ar : array) : int = uint32toint32(array_length ar)
    fun sub (a : array, index :int) =
	let val index = int32touint32 index
	in  if (ugte(index, array_length a))
		then raise Subscript
	    else unsafe_sub(a,index)
	end
    fun update (a, index :int, e : 'a) : unit =
	let val index = int32touint32 index
	in  if (ugte(index, array_length a))
		then raise Subscript
	    else unsafe_update(a,index,e)
	end

    fun extract (v, base : int, optLen : int option) = let
	  val len = length v
	  fun newVec (n : int) : Vector.vector = let
		fun tab (~1, l) = unsafe_array2vector(fromList'(n,l))
		  | tab (i, l) = tab(i-1, (unsafe_sub(v, int32touint32(base+i)))::l)
		in  tab (n-1, [])
		end
	  in
	    case (base, optLen)
	     of (0, NONE) => if (0 < len) then newVec len else vector0
	      | (_, SOME 0) => if ((base < 0) orelse (len < base))
		  then raise General.Subscript
		  else vector0
	      | (_, NONE) => if ((base < 0) orelse (len < base))
		    then raise General.Subscript
		  else if (len = base)
		    then vector0
		    else newVec (len - base)
	      | (_, SOME n) =>
		  if ((base < 0) orelse (n < 0) orelse (len < (base+n)))
		    then raise General.Subscript
		    else newVec n
	    (* end case *)
	  end

    fun copy {src, si=si', len, dst, di} = 
        let

            val (sstop', dstop') = 
                let val srcLen = length src
                in  case len
                    of NONE => if ((si' < 0) orelse (srcLen < si'))
                                   then raise Subscript
                               else (srcLen, di+srcLen-si')
                  | (SOME n) => if ((n < 0) orelse (si' < 0) orelse (srcLen < si'+n))
                                    then raise Subscript
                                else (si'+n, di+n)
                (* end case *)
                end

            val sstop = int32touint32 sstop'
            val dstop = int32touint32 dstop'
            val si = int32touint32 si'
            fun copyUp (j, k) = if ult(j,sstop)
                                    then (unsafe_update(dst, k, unsafe_sub(src, j));
                                          copyUp (uplus(j,0w1),uplus(k,0w1)))
                                else ()

        (* check to continue *after* update; otherwise we might underflow j  - Tom 7 *)
            fun copyDown (j, k) = 
                let in
                    unsafe_update(dst, k, unsafe_sub(src, j));
                    if ult(si,j) then copyDown (uminus(j, 0w1),
                                                uminus(k, 0w1))
                    else ()
                end

        in  if ((di < 0) orelse (length dst < dstop'))
                then raise Subscript
            else if (si' < di) then
                if (0w0 = sstop) then () 
                else copyDown (uminus(sstop,0w1), uminus(dstop,0w1))
              else copyUp (si, int32touint32 di)
        end

    fun copyVec {src, si, len, dst, di} = let
	  val (sstop', dstop') = let
		val srcLen = uint32toint32(vector_length src)
		in
		  case len
		   of NONE => if ((si < 0) orelse (srcLen < si))
		        then raise Subscript
		        else (srcLen, di+srcLen-si)
		    | (SOME n) => if ((n < 0) orelse (si < 0) orelse (srcLen < si+n))
		        then raise Subscript
		        else (si+n, di+n)
		  (* end case *)
		end
	  val sstop = int32touint32 sstop'
	  val dstop = int32touint32 dstop'
	  fun copyUp (j, k) = if ult(j,sstop)
		then (unsafe_update(dst, k, unsafe_vsub(src, j));
		      copyUp (uplus(j,0w1),uplus(k,0w1)))
		else ()
	  in
	    if ((di < 0) orelse (length dst < dstop'))
	      then raise Subscript
	      else copyUp (int32touint32 si, int32touint32 di)
	  end

    fun app f arr = let
	  val len = array_length arr
	  fun app i = if ult(i,len)
			  then (f (unsafe_sub(arr, i)); app(uplus(i,0w1)))
		      else ()
	  in
	    app 0w0
	  end

    fun foldl f init arr = let
	  val len = array_length arr
	  fun fold (i, accum) = if ult(i,len)
				    then fold (uplus(i,0w1), f (unsafe_sub(arr, i), accum))
				else accum
	  in
	    fold (0w0, init)
	  end

    fun chkSlice (vec, i, NONE) = let val len = length vec
	  in
	    if (len < i)
	      then raise Subscript
	      else (vec, int32touint32 i, int32touint32 len)
	  end
      | chkSlice (vec, i, SOME n) = let val len = length vec
	  in
	    if ((0 <= i) andalso (0 <= n) andalso (i+n <= len))
	      then (vec, int32touint32 i, int32touint32(i+n))
	      else raise Subscript
	  end

    fun foldr f init arr = 
	let
	    fun fold (i, accum) = 
		let val accum' = f (unsafe_sub(arr, i), accum)
		in  if (i = 0w0)
			then accum'
		    else fold (uminus(i,0w1), accum')
		end
	in  fold (int32touint32(length arr - 1), init)
	end


    fun modify f arr = let
	  val len = array_length arr
	  fun modify' i = if ult(i,len)
			      then (unsafe_update(arr, i, f (unsafe_sub(arr, i)));
				    modify'(uplus(i,0w1)))
		else ()
	  in
	    modify' 0w0
	  end



    fun appi f slice = let
	  val (vec, start, stop) = chkSlice slice
	  fun app i = if ult(i,stop)
		then (f (uint32toint32 i, unsafe_sub(vec, i)); app(uplus(i,0w1)))
		else ()
	  in
	    app start
	  end

    fun mapi f slice = let
	  val (vec, start, stop) = chkSlice slice
	  val len = uminus(stop,start)
	  fun mapf (i, l) = if ult(i,stop)
		then mapf (uplus(i,0w1), f (uint32toint32 i, unsafe_sub(vec, i)) :: l)
		else fromList'(uint32toint32 len, rev(l, []))
	  in
	    if ugt(len,0w0)
	      then mapf (start, [])
	      else array0
	  end

    fun foldli f init slice = let
	  val (vec, start, stop) = chkSlice slice
	  fun fold (i, accum) = if ult(i,stop)
				    then fold (uplus(i,0w1), f (uint32toint32 i, 
								unsafe_sub(vec, i), accum))
				else accum
	  in  fold (start, init)
	  end

    fun foldri f init slice = let
	  val (vec, start, stop) = chkSlice slice
	  fun fold (i, accum) = if ugt(i,start)
		then let val i' = uminus(i,0w1)
		     in fold (i', f (uint32toint32 i', unsafe_sub(vec, i), accum))
		     end
		else accum
	  in
	    fold (stop, init)
	  end

    fun modifyi f slice = let
	  val (arr, start, stop) = chkSlice slice
	  fun modify' i = if ult(i,stop)
		then (unsafe_update(arr, i,
				    f (uint32toint32 i, unsafe_sub(arr, i)));
		      modify'(uplus(i,0w1)))
		else ()
	  in
	    modify' start
	  end


  end (* structure Array *)


(* pack-word-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature PACK_WORD =
  sig

    val bytesPerElem : int

    val isBigEndian : bool

    val subVec : Word8Vector.vector * int -> LargeWord.word
    val subVecX : Word8Vector.vector * int -> LargeWord.word

    val subArr : Word8Array.array * int -> LargeWord.word
    val subArrX : Word8Array.array * int -> LargeWord.word

    val update : Word8Array.array * int * LargeWord.word -> unit

  end;

(* pack-word-b32.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This is the non-native implementation of 32-bit big-endian packing
 * operations.
 *
 *)

structure Pack32Big :> PACK_WORD =
  struct
    structure W = Word32
    structure W8 = Word8
    structure W8V = Word8Vector
    structure W8A = Word8Array

    val bytesPerElem = 4
    val isBigEndian = true

  (* convert the byte length into word32 length (n div 4), and check the index *)
    fun chkIndex (len, i) = let
	  val len = W.toIntX(W.>>(W.fromInt len, 0w2))
	  in
	    if (i <= len) then () else raise Subscript
	  end

    fun mkWord (b1, b2, b3, b4) =
	  W.orb (W.<<(Word8.toLargeWord b1, 0w24),
	  W.orb (W.<<(Word8.toLargeWord b2, 0w16),
	  W.orb (W.<<(Word8.toLargeWord b3,  0w8),
		      Word8.toLargeWord b4)))

    fun subVec (vec, i) = let
	  val _ = chkIndex (W8V.length vec, i)
	  val k = W.toIntX(W.<<(W.fromInt i, 0w2))
	  in
	    mkWord (W8V.sub(vec, k), W8V.sub(vec, k+1),
	      W8V.sub(vec, k+2), W8V.sub(vec, k+3))
	  end
  (* since LargeWord is 32-bits, no sign extension is required *)
    fun subVecX(vec, i) = subVec (vec, i)

    fun subArr (arr, i) = let
	  val _ = chkIndex (W8A.length arr, i)
	  val k = W.toIntX(W.<<(W.fromInt i, 0w2))
	  in
	    mkWord (W8A.sub(arr, k), W8A.sub(arr, k+1),
	      W8A.sub(arr, k+2), W8A.sub(arr, k+3))
	  end
  (* since LargeWord is 32-bits, no sign extension is required *)
    fun subArrX(arr, i) = subArr (arr, i)

    fun update (arr, i, w) = let
	  val _ = chkIndex (W8A.length arr, i)
	  val k = W.toIntX(W.<<(W.fromInt i, 0w2))
	  in
	    W8A.update (arr, k,   W8.fromLargeWord(W.>>(w, 0w24)));
	    W8A.update (arr, k+1, W8.fromLargeWord(W.>>(w, 0w16)));
	    W8A.update (arr, k+2, W8.fromLargeWord(W.>>(w,  0w8)));
	    W8A.update (arr, k+3, W8.fromLargeWord w)
	  end

  end;


(* byte-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature BYTE =
  sig

    val byteToChar : Word8.word -> char
    val charToByte : char -> Word8.word

    val bytesToString : Word8Vector.vector -> string
    val stringToBytes : string -> Word8Vector.vector

    val unpackStringVec : Word8Vector.vector * int * int option -> string
    val unpackString    : Word8Array.array * int * int option -> string
    val packString      : Word8Array.array * int * Substring.substring -> unit

  end

(* byte.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure Byte :> BYTE =
  struct
    val int32touint32 = TiltPrim.int32touint32
	
    val unsafe_update = TiltPrim.unsafe_update
    val unsafe_vsub = TiltPrim.unsafe_vsub
	
    val uplus = TiltPrim.uplus
    val uminus = TiltPrim.uminus
	
    fun chr (b : Word8.word) : char = b
    fun ord (c : char) : Word8.word = c
    fun vectorToString (v,pos,len) : string = Word8Vector.extract(v,pos,SOME len)
    fun arrayToString (a,pos,len) : string = Word8Array.extract(a,pos,SOME len)

    val byteToChar = chr
    val charToByte = ord

    fun bytesToString (cv : Word8Vector.vector) : string = cv
    fun stringToBytes (str : string) : Word8Vector.vector = str

    val unpackStringVec : (Word8Vector.vector * int * int option) -> string
	 = Word8Vector.extract
    val unpackString  : (Word8Array.array * int * int option) -> string
	 = Word8Array.extract


    fun packString (arr : char array, i : int, ss : Substring.substring) : unit = 
	let
	    val PreString.SS(src, srcStart, srcLen) = ss
	    val dstLen = Array.length arr
	    fun cpy (_, _, 0w0) = ()
	      | cpy (srcIndx, dstIndx, n) = 
		(unsafe_update (arr, dstIndx, unsafe_vsub(src, srcIndx));
		 cpy (uplus(srcIndx,0w1), uplus(dstIndx,0w1), uminus(n,0w1)))
	in
	    if (i < 0) orelse (i > dstLen-srcLen) then raise Subscript else ();
		cpy (int32touint32 srcStart, int32touint32 i, int32touint32 srcLen)
	end

  end



structure CharVector = Word8Vector

structure CharArray = Word8Array
(* list-pair-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * If lists are of unequal length, the excess elements from the
 * tail of the longer one are ignored. No exception is raised.
 *
 *)

signature LIST_PAIR =
  sig

    val zip    : 'a list * 'b list -> ('a * 'b) list
    val unzip  : ('a * 'b) list -> 'a list * 'b list
    val map    : ('a * 'b -> 'c) -> 'a list * 'b list -> 'c list
    val app    : ('a * 'b -> unit) -> 'a list * 'b list -> unit
    val foldl  : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
    val foldr  : ('a * 'b * 'c -> 'c) -> 'c -> 'a list * 'b list -> 'c
    val all    : ('a * 'b -> bool) -> 'a list * 'b list -> bool
    val exists : ('a * 'b -> bool) -> 'a list * 'b list -> bool

  end (* signature LIST_PAIR *)

(* list-pair.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * If lists are of unequal length, the excess elements from the
 * tail of the longer one are ignored. No exception is raised.
 *
 *)

structure ListPair :> LIST_PAIR =
  struct

  (* for inlining *)
    fun rev l = let 
          fun loop ([], acc) = acc
            | loop (a::r, acc) = loop(r, a::acc)
          in
	    loop (l, [])
	  end

    fun zip (l1, l2) = let
	  fun zip' ((a :: r1), (b :: r2), l) = zip' (r1, r2, (a, b)::l)
	    | zip' (_, _, l) = rev l
	  in
	    zip' (l1, l2, [])
	  end

    fun unzip l = let
	  fun unzip' ([], l1, l2) = (l1, l2)
	    | unzip' ((a, b) :: r, l1, l2) = unzip' (r, a::l1, b::l2)
	  in
	    unzip' (rev l, [], [])
	  end

    fun map f = let
	  fun mapf (a::r1, b::r2, l) = mapf (r1, r2, f(a, b) :: l)
	    | mapf (_, _, l) = rev l
	  in
	    fn (l1, l2) => mapf (l1, l2, [])
	  end

    fun app f = let
	  fun appf (a::r1, b::r2) = (f(a, b); appf(r1, r2))
	    | appf _ = ()
	  in
	    appf
	  end

    fun all pred = let
	  fun allp (a::r1, b::r2) = pred(a, b) andalso allp (r1, r2)
	    | allp _ = true
	  in
	    allp
	  end

    fun foldl f init (l1, l2) = let
	  fun foldf (x::xs, y::ys, accum) = foldf(xs, ys, f(x, y, accum))
	    | foldf (_, _, accum) = accum
	  in
	    foldf (l1, l2, init)
	  end

    fun foldr f init (l1, l2) = let
	  fun foldf (x::xs, y::ys) = f(x, y, foldf(xs, ys))
	    | foldf _ = init
	  in
	    foldf (l1, l2)
	  end

    fun exists pred = let
	  fun existsp (a::r1, b::r2) = pred(a, b) orelse existsp (r1, r2)
	    | existsp _ = false
	  in
	    existsp
	  end

  end (* structure ListPair *)


signature COMMAND_LINE =
sig
    val name : unit -> string
    val arguments : unit -> string list
end
extern commandline_name : (unit, string) -->
extern commandline_arguments : (unit, string list) -->

structure CommandLine :> COMMAND_LINE =
struct

    fun name () = Ccall(commandline_name,())
    fun arguments () = Ccall(commandline_arguments,())

end
(* time-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature TIME =
  sig

    eqtype time

    exception Time

    val zeroTime : time

    val fromReal : real -> time
    val toReal   : time -> real

    val toSeconds        : time -> int
    val toMilliseconds   : time -> int
    val toMicroseconds   : time -> int
    val fromSeconds      : int -> time
    val fromMilliseconds : int -> time
    val fromMicroseconds : int -> time

    val +  : time * time -> time
    val -  : time * time -> time

    val compare : time * time -> order

    val <  : time * time -> bool
    val <= : time * time -> bool
    val >  : time * time -> bool
    val >= : time * time -> bool

    val now : unit -> time

    val fmt : int -> time -> string
    val toString   : time -> string
    val fromString : string -> time option
    val scan : (char, 'a) StringCvt.reader -> (time, 'a) StringCvt.reader

  end (* TIME *)


extern ml_timeofday : (unit, (int * int)) -->

(* user sec, user usec, system sec, system usec *)
extern til_selfusage : (unit, int * int * int * int) -->

(* wall clock sec, wall clock msec *)
extern til_realtime : (unit, int * int) --> 

structure PreTime =
struct
    
    datatype time = TIME of {sec : int, usec : int}
	
end
(* time.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure Time :> TIME where type time = PreTime.time =
  struct
    val uint8touint32 = TiltPrim.uint8touint32
    val ulte = TiltPrim.ulte
    val op^ = String.^

(*    structure PB = PreBasis *)

  (* get time type from type-only structure *)
(*    open Time *)

    datatype time = datatype PreTime.time
    exception Time

    val zeroTime = TIME{sec=0, usec=0}

    fun toSeconds (TIME{sec, ...}) = sec  (* should we round? *)
    fun fromSeconds sec =
	  if (sec < 0)
	    then raise Time
	    else TIME{sec=sec, usec=0}

    fun toMilliseconds (TIME{sec, usec}) =
	  (sec * 1000) + Int.quot(usec, 1000)
    fun fromMilliseconds msec =
	  if (msec < 0)
	    then raise Time
	  else if (msec >= 1000)
	    then TIME{sec= Int.quot(msec, 1000), usec= 1000*(Int.rem(msec, 1000))}
	    else TIME{sec= 0, usec= 1000*msec}

    fun toMicroseconds (TIME{sec, usec}) =
	  (sec * 1000000) + usec
    fun fromMicroseconds usec =
	  if (usec < 0)
	    then raise Time
	  else if (usec >= 1000000)
	    then TIME{sec= Int.quot(usec, 1000000), usec= Int.rem(usec,  1000000)}
	    else TIME{sec=0, usec=usec}

    fun fromReal rt = if (rt < 0.0)
	  then raise Time
	  else let
	    val sec = Real.floor rt
	    in
	      TIME{sec=sec, usec=Real.floor((rt - Real.fromInt sec) * 1000000.0)}
	    end

    fun toReal (TIME{sec, usec}) =
	  (Real.fromInt sec) + ((Real.fromInt usec) * 0.000001)

    fun add (TIME{sec=s1, usec=u1}, TIME{sec=s2, usec=u2}) = let
	  val s = s1 + s2
	  val u = u1+u2
	  in
	    if (u >= 1000000)
	      then TIME{sec=s+1, usec=u-1000000}
	      else TIME{sec=s, usec=u}
	  end
    fun sub (TIME{sec=s1, usec=u1}, TIME{sec=s2, usec=u2}) = let
	  val s = s1 - s2
	  val u = u1 - u2
	  val (s, u) = if (u < 0) then (s-1, u+1000000) else (s, u)
	  in
	    if (s < 0)
	      then raise Time
	      else TIME{sec=s, usec=u}
	  end

    fun compare (TIME{sec=s1, usec=u1}, TIME{sec=s2, usec=u2}) =
	  if (s1 < s2) then LESS
	  else if (s1 = s2)
	    then if (u1 < u2) then LESS
	    else if (u1 = u2) then EQUAL
	    else GREATER
	  else GREATER

    fun less (TIME{sec=s1, usec=u1}, TIME{sec=s2, usec=u2}) =
	  (s1 < s2) orelse ((s1 = s2) andalso (u1 < u2))
    fun lessEq (TIME{sec=s1, usec=u1}, TIME{sec=s2, usec=u2}) =
	  (s1 < s2) orelse ((s1 = s2) andalso (u1 <= u2))


    fun now () = let val (ts, tu) = Ccall(ml_timeofday,())
	  in
	    TIME{sec=ts, usec=tu}
	  end


    local
      val zeros = "0000000000"
      val numZeros = String.size zeros
      fun pad 0 = []
	| pad n = if (n <= numZeros)
	    then [String.substring(zeros, 0, n)]
	    else zeros :: pad(n - numZeros)
      val fmtInt = (NumFormat.fmtInt StringCvt.DEC) o Int.fromInt
    in
    fun fmt prec (TIME{sec, usec}) = let
	  val sec' = fmtInt sec
	  in
	    if (prec <= 0)
	      then sec'
	      else let
		val usec' = fmtInt usec
		val frac = String.substring(zeros, 0, 6 - String.size usec') ^ usec'
		in
		  if (prec < 6)
		    then String.concat [
			sec', ".", String.substring(frac, 0, prec)
		      ]
		    else String.concat (sec' :: "." :: frac :: pad(prec-6))
		end
	  end
    end (* local *)

  (* scan a time value; this has the syntax:
   *
   *  [0-9]+(.[0-9]+)? | .[0-9]+
   *)
    fun scan getc charStrm = let
	  fun chrLE (x : char, y : char) : bool = ulte(uint8touint32 x, uint8touint32 y)
	  fun isDigit c = (chrLE(#"0", c) andalso chrLE(c, #"9"))
	  fun incByDigit (n, c) = 10*n + (Char.ord c - Char.ord #"0")
	  fun scanSec (secs, cs) = (case (getc cs)
		 of NONE => SOME(TIME{sec=secs, usec=0}, cs)
		  | (SOME(#".", cs')) => (case (getc cs')
		       of NONE => SOME(TIME{sec=secs, usec=0}, cs)
			| (SOME(d, cs'')) => if (isDigit d)
			    then scanUSec (secs, cs')
			    else SOME(TIME{sec=secs, usec=0}, cs)
		      (* end case *))
		  | (SOME(d, cs')) => if (isDigit d)
		      then scanSec(incByDigit(secs, d), cs')
		      else SOME(TIME{sec=secs, usec=0}, cs)
		(* end case *))
	  and scanUSec (secs, cs) = let
		fun normalize (usecs, 6) = usecs
		  | normalize (usecs, n) = normalize(10*usecs, n+1)
		fun scan' (usecs, 6, cs) = (case (getc cs)
		       of NONE => (usecs, cs)
			| (SOME(d, cs')) => if (isDigit d)
			    then scan' (usecs, 6, cs')
			    else (usecs, cs)
		      (* end case *))
		  | scan' (usecs, ndigits, cs) = (case (getc cs)
		       of NONE => (normalize(usecs, ndigits), cs)
			| (SOME(d, cs')) => if (isDigit d)
			    then scan' (incByDigit(usecs, d), ndigits+1, cs')
			    else (normalize(usecs, ndigits), cs)
		      (* end case *))
		val (usecs, cs) = scan' (0, 0, cs)
		in
		  SOME(TIME{sec=secs, usec=usecs}, cs)
		end
	  val cs = StringCvt.skipWS getc charStrm
	  in
	    case (getc cs)
	     of NONE => NONE
	      | (SOME(#".", cs')) => (case (getc cs')
		   of NONE => NONE
		    | (SOME(d, _)) =>
			if (isDigit d) then scanUSec (0, cs') else NONE
		  (* end case *))
	      | (SOME(d, _)) => if (isDigit d) then scanSec(0, cs) else NONE
	    (* end case *)
	  end

    val toString   = fmt 3
    val fromString = StringCvt.scanString scan

    val (op +) = add
    val (op -) = sub

    val (op <)  = less
    val (op <=) = lessEq
    val (op >)  = Bool.not o lessEq
    val (op >=) = Bool.not o less

  end (* TIME *)

(* os-filesys-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * The generic file system interface.
 *
 *)

signature OS_FILE_SYS =
  sig

    type dirstream

    val openDir   : string -> dirstream
    val readDir   : dirstream -> string
    val rewindDir : dirstream -> unit
    val closeDir  : dirstream -> unit

    val chDir  : string -> unit
    val getDir : unit -> string
    val mkDir  : string -> unit
    val rmDir  : string -> unit
    val isDir  : string -> bool

    val isLink   : string -> bool
    val readLink : string -> string

    val fullPath : string -> string
    val realPath : string -> string

    val modTime  : string -> Time.time
    val fileSize : string -> Position.int
    val setTime  : string * Time.time option -> unit
	
    val remove   : string -> unit
    val rename   : {old : string, new : string} -> unit

    datatype access_mode = A_READ | A_WRITE | A_EXEC

    val access : string * access_mode list -> bool

    val tmpName : unit -> string

    eqtype file_id
    val fileId  : string -> file_id
    val hash    : file_id -> word
    val compare : file_id * file_id -> order

  end; (* FILE_SYS *)


(* os-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * NOTE: this interface has been proposed, but not yet adopted by the
 * Standard basis committee.
 *
 *)

signature OS_IO =
  sig
    eqtype iodesc
	(* an iodesc is an abstract descriptor for an OS object that
	 * supports I/O (e.g., file, tty device, socket, ...).
	 *)
    val hash : iodesc -> word
	(* return a hash value for the I/O descriptor. *)

    val compare : iodesc * iodesc -> order
	(* compare two I/O descriptors *)

    eqtype iodesc_kind

    val kind : iodesc -> iodesc_kind
	(* return the kind of I/O descriptor. *)

    structure Kind : sig
	val file : iodesc_kind
	val dir : iodesc_kind 
	val symlink : iodesc_kind 
	val tty : iodesc_kind 
	val pipe : iodesc_kind 
	val socket : iodesc_kind 
	val device : iodesc_kind 
      end

    type poll_desc
	(* this is an abstract representation of a polling operation on
	 * an I/O descriptor.
	 *)
    type poll_info
	(* this is an abstract representation of the per-descriptor
	 * information returned by the poll operation.
	 *)

    val pollDesc : iodesc -> poll_desc option
	(* create a polling operation on the given descriptor; note that
	 * not all I/O devices support polling.
	 *)
    val pollToIODesc : poll_desc -> iodesc
	(* return the I/O descriptor that is being polled *)

    exception Poll

  (* set polling events; if the polling operation is not appropriate
   * for the underlying I/O device, then the Poll exception is raised.
   *)
    val pollIn  : poll_desc -> poll_desc
    val pollOut : poll_desc -> poll_desc
    val pollPri : poll_desc -> poll_desc

  (* polling function *)
    val poll : poll_desc list * Time.time option -> poll_info list
	(* a timeout of NONE means wait indefinitely; a timeout of
	 * (SOME Time.zeroTime) means do not block.
	 *)

  (* check for conditions *)
    val isIn 		: poll_info -> bool
    val isOut		: poll_info -> bool
    val isPri		: poll_info -> bool
    val infoToPollDesc  : poll_info -> poll_desc

  end (* OS_IO *)


(* os-path-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * The generic interface to syntactic pathname manipulation.
 *
 *)

signature OS_PATH =
  sig

    exception Path
    exception InvalidArc

    val parentArc  : string
    val currentArc : string

    val validVolume : {isAbs : bool, vol : string} -> bool

    val fromString : string -> {isAbs : bool, vol : string, arcs : string list}
    val toString   : {isAbs : bool, vol : string, arcs : string list} -> string

    val getVolume   : string -> string
    val getParent   : string -> string

    val splitDirFile : string -> {dir : string, file : string}
    val joinDirFile  : {dir : string, file : string} -> string
    val dir	     : string -> string
    val file	     : string -> string
    
    val splitBaseExt : string -> {base : string, ext : string option}
    val joinBaseExt  : {base : string, ext : string option} -> string
    val base	     : string -> string    
    val ext	     : string -> string option

    val mkCanonical : string -> string
    val isCanonical : string -> bool

    val mkAbsolute  : string * string -> string
    val mkRelative  : string * string -> string
    val isAbsolute  : string -> bool
    val isRelative  : string -> bool

    val isRoot      : string -> bool

    val concat      : string * string -> string

    val toUnixPath   : string -> string
    val fromUnixPath : string -> string

  end; (* OS_PATH *)

(* os-path-fn.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * A functorized implementation of the OS.Path structure.
 *
 * NOTE: these operations are currently not very efficient, since they
 * explode the path into its volume and arcs.  A better implementation
 * would work "in situ."
 *
 *)

functor OS_PathFn (OSPathBase : sig

    exception Path
    exception InvalidArc

    datatype arc_kind = Null | Parent | Current | Arc of string
    val classify : string -> arc_kind
    val parentArc : string
    val currentArc : string
    val validVolume : (bool * Substring.substring) -> bool
    val splitVolPath : string -> (bool * Substring.substring * Substring.substring)
	(* Split a string into the volume part and arcs part and note whether it
	 * is absolute.
	 * Note: it is guaranteed that this is never called with "".
	 *)
    val joinVolPath : (bool * string * string) -> string
	(* join a volume and path; raise Path on invalid volumes *)
    val arcSepChar : char
	(* the character used to separate arcs (e.g., #"/" on UNIX) *)

    val toUnixPath  : string -> string
    val fromUnixPath : string -> string

  end) :> OS_PATH = struct

    structure P = OSPathBase
    structure SS = Substring

    exception Path = P.Path
    exception InvalidArc = P.InvalidArc

    val arcSepStr = String.str P.arcSepChar

    val parentArc = P.parentArc
    val currentArc = P.currentArc

  (* concatArcs is like List.@@, except that a trailing empty arc in the
   * first argument is dropped.
   *)
    fun concatArcs ([], al2) = al2
      | concatArcs ([""], al2) = al2
      | concatArcs (a::al1, al2) = a :: concatArcs(al1, al2)

    fun validVolume {isAbs, vol} = P.validVolume(isAbs, SS.all vol)

    fun fromString "" = {isAbs = false, vol = "", arcs = []}
      | fromString p = let
	  val fields = SS.fields (fn c => (c = P.arcSepChar))
	  val (isAbs, vol, rest) = P.splitVolPath p
	  in
	    { isAbs = isAbs,
	      vol = SS.string vol,
	      arcs = List.map SS.string (fields rest)
	    }
	  end

    (* XXX -- raise InvalidArc *)
    fun toString {isAbs=false, vol, arcs="" :: _} = raise Path
      | toString {isAbs, vol, arcs} = let
	  fun f [] = [""]
	    | f [a] = [a]
	    | f (a :: al) = a :: arcSepStr :: (f al)
	  in
	    String.concat(P.joinVolPath(isAbs, vol, "") :: f arcs)
	  end

    fun getVolume p = #vol(fromString p)
    fun getParent p = let
	  fun getParent' [] = [parentArc]
	    | getParent' [a] = (case (P.classify a)
		 of P.Current => [parentArc]
		  | P.Parent => [parentArc, parentArc]
		  | P.Null => [parentArc]
		  | _ => []
		(* end case *))
	    | getParent' (a :: al) = a :: getParent' al
	  in
	    case (fromString p)
	     of {isAbs=true, vol, arcs=[""]} => p
	      | {isAbs=true, vol, arcs} =>
		  toString{isAbs = true, vol = vol, arcs = getParent' arcs}
	      | {isAbs=false, vol, arcs} => (case (getParent' arcs)
		   of [] => toString{isAbs=false, vol=vol, arcs=[currentArc]}
		    | al' => toString{isAbs=false, vol=vol, arcs=al'}
		  (* end case *))
	    (* end case *)
	  end

    fun splitDirFile p = let
	  val {isAbs, vol, arcs} = fromString p
	  fun split [] = ([], "")
	    | split [f] = ([], f)
	    | split (a :: al) = let val (d, f) = split al
		in
		  (a :: d, f)
		end
	  fun split' p = let val (d, f) = split p
		in
		  {dir=toString{isAbs=isAbs, vol=vol, arcs=d}, file=f}
		end
	  in
	    split' arcs
	  end
    (* XXX: May raise InvalidArc *)
    fun joinDirFile {dir="", file} = file
      | joinDirFile {dir, file} = let
	  val {isAbs, vol, arcs} = fromString dir
	  in
	    toString {isAbs=isAbs, vol=vol, arcs = concatArcs(arcs, [file])}
	  end
    fun dir p = #dir(splitDirFile p)
    fun file p = #file(splitDirFile p)
    
    fun splitBaseExt p = let
	  val {dir, file} = splitDirFile p
	  val (file', ext') = SS.splitr (fn c => c <> #".") (SS.all file)
	  val fileLen = SS.size file'
	  val (file, ext) =
		if (fileLen <= 1) orelse (SS.isEmpty ext')
		  then (file, NONE)
		  else (SS.string(SS.trimr 1 file'), SOME(SS.string ext'))
	  in
	    {base = joinDirFile{dir=dir, file=file}, ext = ext}
	  end
    fun joinBaseExt {base, ext=NONE} = base
      | joinBaseExt {base, ext=SOME ""} = base
      | joinBaseExt {base, ext=SOME ext} = let
	  val {dir, file} = splitDirFile base
	  in
	    joinDirFile{dir=dir, file=String.concat[file, ".", ext]}
	  end
    fun base p = #base(splitBaseExt p)
    fun ext p = #ext(splitBaseExt p)

    fun mkCanonical "" = currentArc
      | mkCanonical p = let
	  fun scanArcs ([], []) = [P.Current]
	    | scanArcs (l, []) = List.rev l
	    | scanArcs ([], [""]) = [P.Null]
	    | scanArcs (l, a::al) = (case (P.classify a)
		 of P.Null => scanArcs(l, al)
		  | P.Current => scanArcs(l, al)
		  | P.Parent => (case l
		      of (P.Arc _ :: r) => scanArcs(r, al)
		       | _ => scanArcs(P.Parent::l, al)
		     (* end case *))
		  | a' => scanArcs(a' :: l, al) 
		(* end case *))
	  fun scanPath relPath = scanArcs([], relPath)
	  fun mkArc (P.Arc a) = a
	    | mkArc (P.Parent) = parentArc
	    | mkArc _ = raise TiltExn.LibFail "mkCanonical: impossible"
	  fun filterArcs (true, P.Parent::r) = filterArcs (true, r)
	    | filterArcs (true, []) = [""]
	    | filterArcs (true, [P.Null]) = [""]
	    | filterArcs (true, [P.Current]) = [""]
	    | filterArcs (false, [P.Current]) = [currentArc]
	    | filterArcs (_, al) = List.map mkArc al
	  val {isAbs, vol, arcs} = fromString p
	  in
	    toString{
		isAbs=isAbs, vol=vol, arcs=filterArcs(isAbs, scanPath arcs)
	      }
	  end

    fun isCanonical p = (p = mkCanonical p)

    fun isAbsolute p = #isAbs(fromString p)
    fun isRelative p = Bool.not(#isAbs(fromString p))

    fun mkAbsolute (p1, p2) = (case (fromString p1, fromString p2)
	   of (_, {isAbs=false, ...}) => raise Path
	    | ({isAbs=true, ...}, _) => p1
	    | ({vol=v1, arcs=al1, ...}, {vol=v2, arcs=al2, ...}) => let
		fun mkCanon vol = mkCanonical(toString{
			isAbs=true, vol=vol, arcs=List.@@(al2, al1)
		     })
		in
		  if (v1 = v2) then mkCanon v1
		  else if (v1 = "") then mkCanon v2
		  else if (v2 = "") then mkCanon v1
		    else raise Path
		end
	  (* end case *))
    fun mkRelative (p1, p2) =
	  if (isAbsolute p2)
	    then if (isRelative p1)
	      then p1
	      else let
		val {vol=v1, arcs=al1, ...} = fromString p1
		val {vol=v2, arcs=al2, ...} = fromString(mkCanonical p2)
		fun strip (l, []) = mkArcs l
		  | strip ([], l) = dotDot([], l)
                  | strip (l1 as (x1::r1), l2 as (x2::r2)) = if (x1 = x2)
                      then strip (r1, r2)
                      else dotDot (l1, l2)
                and dotDot (al, []) = al
                  | dotDot (al, _::r) = dotDot(parentArc :: al, r)
		and mkArcs [] = [currentArc]
		  | mkArcs al = al
		in
		  if (v1 <> v2)
		    then raise Path
		    else (case (al1, al2)
		       of ([""], [""]) => currentArc
			| ([""], _) =>
			    toString{isAbs=false, vol="", arcs=dotDot([], al2)}
			| _ =>
			    toString{isAbs=false, vol="", arcs=strip(al1, al2)}
		      (* end case *))
		end
	    else raise Path

    fun isRoot path = (case (fromString path)
	   of {isAbs=true, arcs=[""], ...} => true
	    | _ => false
	  (* end case *))

    fun concat (p1, p2) = (case (fromString p1, fromString p2)
	   of (_, {isAbs=true, ...}) => raise Path
	    | ({isAbs, vol=v1, arcs=al1}, {vol=v2, arcs=al2, ...}) =>
		if ((v2 = "") orelse (v1 = v2))
		  then toString{isAbs=isAbs, vol=v1, arcs=concatArcs(al1, al2)}
		  else raise Path
	  (* end case *))

    val toUnixPath = P.toUnixPath
    val fromUnixPath = P.fromUnixPath
  end;


(* os-process-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * The generic process control interface.
 *
 *)

signature OS_PROCESS =
  sig

    eqtype status

    val success   : status
    val failure   : status

    val system    : string -> status

    val atExit    : (unit -> unit) -> unit

    val exit      : status -> 'a
    val terminate : status -> 'a

    val getEnv : string -> string option

  end

(* os-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature OS =
  sig
    eqtype syserror

    exception SysErr of string * syserror option
    
    val errorMsg : syserror -> string
    val errorName : syserror -> string
    val syserror : string -> syserror option

    structure FileSys : OS_FILE_SYS
    structure Path : OS_PATH
    structure Process : OS_PROCESS
    structure IO : OS_IO

  end;


(* pre-os.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This the OS structure(s) with only types, so that the signatures can compile.
 *
 *)

structure PreOS =
  struct
    type syserror = int                     (* the integer code; we may need to beef this up *)

    exception SysErr = TiltExn.SysErr


    structure Process =
      struct
	type status = int (* should this be Word8.word ?*)
      end

    structure IO =
      struct
	datatype iodesc = IODesc of int
	type poll_flags = {rd : bool, wr : bool, pri : bool}
	datatype poll_desc = PollDesc of (iodesc * poll_flags)
	datatype poll_info = PollInfo of (iodesc * poll_flags)
      end

  end;




(* io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature IO =
  sig

    exception Io of {
	name : string,
	function : string,
	cause : exn
      }

    exception BlockingNotSupported
    exception NonblockingNotSupported
    exception RandomAccessNotSupported
    exception TerminatedStream
    exception ClosedStream

    datatype buffer_mode = NO_BUF | LINE_BUF | BLOCK_BUF

  end


(* io.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure IO :> IO =
  struct

    exception Io of {
	name : string,
	function : string,
	cause : exn
      }

    exception BlockingNotSupported
    exception NonblockingNotSupported
    exception RandomAccessNotSupported
    exception TerminatedStream
    exception ClosedStream

    datatype buffer_mode = NO_BUF | LINE_BUF | BLOCK_BUF

  end


(* stream-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature STREAM_IO =
  sig
    type elem
    type vector
    type reader
    type writer

    type instream
    type outstream

    type in_pos
    type out_pos
    type pos

    val input       : instream -> vector * instream
    val input1      : instream -> (elem * instream) option
    val inputN      : instream * int -> vector * instream
    val inputAll    : instream -> vector * instream
    val canInput    : instream * int -> int option
    val closeIn     : instream -> unit
    val endOfStream : instream -> bool
    val mkInstream  : reader * vector option -> instream
    val getReader   : instream -> reader * vector
    val getPosIn    : instream -> in_pos
    val setPosIn    : in_pos -> instream
    val filePosIn   : in_pos -> pos

    val output        : outstream * vector -> unit
    val output1       : outstream * elem -> unit
    val flushOut      : outstream -> unit
    val closeOut      : outstream -> unit
    val setBufferMode : outstream * IO.buffer_mode -> unit
    val getBufferMode : outstream -> IO.buffer_mode
    val mkOutstream   : writer * IO.buffer_mode -> outstream
    val getWriter     : outstream -> writer * IO.buffer_mode
    val getPosOut     : outstream -> out_pos
    val setPosOut     : out_pos -> unit
    val filePosOut    : out_pos -> pos

  end
  
(* imperative-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature IMPERATIVE_IO =
  sig
    structure StreamIO : STREAM_IO

    type vector = StreamIO.vector
    type elem = StreamIO.elem

    type instream
    type outstream

    val input    : instream -> vector
    val input1   : instream -> elem option
    val inputN   : instream * int -> vector
    val inputAll : instream -> vector
    val canInput : instream * int -> int option
	
    val lookahead : instream -> elem option
    val closeIn : instream -> unit
    val endOfStream : instream -> bool

    val output   : outstream * vector -> unit
    val output1  : outstream * elem -> unit
    val flushOut : outstream -> unit
    val closeOut : outstream -> unit

    val getPosIn    : instream -> StreamIO.in_pos
    val setPosIn    : instream * StreamIO.in_pos -> unit
    val mkInstream  : StreamIO.instream -> instream
    val getInstream : instream -> StreamIO.instream
    val setInstream : instream * StreamIO.instream -> unit

    val getPosOut    : outstream -> StreamIO.out_pos
    val setPosOut    : outstream * StreamIO.out_pos -> unit
    val mkOutstream  : StreamIO.outstream -> outstream
    val getOutstream : outstream -> StreamIO.outstream
    val setOutstream : outstream * StreamIO.outstream -> unit

  end;

(* bin-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature BIN_IO =
  sig
    include IMPERATIVE_IO
      where type StreamIO.vector = Word8Vector.vector
        and type StreamIO.elem = Word8.word

    val openIn     : string -> instream
    val openOut    : string -> outstream
    val openAppend : string -> outstream
  end

(* prim-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature PRIM_IO =
  sig
    type array
    type vector
    type elem
    eqtype pos

    val compare : pos * pos -> order

    datatype reader = RD of {
	name      : string, 
	chunkSize : int,
	readVec   : (int -> vector) option,
        readArr   : ({buf : array, i : int, sz : int option} -> int) option,
	readVecNB : (int -> vector option) option,
	readArrNB : ({buf : array, i : int, sz : int option} -> int option) option,
	block     : (unit -> unit) option,
	canInput  : (unit -> bool) option,
	avail     : unit -> int option,
	getPos    : (unit -> pos) option,
	setPos    : (pos -> unit) option,
        endPos    : (unit -> pos) option,
	verifyPos : (unit -> pos) option,
	close     : unit -> unit,
	ioDesc    : PreOS.IO.iodesc option
      }

    datatype writer = WR of {
	name       : string,
	chunkSize  : int,
	writeVec   : ({buf : vector, i : int, sz : int option} -> int) option,
	writeArr   : ({buf : array, i : int, sz : int option} -> int) option,
	writeVecNB : ({buf : vector, i : int, sz : int option} -> int option) option,
	writeArrNB : ({buf : array, i : int, sz : int option} -> int option) option,
	block      : (unit -> unit) option,
	canOutput  : (unit -> bool) option,
	getPos     : (unit -> pos) option,
	setPos     : (pos -> unit) option,
        endPos     : (unit -> pos) option,
	verifyPos  : (unit -> pos) option,
	close      : unit -> unit,
	ioDesc     : PreOS.IO.iodesc option
      }

    val augmentReader : reader -> reader
    val augmentWriter : writer -> writer

  end


(* os-prim-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This is an interface to a PrimIO structure augmented with OS specific
 * functions to create readers and writers.
 *
 *)

signature OS_PRIM_IO =
  sig
    structure PrimIO : PRIM_IO

    type file_desc

    val openRd  : string -> PrimIO.reader
    val openWr  : string -> PrimIO.writer
    val openApp : string -> PrimIO.writer

    val mkReader : {
	    fd : file_desc,
	    name : string,
  	    initBlkMode : bool
	  } -> PrimIO.reader
    val mkWriter: {
	    fd : file_desc,
	    name : string,
	    appendMode : bool,
	    initBlkMode : bool, 
	    chunkSize : int
	  } -> PrimIO.writer

  end


(* prim-io-fn.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

(* Note: this is not the standard PrimIO functor. *)

functor PrimIOFn (structure A : MONO_ARRAY
		      sharing type A.elem = A.Vector.elem
		  val someElem : A.elem
		  eqtype pos
		  val compare : (pos * pos) -> order)
    :> PRIM_IO where type array = A.array
		 and type vector = A.Vector.vector
		 and type elem = A.elem
		 and type pos = pos =
struct

    structure V = A.Vector
    type array = A.array
    type vector = V.vector
    type elem = A.elem
    type pos = pos

    val compare = compare

    datatype reader = RD of {
	name      : string,
	chunkSize : int,
	readVec   : (int -> vector) option,
        readArr   : ({buf : array, i : int, sz : int option} -> int) option,
	readVecNB : (int -> vector option) option,
	readArrNB : ({buf : array, i : int, sz : int option} -> int option) option,
	block     : (unit -> unit) option,
	canInput  : (unit -> bool) option,
	avail     : unit -> int option,
	getPos    : (unit -> pos) option,
	setPos    : (pos -> unit) option,
        endPos    : (unit -> pos) option,
	verifyPos : (unit -> pos) option,
	close     : unit -> unit,
	ioDesc    : PreOS.IO.iodesc option
      }

    datatype writer = WR of {
	name       : string,
	chunkSize  : int,
	writeVec   : ({buf : vector, i : int, sz : int option} -> int) option,
	writeArr   : ({buf : array, i : int, sz : int option} -> int) option,
	writeVecNB : ({buf : vector, i : int, sz : int option} -> int option) option,
	writeArrNB : ({buf : array, i : int, sz : int option} -> int option) option,
	block      : (unit -> unit) option,
	canOutput  : (unit -> bool) option,
	getPos     : (unit -> pos) option,
	setPos     : (pos -> unit) option,
        endPos     : (unit -> pos) option,
	verifyPos  : (unit -> pos) option,
	close      : unit -> unit,
	ioDesc     : PreOS.IO.iodesc option
      }

    fun blockingOperation (f, block) x = (block (); Option.valOf (f x))

    fun nonblockingOperation (read, canInput) x =
	  if (canInput()) then SOME(read x) else NONE

    fun augmentReader (RD rd) = let
	  fun readaToReadv reada n = let
		val a = A.array(n, someElem)
		val n = reada{buf=a, i=0, sz=NONE}
		in
		  A.extract(a, 0, SOME n)
		end
	  fun readaToReadvNB readaNB n = let
		val a = A.array(n, someElem)
		in
		  case readaNB{buf=a, i=0, sz=NONE}
		   of SOME n' => SOME(A.extract(a, 0, SOME n'))
		    | NONE => NONE  
		  (* end case *)
		end
	  fun readvToReada readv {buf, i, sz} = let
		val nelems = (case sz of NONE => A.length buf - i | SOME n => n)
		val v = readv nelems
		val len = V.length v
		in
		  A.copyVec {dst=buf, di=i, src=v, si=0, len=NONE};
		  len
		end
	  fun readvToReadaNB readvNB {buf, i, sz} = let
		val nelems = (case sz of NONE => A.length buf - i | SOME n => n)
		in
		  case readvNB nelems
		   of SOME v => let
			val len = V.length v
			in
			  A.copyVec {dst=buf, di=i, src=v, si=0, len=NONE};
			  SOME len
			end
		    | NONE => NONE
		  (* end case *)
		end
	  val readVec' = (case rd
		 of {readVec=SOME f, ...} => SOME f
		  | {readArr=SOME f, ...} => SOME(readaToReadv f)
		  | {readVecNB=SOME f, block=SOME b, ...} =>
		      SOME(blockingOperation (f, b))
		  | {readArrNB=SOME f, block=SOME b, ...} =>
		      SOME(blockingOperation (readaToReadvNB f, b))
		  | _ => NONE
		(* end case *))
	  val readArr' = (case rd
		 of {readArr=SOME f, ...} => SOME f
		  | {readVec=SOME f, ...} => SOME(readvToReada f)
		  | {readArrNB=SOME f, block=SOME b, ...} =>
		      SOME(blockingOperation(f, b))
		  | {readVecNB=SOME f,block=SOME b, ...} =>
		      SOME(blockingOperation(readvToReadaNB f, b))
		  | _ => NONE
		(* end case *))
	  val readVecNB' = (case rd
		 of {readVecNB=SOME f, ...} => SOME f
		  | {readArrNB=SOME f, ...} => SOME(readaToReadvNB f)
		  | {readVec=SOME f, canInput=SOME can, ...} =>
		      SOME(nonblockingOperation(f, can))
		  | {readArr=SOME f, canInput=SOME can, ...} =>
		      SOME(nonblockingOperation(readaToReadv f, can))
		  | _ => NONE
		(* end case *))
	  val readArrNB' = (case rd
		 of {readArrNB=SOME f, ...} => SOME f
		  | {readVecNB=SOME f, ...} => SOME(readvToReadaNB f)
		  | {readArr=SOME f, canInput=SOME can, ...} =>
		      SOME(nonblockingOperation (f, can))
		  | {readVec=SOME f, canInput=SOME can, ...} =>
		      SOME(nonblockingOperation (readvToReada f, can))
		  | _ => NONE
		(* end case *))
	  in RD{
	      name= #name rd, chunkSize= #chunkSize rd,
	      readVec=readVec', readArr=readArr',
	      readVecNB=readVecNB', readArrNB=readArrNB',
	      block= #block rd, canInput = #canInput rd, avail = #avail rd,
	      getPos = #getPos rd, setPos = #setPos rd, endPos = #endPos rd, 
	      verifyPos = #verifyPos rd,
	      close= #close rd,
	      ioDesc= #ioDesc rd
	    }
	  end

    fun augmentWriter (WR wr) = let
	  fun writevToWritea writev {buf, i, sz} = let
		val v = A.extract(buf, i, sz)
		in
		  writev{buf=v, i=0, sz=NONE}
		end
	  fun writeaToWritev writea {buf, i, sz} = let
		val n = (case sz of NONE => V.length buf - i | (SOME n) => n)
		in
		  case n
		   of 0 => 0
		    | _ => let
			val a = A.array(n, V.sub(buf, i))
			in
			  A.copyVec {dst=a, di=1, src=buf, si=i+1, len=SOME(n-1)};
			  writea {buf=a, i=0, sz=NONE}
			end
		  (* end case *)
		end
	  fun writeaToWritevNB writeaNB {buf, i, sz} = let
		val n = (case sz of NONE => V.length buf - i | (SOME n) => n)
		in
		  case n
		   of 0 => SOME 0
		    | _ => let
			val a = A.array(n, V.sub(buf, i))
			in
			  A.copyVec {dst=a, di=1, src=buf, si=i+1, len=SOME(n-1)};
			  writeaNB {buf=a, i=0, sz=NONE}
			end
		  (* end case *)
		end
	  val writeVec' = (case wr
		 of {writeVec=SOME f, ...} => SOME f
		  | {writeArr=SOME f, ...} => SOME(writeaToWritev f)
		  | {writeVecNB=SOME f, block=SOME b, ...} => 
		      SOME(fn i => (b(); Option.valOf(f i)))
		  | {writeArrNB=SOME f, block=SOME b, ...} =>
		      SOME(fn x => (b(); writeaToWritev (Option.valOf o f) x)) 
		  | _ => NONE
		(* end case *))
	  val writeArr' = (case wr
		 of {writeArr=SOME f, ...} => SOME f
		  | {writeVec=SOME f, ...} => SOME(writevToWritea f)
		  | {writeArrNB=SOME f, block=SOME b, ...} => SOME(blockingOperation (f, b))
		  | {writeVecNB=SOME f,block=SOME b, ...} =>
		      SOME(blockingOperation (writevToWritea f, b))
		  | _ => NONE
		(* end case *))
	  val writeVecNB' = (case wr
		 of {writeVecNB=SOME f, ...} => SOME f
		  | {writeArrNB=SOME f, ...} => SOME(writeaToWritevNB f)
		  | {writeVec=SOME f, canOutput=SOME can, ...} =>
		      SOME(nonblockingOperation (f, can))
		  | {writeArr=SOME f, canOutput=SOME can, ...} =>
		      SOME(nonblockingOperation (writeaToWritev f, can))
		  | _ => NONE
		(* end case *))
	  val writeArrNB' = (case wr
		 of {writeArrNB=SOME f, ...} => SOME f
		  | {writeVecNB=SOME f, ...} => SOME(writevToWritea f)
		  | {writeArr=SOME f, canOutput=SOME can, ...} =>
		      SOME(nonblockingOperation (f, can))
		  | {writeVec=SOME f, canOutput=SOME can, ...} =>
		      SOME(nonblockingOperation (writevToWritea f, can))
		  | _ => NONE
		(* end case *))
	  in WR{
	      name= #name wr, chunkSize= #chunkSize wr,
	      writeVec=writeVec', writeArr=writeArr',
	      writeVecNB=writeVecNB', writeArrNB=writeArrNB',
	      block= #block wr, canOutput = #canOutput wr,
	      getPos = #getPos wr, setPos = #setPos wr, endPos = #endPos wr,
	      verifyPos = #verifyPos wr,
	      close= #close wr,
	      ioDesc= #ioDesc wr
	    }
	  end

  end (* PrimIO *)


(* text-prim-io.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

structure TextPrimIO = PrimIOFn (structure A = CharArray
				 val someElem = #"\000"
				 type pos = Position.int
				 val compare = Position.compare);
    

(* cleanup-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This provides a mechanism for registering actions that should be performed
 * at initialization or termination time.  We define five distinct contexts
 * for a hook:
 *
 *	AtExportML	just prior to exporting a heap image (exportML).
 *	AtExportFn	exit because of exportFn.
 *	AtExit		normal program exit.
 *	AtInit		initialization of a program that was generated by exportML.
 *	AtInitFn	initialization of a program that was generated by exportFn.
 *
 *)

signature CLEAN_UP =
  sig

    datatype when = AtExportML | AtExportFn | AtExit | AtInit | AtInitFn

    val atAll : when list
	(* at all times *)

    val addCleaner    : (string * when list * (when -> unit))
	  -> (when list * (when -> unit)) option
	(* add the named cleaner.  This returns the previous definition, or NONE. *)

    val removeCleaner : string -> (when list * (when -> unit)) option
	(* remove and return the named cleaner; return NONE if it is not found *)

  end (* CLEAN_UP *)


(* cleanup.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This provides a mechanism for registering actions that should be performed
 * at initialization or termination time.  We define five distinct contexts
 * for a hook:
 *
 *	AtExportML	just prior to exporting a heap image (exportML).
 *	AtExportFn	exit because of exportFn.
 *	AtExit		normal program exit.
 *	AtInit		initialization of a program that was generated by exportML.
 *	AtInitFn	initialization of a program that was generated by exportFn.
 *
 *)

structure CleanUp : sig

    include CLEAN_UP

    val clean : when -> unit

  end = struct

    datatype when = AtExportML | AtExportFn | AtExit | AtInit | AtInitFn

    val atAll = [AtExportML, AtExportFn, AtExit, AtInit, AtInitFn]

    val hooks = ref ([] : (string * when list * (when -> unit)) list)

  (* return the list of hooks that apply at when. *)
    fun filter when = let
	  fun f [] = []
	    | f ((item as (_, whenLst, _))::r) =
		  if (List.exists when whenLst) then item :: (f r) else (f r)
	  in
	    f (!hooks)
	  end

  (* apply the clean-up function for the given time.  In some cases, this
   * causes the list of hooks to be redefined.
   * NOTE: we reverse the order of application at initialization time.
   *)
    fun clean when = let
	  val cleanFns = (case when of
			      AtInit =>  List.rev (filter (fn w => (w = when)))
			    | AtInitFn => List.rev (filter (fn w => (w = when)))
			    | _ => filter (fn w => (w = when)))
	  fun exportFnPred AtInitFn = true
	    | exportFnPred AtExit = true
	    | exportFnPred _ = false
	  fun initFnPred AtExit = true
	    | initFnPred _ = false
	  in
	  (* remove uneccesary clean-up routines *)
	    case when
	     of AtExportFn => hooks := filter exportFnPred
	      | AtInitFn => hooks := filter initFnPred
	      | _ => ()
	    (* end case *);
	  (* now apply the clean-up routines *)
	    List.app (fn (_, _, f) => (f when) handle _ => ()) cleanFns
	  end

  (* find and remove the named hook from the hook list; return the hook
   * and the new hook list; if the named hook doesn't exist, then return NONE.
   *)
    fun removeHook name = let
	  fun remove [] = NONE
	    | remove ((hook as (name', whenLst, cleanFn)) :: r) =
		if (name = name')
		  then SOME((whenLst, cleanFn), r)
		  else (case (remove r)
		     of NONE => NONE
		      | SOME(hook', r') => SOME(hook', hook::r')
		    (* end case *))
	  in
	    remove (! hooks)
	  end

  (* add the named cleaner.  This returns the previous definition, or NONE. *)
    fun addCleaner (arg as (name, _, _)) = (case (removeHook name)
	   of NONE => (hooks := arg :: !hooks; NONE)
	    | (SOME(oldHook, hookLst)) => (
		hooks := arg :: hookLst; SOME oldHook)
	  (* end case *))

  (* remove and return the named cleaner; return NONE if it is not found *)
    fun removeCleaner name = (case (removeHook name)
	   of NONE => NONE
	    | (SOME(oldHook, hookLst)) => (
		hooks := hookLst; SOME oldHook)
	  (* end case *))

  end (* CleanUp *)

(* clean-io.sml
 *
 * COPYRIGHT (c) 1996 AT&T Research.
 *
 * This module keeps track of open I/O streams, and handles the proper
 * cleaning of them.
 *
 * NOTE: there is currently a problem with removing the cleaners for streams
 * that get dropped by the application, but the system limit on open files
 * will limit this.
 *
 *)

structure CleanIO :> sig

    type tag

    val osInitHook : (unit -> unit) ref
	(* this function gets invoked as the first action during the IO
	 * initialization.  It is meant to support any OS specific initialization
	 * that might be necessary.
	 *)

    val stdStrmHook : (unit -> unit) ref

    val addCleaner : {
	    init : unit -> unit,	(* called AtInit and AtInitFn *)
	    flush : unit -> unit,	(* called AtExportML *)
	    close : unit -> unit	(* called AtExit and AtExportFn *)
	  } -> tag

    val rebindCleaner : (tag * {
	    init : unit -> unit,	(* called AtInit and AtInitFn *)
	    flush : unit -> unit,	(* called AtExportML *)
	    close : unit -> unit	(* called AtExit and AtExportFn *)
	  })-> unit

    val removeCleaner : tag -> unit

  end = struct

    type tag = unit ref

    type cleaner = {
	tag : tag,		(* unique ID for this cleaner *)
	init : unit -> unit,	(* called AtInit and AtInitFn *)
	flush : unit -> unit,	(* called AtExportML *)
	close : unit -> unit	(* called AtExit and AtExportFn *)
      }

    val osInitHook = ref(fn () => ())
    val stdStrmHook = ref(fn () => ())

    val cleaners = ref ([] : cleaner list)

    fun addCleaner {init, flush, close} = let
	  val tag = ref()
	  val cleanerRec = {tag = tag, init = init, flush = flush, close = close}
	  in
	    cleaners := cleanerRec :: !cleaners;
	    tag
	  end

    fun getTag ({tag, ...} : cleaner) = tag

    fun rebindCleaner (t, {init, flush, close}) = let
	  fun f [] = raise TiltExn.LibFail "rebindCleaner: tag not found"
	    | f (x :: r) = let
		val t' = getTag x
		in
		  if (t' = t)
		    then {tag=t, init=init, flush=flush, close=close} :: r
		    else x :: f r
		end
	  in
	    cleaners := f (! cleaners)
	  end

    fun removeCleaner t = let
	  fun f [] = []		(* should we raise an exception here? *)
	    | f (x :: r) = if (getTag x = t) then r else x :: f r
	  in
	    cleaners := f (! cleaners)
	  end

    fun doClean selFn = let
	  fun doit [] = ()
	    | doit (x::r) = (((selFn x)()) handle _ => (); doit r)
	  in
	     doit (! cleaners)
	  end
(*
    structure C = CleanUp

    fun cleanUp (C.AtExportML) = doClean #flush
      | cleanUp (C.AtExportFn | C.AtExit) = doClean #close
      | cleanUp (C.AtInit | C.AtInitFn) = (
	  (!osInitHook)();
	  (!stdStrmHook)();
	  doClean #init)

    val _ = C.addCleaner ("IO", C.atAll, cleanUp)
*)

  end (* CleanIO *)


(* bin-prim-io.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)


structure BinPrimIO = PrimIOFn (structure A = Word8Array
				val someElem = (#"\000" : Word8.word)
				type pos = Position.int
				val compare = Position.compare)


(* bin-io-fn.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * QUESTION: what operations should raise exceptions when the stream is
 * closed?
 *
 *)

functor BinIOFn (structure OSPrimIO : OS_PRIM_IO
		     where PrimIO = BinPrimIO)
    :> BIN_IO where type StreamIO.pos = BinPrimIO.pos
                and type StreamIO.reader = BinPrimIO.reader
		and type StreamIO.writer = BinPrimIO.writer =
struct

    structure PIO = OSPrimIO.PrimIO
    structure A = Word8Array
    structure V = Word8Vector
    structure Pos = Position

  (* an element for initializing buffers *)
    val someElem = (#"\000" : Word8.word)

(** Fast, but unsafe version (from Word8Vector) **
    val vecSub = InlineT.Word8Vector.sub
    val arrUpdate = InlineT.Word8Array.update
  (* fast vector extract operation.  This should never be called with
   * a length of 0.
   *)
    fun vecExtract (v, base, optLen) = let
	  val len = V.length v
	  fun newVec n = let
		val newV = Assembly.A.create_s n
		fun fill i = if (i < n)
		      then (
			InlineT.Word8Vector.update(newV, i, vecSub(v, base+i));
			fill(i+1))
		      else ()
		in
		  fill 0; newV
		end
	  in
	    case (base, optLen)
	     of (0, NONE) => v
	      | (_, NONE) => newVec (len - base)
	      | (_, SOME n) => newVec n
	    (* end case *)
	  end
**)
    val vecExtract = V.extract
    val vecSub = V.sub
    val arrUpdate = A.update
    val empty = V.fromList[]

    structure StreamIO =
      struct
	type vector = V.vector
	type elem = V.elem
	type reader = PIO.reader
	type writer = PIO.writer
	type pos = PIO.pos

      (*** Functional input streams ***)
	datatype instream = ISTRM of (in_buffer * int)
	and in_buffer = IBUF of {
	    basePos : pos option,
	    more : more ref,
	    data : vector,
	    info : info
	  }
	and more
	  = MORE of in_buffer	(* forward link to additional data *)
	  | NOMORE		(* placeholder for forward link *)
	  | TERMINATED		(* termination of the stream *)

	and info = INFO of {
	    reader : reader,
	    readVec : int -> vector,
	    readVecNB : (int -> vector) option,
	    closed : bool ref,
	    getPos : unit -> pos option,
	    tail : more ref ref, (* points to the more cell of the last buffer *)
	    cleanTag : CleanIO.tag
	  }

	fun infoOfIBuf (IBUF{info, ...}) = info
	fun chunkSzOfIBuf buf = let
	      val INFO{reader=PIO.RD{chunkSize, ...}, ...} = infoOfIBuf buf
	      in
		chunkSize
	      end
	fun readVec (IBUF{info=INFO{readVec=f, ...}, ...}) = f

	fun inputExn (INFO{reader=PIO.RD{name, ...}, ...}, mlOp, exn) =
	      raise IO.Io{function=mlOp, name=name, cause=exn}

      (* this exception is raised by readVecNB in the blocking case *)
	exception WouldBlock

	datatype more_data = EOF | DATA of in_buffer

	fun extendStream (readFn, mlOp, buf as IBUF{more, info, ...}) = (let
	      val INFO{getPos, tail, ...} = info
              val basePos = getPos()
	      val chunk = readFn (chunkSzOfIBuf buf)
	      in
		if (V.length chunk = 0)
		  then EOF
		  else let
		    val newMore = ref NOMORE
		    val buf' = IBUF{
                            basePos = basePos, data = chunk,
			    more = newMore, info = info
			  }
		    in
		      more := MORE buf';
		      tail := newMore;
		      DATA buf'
		    end
	      end
		handle ex => inputExn(info, mlOp, ex))

	fun getBuffer (readFn, mlOp) (buf as IBUF{more, info, ...}) = (
	      case !more
	       of TERMINATED => EOF
		| NOMORE => extendStream (readFn, mlOp, buf)
		| (MORE buf') => DATA buf'
	      (* end case *))

      (* read a chunk that is at least the specified size *)
	fun readChunk buf = let
	      val INFO{readVec, reader=PIO.RD{chunkSize, ...}, ...} =
		     infoOfIBuf buf
	      in
		case (chunkSize - 1)
		 of 0 => (fn n => readVec n)
		  | k => (* round up to next multiple of chunkSize *)
		      (fn n => readVec(Int.quot((n+k), chunkSize) * chunkSize))
		(* end case *)
	      end

	fun generalizedInput getBuf = let
	      fun get (ISTRM(buf as IBUF{data, ...}, pos)) = let
		    val len = V.length data
		    in
		      if (pos < len)
			then (vecExtract(data, pos, NONE), ISTRM(buf, len))
			else (case (getBuf buf)
			   of EOF => (empty, ISTRM(buf, len))
			    | (DATA rest) => get (ISTRM(rest, 0))
			  (* end case *))
		    end
	      in
		get
	      end

      (* terminate an input stream *)
	fun terminate (INFO{tail, cleanTag, ...}) = (case !tail
	       of (m as ref NOMORE) => (
		    CleanIO.removeCleaner cleanTag;
		    m := TERMINATED)
		| (m as ref TERMINATED) => ()
	      (* end case *))

      (* find the end of the stream *)
	fun findEOS (IBUF{more=ref(MORE buf), ...}) = findEOS buf
	  | findEOS (buf as IBUF{data, ...}) = ISTRM(buf, V.length data)

	fun input (strm as ISTRM(buf, _)) =
	      generalizedInput (getBuffer (readVec buf, "input")) strm
	fun input1 (ISTRM(buf, pos)) = let
	      val IBUF{data, more, ...} = buf
	      in
		if (pos < V.length data)
		  then SOME(vecSub(data, pos), ISTRM(buf, pos+1))
		  else (case !more
		     of (MORE buf) => input1 (ISTRM(buf, 0))
		      | NOMORE => (
			  case extendStream (readVec buf, "input1", buf)
			   of EOF => NONE
			    | (DATA rest) => input1 (ISTRM(rest, 0))
			  (* end case *))
		      | TERMINATED => NONE
		    (* end case *))
	      end
	fun inputN (ISTRM(buf, pos), n) = let
	      fun join (item, (list, strm)) = (item::list, strm)
	      fun inputList (buf as IBUF{data, ...}, i, n) = let
		    val len = V.length data
		    val remain = len-i
		    in
		      if (remain >= n)
			then ([vecExtract(data, i, SOME n)], ISTRM(buf, i+n))
		      else join (
			vecExtract(data, i, NONE),
			nextBuf(buf, n-remain))
		    end
	      and nextBuf (buf as IBUF{more, data, ...}, n) = (case !more
		     of (MORE buf) => inputList (buf, 0, n)
		      | NOMORE => (
			  case extendStream (readVec buf, "inputN", buf)
			   of EOF => ([], ISTRM(buf, V.length data))
			    | (DATA rest) => inputList (rest, 0, n)
			  (* end case *))
		      | TERMINATED => ([], ISTRM(buf, V.length data))
		    (* end case *))
	      val (data, strm) = inputList (buf, pos, n)
	      in
		(V.concat data, strm)
	      end

	fun inputAll (strm as ISTRM(buf, _)) = let
	      val INFO{reader=PIO.RD{avail, ...}, ...} = infoOfIBuf buf
 	    (* read a chunk that is as large as the available input.  Note
	     * that for systems that use CR-LF for #"\n", the size will be
	     * too large, but this should be okay.
	     *)
	      fun bigChunk _ = let
		    val delta = (case avail()
			   of NONE => chunkSzOfIBuf buf
			    | (SOME n) => n
			  (* end case *))
		    in
		      readChunk buf delta
		    end
	      val bigInput =
		    generalizedInput (getBuffer (bigChunk, "inputAll"))
	      fun loop (v, strm) =
		    if (V.length v = 0) then [] else v :: loop(bigInput strm)
	      val data = V.concat (loop (bigInput strm))
	      in
		(data, findEOS buf)
	      end
      (* Return SOME k, if k <= amount characters can be read without blocking. *)
	fun canInput (strm as ISTRM(buf, pos), amount) = let
	      val readVecNB = (case buf
		   of (IBUF{info as INFO{readVecNB=NONE, ...}, ...}) =>
			inputExn(info, "canInput", IO.NonblockingNotSupported)
		    | (IBUF{info=INFO{readVecNB=SOME f, ...}, ...}) => f
		  (* end case *))
	      fun tryInput (buf as IBUF{data, ...}, i, n) = let
		    val len = V.length data
		    val remain = len - i
		    in
		      if (remain >= n)
			then SOME n
			else nextBuf (buf, n - remain)
		    end
	      and nextBuf (IBUF{more, ...}, n) = (case !more
		     of (MORE buf) => tryInput (buf, 0, n)
		      | TERMINATED => SOME(amount - n)
		      | NOMORE => ((
			  case extendStream (readVecNB, "canInput", buf)
			   of EOF => SOME(amount - n)
			    | (DATA b) => tryInput (b, 0, n)
			  (* end case *))
			    handle IO.Io{cause=WouldBlock, ...} => SOME(amount - n))
		    (* end case *))
	      in
		if (amount < 0)
		  then raise Size
		  else tryInput (buf, pos, amount)
	      end
	fun closeIn (ISTRM(buf, _)) = (case (infoOfIBuf buf)
	       of INFO{closed=ref true, ...} => ()
		| (info as INFO{closed, reader=PIO.RD{close, ...}, ...}) => (
		    terminate info;
		    closed := true;
		    close() handle ex => inputExn(info, "closeIn", ex))
	      (* end case *))
	fun endOfStream (ISTRM(buf, pos)) = (case buf
	       of (IBUF{more=ref(MORE _), ...}) => false
		| (IBUF{more, data, info=INFO{closed, ...}, ...}) =>
		    if (pos = V.length data)
		      then (case (!more, !closed)
			 of (NOMORE, false) => (
			      case extendStream (readVec buf, "endOfStream", buf)
			       of EOF => true
				| _ => false
			    (* end case *))
			  | _ => true
			(* end case *))
		      else false
	      (* end case *))
	fun mkInstream (reader, optData) = let
	      val PIO.RD{readVec, readVecNB, getPos, setPos, ...} = reader
	      val readVec' = (case readVec
		     of NONE => (fn _ => raise IO.BlockingNotSupported)
		      | (SOME f) => f
		    (* end case *))
	      val readVecNB' = (case readVecNB
		     of NONE => NONE
		      | (SOME f) => SOME(fn arg => case (f arg)
			   of (SOME x) => x
			    | NONE => raise WouldBlock
			  (* end case *))
		    (* end case *))
	      val getPos = (case (getPos, setPos)
		     of (SOME f, SOME _) => (fn () => SOME(f()))
		      | _ => (fn () => NONE)
		    (* end case *))
	      val more = ref NOMORE
	      val closedFlg = ref false
	      val tag = CleanIO.addCleaner {
		      init = fn () => (closedFlg := true),
		      flush = fn () => (),
		      close = fn () => (closedFlg := true)
		    }
	      val info = INFO{
		      reader=reader, readVec=readVec', readVecNB=readVecNB',
		      closed = closedFlg, getPos = getPos, tail = ref more,
		      cleanTag = tag
		    }
	      val buf = (case optData
		     of NONE => IBUF{
			    basePos = getPos(), data=empty,
			    info=info, more=more
			  }
(** What should we do about the position in this case ?? **)
(** Suggestion: When building a stream with supplied initial data,
 ** nothing can be said about the positions inside that initial
 ** data (who knows where that data even came from!).
 **) 
		      | (SOME v) => IBUF{
			    basePos = NONE, data=v,
			    info=info, more=more}
		    (* end case *))
	      in
		ISTRM(buf, 0)
	      end
	fun getReader (ISTRM(buf, pos)) = let
	      val IBUF{data, info as INFO{reader, ...}, more, ...} = buf
	      fun getData (MORE(IBUF{data, more, ...})) = data :: getData(!more)
		| getData _ = []
	      in
		terminate info;
		if (pos < V.length data)
		  then (
		      reader,
		      V.concat(vecExtract(data, pos, NONE) :: getData(!more))
		    )
		  else (reader, V.concat(getData(!more)))
	      end

      (** Position operations on instreams **)
	datatype in_pos = INP of {
	    base : pos,
	    offset : int,
	    info : info
	  }

	fun getPosIn (ISTRM(buf, pos)) = (case buf
	       of IBUF{basePos=NONE, info, ...} =>
		    inputExn (info, "getPosIn", IO.RandomAccessNotSupported)
		| IBUF{basePos=SOME p, info, ...} => INP{
		      base = p, offset = pos, info = info
		    }
	      (* end case *))
	fun filePosIn (INP{base, offset, ...}) =
	      Position.+(base, Position.fromInt offset)
	fun setPosIn (pos as INP{info as INFO{reader, ...}, ...}) = let
	      val fpos = filePosIn pos
	      val (PIO.RD rd) = reader
	      in
		terminate info;
		Option.valOf (#setPos rd) fpos;
		mkInstream (PIO.RD rd, NONE)
	      end


      (*** Output streams ***)
	datatype outstream = OSTRM of {
	    buf : A.array,
	    pos : int ref,
	    closed : bool ref,
	    bufferMode : IO.buffer_mode ref,
	    writer : writer,
	    writeArr : {buf : A.array, i : int, sz : int option} -> unit,
	    writeVec : {buf : V.vector, i : int, sz : int option} -> unit,
	    cleanTag : CleanIO.tag
	  }

	fun outputExn (OSTRM{writer=PIO.WR{name, ...}, ...}, mlOp, exn) =
	      raise IO.Io{function=mlOp, name=name, cause=exn}

	fun isClosedOut (strm as OSTRM{closed=ref true, ...}, mlOp) =
	      outputExn (strm, mlOp, IO.ClosedStream)
	  | isClosedOut _ = ()

	fun flushBuffer (strm as OSTRM{buf, pos, writeArr, ...}, mlOp) = (
	      case !pos
	       of 0 => ()
		| n => ((
		    writeArr {buf=buf, i=0, sz=SOME n}; pos := 0)
		      handle ex => outputExn (strm, mlOp, ex))
	      (* end case *))

	fun output (strm as OSTRM os, v) = let
	      val _ = isClosedOut (strm, "output")
	      val {buf, pos, bufferMode, ...} = os
	      fun flush () = flushBuffer (strm, "output")
	      fun flushAll () = (#writeArr os {buf=buf, i=0, sz=NONE}
		    handle ex => outputExn (strm, "output", ex))
	      fun writeDirect () = (
		    case !pos
		     of 0 => ()
		      | n => (#writeArr os {buf=buf, i=0, sz=SOME n}; pos := 0)
		    (* end case *);
		    #writeVec os {buf=v, i=0, sz=NONE})
		      handle ex => outputExn (strm, "output", ex)
	      fun insert copyVec = let
		    val bufLen = A.length buf
		    val dataLen = V.length v
		    in
		      if (dataLen >= bufLen)
			then writeDirect()
			else let
			  val i = !pos
			  val avail = bufLen - i
			  in
			    if (avail < dataLen)
			      then (
				copyVec(v, 0, avail, buf, i);
				flushAll();
				copyVec(v, avail, dataLen-avail, buf, 0);
			  	pos := dataLen-avail)
			    else (
			      copyVec(v, 0, dataLen, buf, i);
			      pos := i + dataLen;
			      if (avail = dataLen) then flush() else ())
			  end
		    end
	      in
		case !bufferMode
		 of IO.NO_BUF => writeDirect ()
		  | _ => let
		      fun copyVec (src, srcI, srcLen, dst, dstI) = A.copyVec {
			      src = src, si = srcI, len = SOME srcLen,
			      dst = dst, di = dstI
			    }
		      in
			insert copyVec
		      end
		(* end case *)
	      end

	fun output1 (strm as OSTRM{buf, pos, bufferMode, writeArr, ...}, elem) = (
	      isClosedOut (strm, "output1");
	      case !bufferMode
	       of IO.NO_BUF => (
		    arrUpdate (buf, 0, elem);
		    writeArr {buf=buf, i=0, sz=SOME 1}
		      handle ex => outputExn (strm, "output1", ex))
		| _ => let val i = !pos val i' = i+1
		    in
		      arrUpdate (buf, i, elem); pos := i';
		      if (i' = A.length buf)
			then flushBuffer (strm, "output1")
			else ()
		    end
	      (* end case *))

	fun flushOut strm = (
	      flushBuffer (strm, "flushOut"))

	fun closeOut (strm as OSTRM{writer=PIO.WR{close, ...}, closed, cleanTag, ...}) =
	      if !closed
		then ()
		else (
		  flushBuffer (strm, "closeOut");
		  closed := true;
		  CleanIO.removeCleaner cleanTag;
		  close())

	fun mkOutstream (wr as PIO.WR{chunkSize, writeArr, writeVec, ...}, mode) =
	      let
	      fun iterate f (buf, i, sz) = let
		    fun lp (_, 0) = ()
		      | lp (i, n) = let val n' = f{buf=buf, i=i, sz=SOME n}
			  in lp (i+n', n-n') end
		    in
		      lp (i, sz)
		    end
	      val writeArr' = (case writeArr
		     of NONE => (fn _ => raise IO.BlockingNotSupported)
		      | (SOME f) => let
			  fun write {buf, i, sz} = let
				val len = (case sz
				       of NONE => A.length buf - i
					| (SOME n) => n
				      (* end case *))
				in
				  iterate f (buf, i, len)
				end
			  in
			    write
			  end
		    (* end case *))
	      val writeVec' = (case writeVec
		     of NONE => (fn _ => raise IO.BlockingNotSupported)
		      | (SOME f) => let
			  fun write {buf, i, sz} = let
				val len = (case sz
				       of NONE => V.length buf - i
					| (SOME n) => n
				      (* end case *))
				in
				  iterate f (buf, i, len)
				end
			  in
			    write
			  end
		    (* end case *))
	    (* install a dummy cleaner *)
	      val tag = CleanIO.addCleaner {
		      init = fn () => (),
		      flush = fn () => (),
		      close = fn () => ()
		    }
	      val strm = OSTRM{
		      buf = A.array(chunkSize, someElem),
		      pos = ref 0,
		      closed = ref false,
		      bufferMode = ref mode,
		      writer = wr,
		      writeArr = writeArr',
		      writeVec = writeVec',
		      cleanTag = tag
		    }
	      in
		CleanIO.rebindCleaner (tag, {
		    init = fn () => closeOut strm,
		    flush = fn () => flushOut strm,
		    close = fn () => closeOut strm
		  });
		strm
	      end

	fun getWriter (strm as OSTRM{writer, bufferMode, ...}) = (
	      flushBuffer (strm, "getWriter");
	      (writer, !bufferMode))

      (** Position operations on outstreams **)
	datatype out_pos = OUTP of {
	    pos : PIO.pos,
	    strm : outstream
	  }

	fun getPosOut (strm as OSTRM{writer, ...}) = (
	      flushBuffer (strm, "getPosOut");
	      case writer
	       of PIO.WR{getPos=SOME f, ...} => (
		    OUTP{pos = f(), strm = strm}
		      handle ex => outputExn(strm, "getPosOut", ex))
		| _ => outputExn(strm, "getPosOut", IO.RandomAccessNotSupported)
	      (* end case *))
	fun filePosOut (OUTP{pos, strm}) = (
	      isClosedOut (strm, "filePosOut"); pos)
	fun setPosOut (OUTP{pos, strm as OSTRM{writer, ...}}) = (
	      isClosedOut (strm, "setPosOut");
	      case writer
	       of PIO.WR{setPos=SOME f, ...} => (
		    (f pos)
		      handle ex => outputExn(strm, "setPosOut", ex))
		| _ => outputExn(strm, "getPosOut", IO.RandomAccessNotSupported)
	      (* end case *))

	fun setBufferMode (strm as OSTRM{bufferMode, ...}, IO.NO_BUF) = (
	      flushBuffer (strm, "setBufferMode");
	      bufferMode := IO.NO_BUF)
	  | setBufferMode (strm as OSTRM{bufferMode, ...}, mode) = (
	      isClosedOut (strm, "setBufferMode");
	      bufferMode := mode)
	fun getBufferMode (strm as OSTRM{bufferMode, ...}) = (
	      isClosedOut (strm, "getBufferMode");
	      !bufferMode)

      end (* StreamIO *)

    type vector = V.vector
    type elem = V.elem
    type instream = StreamIO.instream ref
    type outstream = StreamIO.outstream ref

  (** Input operations **)
    fun input strm = let val (v, strm') = StreamIO.input(!strm)
	  in
	    strm := strm'; v
	  end
    fun input1 strm = (case StreamIO.input1(!strm)
	   of NONE => NONE
	    | (SOME(elem, strm')) => (strm := strm'; SOME elem)
	  (* end case *))
    fun inputN (strm, n) = let val (v, strm') = StreamIO.inputN (!strm, n)
	  in
	    strm := strm'; v
	  end
    fun inputAll (strm : instream) = let
	  val (v, strm') = StreamIO.inputAll(!strm)
	  in
	    strm := strm'; v
	  end
    fun canInput (strm, n) = StreamIO.canInput (!strm, n)
    fun lookahead (strm : instream) = (case StreamIO.input1(!strm)
	   of NONE => NONE
	    | (SOME(elem, _)) => SOME elem
	  (* end case *))
    fun closeIn strm = let
	  val (s as StreamIO.ISTRM(buf as StreamIO.IBUF{data, ...}, _)) = !strm
	  in
	    StreamIO.closeIn s;
	    strm := StreamIO.findEOS buf
	  end
    fun endOfStream strm = StreamIO.endOfStream(! strm)
    fun getPosIn strm = StreamIO.getPosIn(!strm)
    fun setPosIn (strm, p) = (strm := StreamIO.setPosIn p)

  (** Output operations **)
    fun output (strm, v) = StreamIO.output(!strm, v)
    fun output1 (strm, c) = StreamIO.output1(!strm, c)
    fun flushOut strm = StreamIO.flushOut(!strm)
    fun closeOut strm = StreamIO.closeOut(!strm)
    fun getPosOut strm = StreamIO.getPosOut(!strm)
    fun setPosOut (strm, p as StreamIO.OUTP{strm=strm', ...}) = (
	  strm := strm'; StreamIO.setPosOut p)

    fun mkInstream (strm : StreamIO.instream) = ref strm
    fun getInstream (strm : instream) = !strm
    fun setInstream (strm : instream, strm') = strm := strm'

    fun mkOutstream (strm : StreamIO.outstream) = ref strm
    fun getOutstream (strm : outstream) = !strm
    fun setOutstream (strm : outstream, strm') = strm := strm'

  (** Open files **)
    fun openIn fname =
	  mkInstream(StreamIO.mkInstream(OSPrimIO.openRd fname, NONE))
	    handle ex => raise IO.Io{function="openIn", name=fname, cause=ex}
    fun openOut fname =
	  mkOutstream(StreamIO.mkOutstream(OSPrimIO.openWr fname, IO.BLOCK_BUF))
	    handle ex => raise IO.Io{function="openOut", name=fname, cause=ex}
    fun openAppend fname =
	  mkOutstream(StreamIO.mkOutstream(OSPrimIO.openApp fname, IO.NO_BUF))
	    handle ex => raise IO.Io{function="openAppend", name=fname, cause=ex}

  end (* BinIOFn *)

type statrep = (int * word * word * word * word * word * 
		word * int * int * int * int)
type flock_rep = int * int * Position.int * Position.int * int
type tm = (int * int * int * int * int * int * int * int * int)
type termio_rep = (word *       	(* iflags *)
		   word *       	(* oflags *)
		   word *       	(* cflags *)
		   word *       	(* lflags *)
		   Word8Vector.vector *	(* cc *)
		   word *		(* inspeed *)
		   word			(* outspeed *)
		   )

extern posix_ascTime :  (int * int * int * int * int * int * int * int * int, string) -->
extern posix_localTime :  (int, int * int * int * int * int * int * int * int * int) -->
extern posix_gmTime :  (int, int * int * int * int * int * int * int * int * int) -->
extern posix_mkTime : (int * int * int * int * int * int * int * int * int, int) -->
extern posix_strfTime : (string * (int * int * int * int * int * int * int * int * int), string) -->
extern posix_error_msg : (int, string) -->
extern posix_error_name : (int, string) -->
extern posix_error_num: (string, int) -->
extern posix_os_tmpname : (unit, string) -->
extern posix_os_poll : ((int * word) list, (int * int) option, (int * word) list) -->
extern posix_io_num : (string, int) -->
extern posix_io_pipe : (unit, (int * int)) -->
extern posix_io_dup : (int, int) -->
extern posix_io_dup2 : (int, int, unit) -->
extern posix_io_close : (int, unit) -->
extern posix_io_read : (int, int, Word8Vector.vector ) -->
extern posix_io_readbuf : (int, Word8Array.array, int, int, int) -->
extern posix_io_writebuf : (int, Word8Array.array, int, int, int) -->
extern posix_io_fcntl_d : (int, int, int) -->
extern posix_io_fcntl_gfd: (int, word) -->
extern posix_io_fcntl_sfd : (int, word, unit) -->
extern posix_io_fcntl_gfl : (int, word * word) -->
extern posix_io_fcntl_sfl : (int, word, unit) -->
(* due to a deficiency in the phase-splitter, externs cannot use types
   defined within the same unit *)
extern posix_io_fcntl_l : (int, int, 
			   int * int * Position.int * Position.int * int (* = flock_rep *), 
			   int * int * Position.int * Position.int * int (* = flock_rep *) ) -->
extern posix_io_lseek : (int, int, int, int) -->
extern posix_io_fsync : (int, unit) -->
extern posix_procenv_getpid : (unit, int) -->
extern posix_procenv_getppid : (unit, int) -->
extern posix_procenv_getuid : (unit, word) -->
extern posix_procenv_geteuid : (unit, word) -->
extern posix_procenv_getgid : (unit, word) -->
extern posix_procenv_getegid : (unit, word) -->
extern posix_procenv_setuid : (word, unit) -->
extern posix_procenv_setgid : (word, unit) -->
extern posix_procenv_getgroups : (unit, word list) -->
extern posix_procenv_getlogin : (unit, string) -->
extern posix_procenv_getpgrp : (unit, int) -->
extern posix_procenv_setsid : (unit, int) -->
extern posix_procenv_setpgid : (int, int, unit) -->
extern posix_procenv_uname : (unit, (string * string) list) -->

extern posix_tty_num : (string, int) -->
extern posix_tty_tcgetattr : (int, (word * word * word * word * Word8Vector.vector * word * word)
			           (* = termio_rep *) ) -->
extern posix_tty_tcsetattr : (int, int, (word * word * word * word * Word8Vector.vector * word * word)
			                (* = termio_rep *) , unit) -->
extern posix_tty_tcsendbreak : (int, int, unit) -->
extern posix_tty_tcdrain : (int, unit) -->
extern posix_tty_tcflush : (int, int, unit) -->
extern posix_tty_tcflow : (int, int, unit) -->
extern posix_tty_tcgetpgrp : (int, int) -->
extern posix_tty_tcsetpgrp : (int, int, unit) -->

extern posix_sysdb_getgrgid : (word, string * word * string list) -->
extern posix_sysdb_getgrnam : (string, string * word * string list) -->
extern posix_sysdb_getpwuid : (word, string * word * word * string * string) -->
extern posix_sysdb_getpwnam : (string, string * word * word * string * string) -->


extern posix_procenv_time : (unit, int) -->
extern posix_procenv_times : (unit, int * int * int * int * int) -->
extern posix_procenv_getenv : (string, string option) -->
extern posix_procenv_environ : (unit, string list) -->
extern posix_procenv_ctermid : (unit, string) -->
extern posix_procenv_ttyname : (int, string) -->
extern posix_procenv_isatty : (int, bool) -->


extern posix_process_num : (string, int) -->
extern posix_process_sysconf : (string, word) -->
extern posix_process_fork : (unit, int) -->
extern posix_process_exec : (string, string list, unit) -->
extern posix_process_exece : (string, string list, string list, unit) -->
extern posix_process_execp : (string, string list, unit) -->
extern posix_process_waitpid : (int, word, (int * int * int)) -->
extern posix_process_exit : (Word8.word, unit) -->
extern posix_process_kill : (int, int, unit) -->
extern posix_process_alarm : (int, int) -->
extern posix_process_pause : (unit, unit) -->
extern posix_process_sleep : (int, int) -->
extern posix_signal_num : (string, int) -->
extern posix_filesys_num : (string, word) -->
extern posix_filesys_opendir : (string, int) -->
extern posix_filesys_readdir : (int, string) -->
extern posix_filesys_rewinddir : (int, unit) -->
extern posix_filesys_closedir : (int, unit) -->
extern posix_filesys_chdir : (string, unit) -->
extern posix_filesys_getcwd : (unit, string) -->
extern posix_filesys_openf : (string, word, word, int) -->
extern posix_filesys_umask : (word, word) -->
extern posix_filesys_link : (string, string, unit) -->
extern posix_filesys_rename : (string, string, unit) -->
extern posix_filesys_symlink : (string, string, unit) -->
extern posix_filesys_mkdir : (string, word, unit) -->
extern posix_filesys_mkfifo : (string, word, unit) -->
extern posix_filesys_unlink : (string, unit) -->
extern posix_filesys_rmdir : (string, unit) -->
extern posix_filesys_readlink : (string, string) -->
extern posix_filesys_ftruncate : (int, int, unit) -->
extern posix_filesys_stat : (string, (int * word * word * word * word * word * 
				      word * int * int * int * int) (* = statrep *) ) -->
extern posix_filesys_lstat : (string, (int * word * word * word * word * word * 
				       word * int * int * int * int) (* = statrep *) ) -->
extern posix_filesys_fstat : (int, (int * word * word * word * word * word * 
				    word * int * int * int * int) (* = statrep *) ) -->
extern posix_filesys_access : (string, word, bool) -->
extern posix_filesys_chmod : (string, word, unit) -->
extern posix_filesys_fchmod : (int, word, unit) -->
extern posix_filesys_chown : (string, word, word, unit) -->
extern posix_filesys_fchown : (int, word, word, unit) -->
extern posix_filesys_utime : (string, int, int, unit) -->
extern posix_filesys_pathconf : (string, string, (int * int)) -->
extern posix_filesys_fpathconf :  (int, string, (int * int)) -->

signature PRE_POSIX =
sig

    eqtype uid
    val uidToWord : uid -> SysWord.word
    val wordToUid : SysWord.word -> uid
	
    eqtype gid
    val gidToWord : gid -> SysWord.word
    val wordToGid : SysWord.word -> gid

    datatype open_mode = O_RDONLY | O_WRONLY | O_RDWR
    val omodeFromWord : SysWord.word -> open_mode
    val omodeToWord : open_mode -> SysWord.word

    val sysconf : string -> SysWord.word

end
	
structure PrePosix :> PRE_POSIX =
struct

    datatype uid = UID of word
    datatype gid = GID of word
    datatype open_mode = O_RDONLY | O_WRONLY | O_RDWR

    fun uidToWord (UID i) = i
    fun wordToUid i = UID i

    fun gidToWord (GID i) = i
    fun wordToGid i = GID i

    fun w_osval (str : string) : word = Ccall(posix_filesys_num,str)

    val o_rdonly = w_osval "O_RDONLY"
    val o_wronly = w_osval "O_WRONLY"
    val o_rdwr = w_osval "O_RDWR"

    fun omodeFromWord omode =
          if omode = o_rdonly then O_RDONLY
          else if omode = o_wronly then O_WRONLY
          else if omode = o_rdwr then O_RDWR
          else raise TiltExn.LibFail (String.^ ("PrePosix.omodeFromWord: unknown mode ",
						(SysWord.toString omode)))

    fun omodeToWord O_RDONLY = o_rdonly
      | omodeToWord O_WRONLY = o_wronly
      | omodeToWord O_RDWR = o_rdwr

    fun sysconf (s : string) : SysWord.word = Ccall(posix_process_sysconf,s)

end    
d14 1
a14 1
    val unsafe_vector2array = TiltPrim.unsafe_vector2array
d16 2
a17 2
    fun writearr' (x : int, v : Word8Array.array, y : int, z : int) : int = Ccall(posix_io_writebuf,x,v,y,z)
    fun writevec' (x : int, v : Word8Vector.vector, y : int, z : int) : int = writearr'(x,unsafe_vector2array v,y,z)
d19 1
a19 1
          val vlen = Word8Vector.length buf
d26 1
a26 1
          val vlen = Word8Vector.length buf
@


1.17
log
@*** empty log message ***
@
text
@a7516 7
(* posix-error-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX error codes.
 *
 *)
d7518 1
a7518 65
signature POSIX_ERROR =
  sig

    eqtype syserror

    val toWord    : syserror -> word
    val fromWord  : word -> syserror
    val errorMsg  : syserror -> string
    val errorName : syserror -> string
    val syserror  : string -> syserror option

    val toobig      : syserror
    val acces       : syserror
    val again       : syserror
    val badf        : syserror
    val badmsg      : syserror
    val busy        : syserror
    val canceled    : syserror
    val child       : syserror
    val deadlk      : syserror
    val dom         : syserror
    val exist       : syserror
    val fault       : syserror
    val fbig        : syserror
    val inprogress  : syserror
    val intr        : syserror
    val inval       : syserror
    val io          : syserror
    val isdir       : syserror
    val loop        : syserror
    val mfile       : syserror
    val mlink       : syserror
    val msgsize     : syserror
    val nametoolong : syserror
    val nfile       : syserror
    val nodev       : syserror
    val noent       : syserror
    val noexec      : syserror
    val nolck       : syserror
    val nomem       : syserror
    val nospc       : syserror
    val nosys       : syserror
    val notdir      : syserror
    val notempty    : syserror
    val notsup      : syserror
    val notty       : syserror
    val nxio        : syserror
    val perm        : syserror
    val pipe        : syserror
    val range       : syserror
    val rofs        : syserror
    val spipe       : syserror
    val srch        : syserror
    val xdev        : syserror

  end (* signature POSIX_ERROR *)
(* posix-error.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Structure for POSIX error codes.
 *
 *)

structure POSIX_Error :> POSIX_ERROR  where type syserror = int =
d7520 3
a7522 86
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
    type syserror = int

    fun toWord se = int32touint32 se
    fun fromWord w = uint32toint32 w
    fun errorMsg i    = Ccall(posix_error_msg, i)
    fun errorName err = Ccall(posix_error_name, err)
    val posix_error_num = fn (str : string) => Ccall(posix_error_num, str)
    fun syserror str = let val s : int = posix_error_num str
		       in if s > 536870912
			      then SOME s
			  else NONE
		       end

    val toobig      = posix_error_num "toobig"
    val acces       = posix_error_num "acces"
    val again       = posix_error_num "again"
    val badf        = posix_error_num "badf"
    val badmsg      = posix_error_num "badmsg"
    val busy        = posix_error_num "busy"
    val canceled    = posix_error_num "canceled"
    val child       = posix_error_num "child"
    val deadlk      = posix_error_num "deadlk"
    val dom         = posix_error_num "dom"
    val exist       = posix_error_num "exist"
    val fault       = posix_error_num "fault"
    val fbig        = posix_error_num "fbig"
    val inprogress  = posix_error_num "inprogress"
    val intr        = posix_error_num "intr"
    val inval       = posix_error_num "inval"
    val io          = posix_error_num "io"
    val isdir       = posix_error_num "isdir"
    val loop        = posix_error_num "loop"
    val mfile       = posix_error_num "mfile"
    val mlink       = posix_error_num "mlink"
    val msgsize     = posix_error_num "msgsize"
    val nametoolong = posix_error_num "nametoolong"
    val nfile       = posix_error_num "nfile"
    val nodev       = posix_error_num "nodev"
    val noent       = posix_error_num "noent"
    val noexec      = posix_error_num "noexec"
    val nolck       = posix_error_num "nolck"
    val nomem       = posix_error_num "nomem"
    val nospc       = posix_error_num "nospc"
    val nosys       = posix_error_num "nosys"
    val notdir      = posix_error_num "notdir"
    val notempty    = posix_error_num "notempty"
    val notsup      = posix_error_num "notsup"
    val notty       = posix_error_num "notty"
    val nxio        = posix_error_num "nxio"
    val perm        = posix_error_num "perm"
    val pipe        = posix_error_num "pipe"
    val range       = posix_error_num "range"
    val rofs        = posix_error_num "rofs"
    val spipe       = posix_error_num "spipe"
    val srch        = posix_error_num "srch"
    val xdev        = posix_error_num "xdev"

  end (* structure POSIX_Error *)
(* posix-flags.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for bit flags.
 *
 *)

signature POSIX_FLAGS =
  sig
    eqtype flags

    val toWord  : flags -> SysWord.word
    val wordTo : SysWord.word -> flags

      (* Create a flags value corresponding to the union of all flags
       * set in the list.
       *)
    val flags  : flags list -> flags

      (* allSet(s,t) returns true if all flags in s are also in t. *)
    val allSet : flags * flags -> bool

      (* anySet(s,t) returns true if any flag in s is also in t. *)
    val anySet : flags * flags -> bool
a7524 490

(* posix-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 primitive I/O operations
 *
 *)

signature POSIX_IO =
  sig

    eqtype file_desc
    eqtype pid
    
    val pipe : unit -> {infd : file_desc, outfd : file_desc}
    val dup : file_desc -> file_desc
    val dup2 : {old : file_desc, new : file_desc} -> unit
    val close : file_desc -> unit
    val readVec : file_desc * int -> Word8Vector.vector
    val readArr : file_desc * {buf : Word8Array.array, i : int, sz : int option} -> int
    val writeVec : file_desc * {buf : Word8Vector.vector, i : int, sz : int option} -> int
    val writeArr : file_desc * {buf : Word8Array.array, i : int, sz : int option} -> int
    
    datatype whence = SEEK_SET | SEEK_CUR | SEEK_END
    
    structure FD :
      sig
        include POSIX_FLAGS

        val cloexec : flags
      end

    structure O :
      sig
        include POSIX_FLAGS

        val append   : flags
(*
        val dsync    : flags
        val rsync    : flags
*)
        val nonblock : flags
        val sync     : flags

      end

    datatype open_mode = O_RDONLY | O_WRONLY | O_RDWR
    
    val dupfd : {old : file_desc, base : file_desc} -> file_desc
    val getfd : file_desc -> FD.flags
    val setfd : file_desc * FD.flags -> unit
    val getfl : file_desc -> O.flags * open_mode
    val setfl : file_desc * O.flags -> unit
    
    val lseek : file_desc * Position.int * whence -> Position.int

    val fsync : file_desc -> unit

    datatype lock_type = F_RDLCK | F_WRLCK | F_UNLCK

    structure FLock :
      sig
        type flock

        val flock : { l_type : lock_type,
                      l_whence : whence,
                      l_start : Position.int,
                      l_len : Position.int,
                      l_pid : pid option} -> flock

        val ltype    : flock -> lock_type
        val whence   : flock -> whence
        val start    : flock -> Position.int
        val len      : flock -> Position.int
        val pid      : flock -> pid option
      end

    val getlk  : file_desc * FLock.flock -> FLock.flock
    val setlk  : file_desc * FLock.flock -> FLock.flock
    val setlkw : file_desc * FLock.flock -> FLock.flock
    
  end (* signature POSIX_IO *)

(* posix-filesys-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 file system operations
 *
 *)

signature POSIX_FILE_SYS =
  sig

    eqtype uid
    eqtype gid
    eqtype file_desc

    val fdToWord    : file_desc -> SysWord.word
    val wordToFD    : SysWord.word -> file_desc

    val fdToIOD    : file_desc -> PreOS.IO.iodesc
    val iodToFD    : PreOS.IO.iodesc -> file_desc option

    type dirstream

    val opendir   : string -> dirstream
    val readdir   : dirstream -> string
    val rewinddir : dirstream -> unit
    val closedir  : dirstream -> unit

    val chdir  : string -> unit
    val getcwd : unit -> string

    val stdin  : file_desc
    val stdout : file_desc
    val stderr : file_desc

    structure S :
      sig
        include POSIX_FLAGS

        type mode
          sharing type mode = flags
 
        val irwxu : mode
        val irusr : mode
        val iwusr : mode
        val ixusr : mode
        val irwxg : mode
        val irgrp : mode
        val iwgrp : mode
        val ixgrp : mode
        val irwxo : mode
        val iroth : mode
        val iwoth : mode
        val ixoth : mode
        val isuid : mode
        val isgid : mode

      end

    structure O :
      sig
        include POSIX_FLAGS

        val append   : flags
        val dsync    : flags
        val excl     : flags
        val noctty   : flags
        val nonblock : flags
        val rsync    : flags
        val sync     : flags
        val trunc    : flags

      end

    datatype open_mode = O_RDONLY | O_WRONLY | O_RDWR

    val openf     : string * open_mode * O.flags -> file_desc
    val createf   : string * open_mode * O.flags * S.mode -> file_desc
    val creat     : string * S.mode -> file_desc
    val umask     : S.mode -> S.mode
    val link      : {old : string, new : string} -> unit
    val mkdir     : string * S.mode -> unit
    val mkfifo    : string * S.mode -> unit
    val unlink    : string -> unit
    val rmdir     : string -> unit
    val rename    : {old : string, new : string} -> unit
    val symlink   : {old : string, new : string} -> unit  (* POSIX 1003.1a *)
    val readlink  : string -> string                      (* POSIX 1003.1a *)
	
    eqtype dev
    val wordToDev : SysWord.word -> dev
    val devToWord : dev -> SysWord.word

    eqtype ino
    val wordToIno : SysWord.word -> ino
    val inoToWord : ino -> SysWord.word

    structure ST :
      sig
        type stat

	val isDir  : stat -> bool
	val isChr  : stat -> bool
	val isBlk  : stat -> bool
	val isReg  : stat -> bool
	val isFIFO : stat -> bool
	val isLink : stat -> bool
	val isSock : stat -> bool
        val mode   : stat -> S.mode
        val ino    : stat -> ino
        val dev    : stat -> dev
        val nlink  : stat -> int
        val uid    : stat -> uid
        val gid    : stat -> gid
        val size   : stat -> Position.int
        val atime  : stat -> Time.time
        val mtime  : stat -> Time.time
        val ctime  : stat -> Time.time
      end

    val stat : string -> ST.stat
    val lstat : string -> ST.stat     (* POSIX 1003.1a *)
    val fstat : file_desc -> ST.stat

    datatype access_mode = A_READ | A_WRITE | A_EXEC
    val access : string * access_mode list -> bool

    val chmod   : string * S.mode -> unit
    val fchmod  : file_desc * S.mode -> unit

    val chown    : string * uid * gid -> unit
    val fchown   : file_desc * uid * gid -> unit

    val utime : string * {actime : Time.time, modtime : Time.time} option -> unit
    
    val ftruncate : file_desc * Position.int -> unit      (* POSIX 1003.1a *)

    val pathconf  : string * string -> SysWord.word option
    val fpathconf : file_desc * string -> SysWord.word option

  end (* signature POSIX_FILE_SYS *)

(* posix-filesys.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Structure for POSIX 1003.1 file system operations
 *
 *)

structure POSIX_FileSys :> POSIX_FILE_SYS where type uid = PrePosix.uid
					    and type gid = PrePosix.gid
					    and type open_mode = PrePosix.open_mode =
  struct
    val int32touint32 = TiltPrim.int32touint32
    val op^ = String.^
	
    val ++ = Word.orb
    val & = Word.andb
    infix ++ &

    type uid = PrePosix.uid
    type gid = PrePosix.gid
	
    datatype file_desc = FD of {fd : int}
    fun intOf (FD{fd,...}) = fd
    fun fd fd = FD{fd=fd}
    fun fdToWord (FD{fd,...}) = Word.fromInt fd
    fun wordToFD fd = FD{fd = Word.toInt fd}

  (* conversions between OS.IO.iodesc values and Posix file descriptors. *)
    fun fdToIOD (FD{fd,...}) = PreOS.IO.IODesc fd
    fun iodToFD (PreOS.IO.IODesc fd) = SOME(FD{fd = fd})

    datatype open_mode = datatype PrePosix.open_mode
	
    type c_dirstream = int   (* the underlying C DIRSTREAM - which is a DIR pointer *)

    datatype dirstream = DS of {
	dirStrm : c_dirstream,
	isOpen : bool ref
      }

    val opendir' (* : string -> c_dirstream  *) = fn arg => Ccall(posix_filesys_opendir,arg)
    val readdir' (* : c_dirstream -> string  *) = fn arg => Ccall(posix_filesys_readdir,arg)
    val rewinddir' (* : c_dirstream -> unit  *) = fn arg => Ccall(posix_filesys_rewinddir,arg)
    val closedir' (* : c_dirstream -> unit   *) = fn arg => Ccall(posix_filesys_closedir,arg)
    fun opendir path = DS{
	    dirStrm = opendir' path,
	    isOpen = ref true
	  }
    fun readdir (DS{dirStrm, isOpen = ref false}) =
	  raise TiltExn.LibFail "readdir on closed directory stream"
	  (* PreOS.error "readdir on closed directory stream" ??? *)
      | readdir (DS{dirStrm, ...}) = readdir' dirStrm
    fun rewinddir (DS{dirStrm, isOpen = ref false}) =
	  raise TiltExn.LibFail "rewinddir on closed directory stream"
	  (* PreOS.error "rewinddir on closed directory stream" ??? *)
      | rewinddir (DS{dirStrm, ...}) = rewinddir' dirStrm
    fun closedir (DS{dirStrm, isOpen = ref false}) = ()
      | closedir (DS{dirStrm, isOpen}) = (
	  isOpen := false;
	  closedir' dirStrm)

    fun chdir  (s : string) : unit = Ccall(posix_filesys_chdir, s)
    fun getcwd () : string = Ccall(posix_filesys_getcwd,())

    val stdin  = fd 0
    val stdout = fd 1
    val stderr = fd 2

    fun w_osval (str : string) : word = Ccall(posix_filesys_num,str)
    val o_wronly = w_osval "O_WRONLY"
	 
    structure S =
      struct
        datatype flags = MODE of word
        type mode = flags

        fun wordTo w = MODE w
        fun toWord (MODE w) = w

        fun flags ms = MODE(List.foldl (fn (MODE m,acc) => m ++ acc) 0w0 ms)
        fun anySet (MODE m, MODE m') = (m & m') <> 0w0
        fun allSet (MODE m, MODE m') = (m & m') = m

        val irwxu = MODE(w_osval "irwxu")
        val irusr = MODE(w_osval "irusr")
        val iwusr = MODE(w_osval "iwusr")
        val ixusr = MODE(w_osval "ixusr")
        val irwxg = MODE(w_osval "irwxg")
        val irgrp = MODE(w_osval "irgrp")
        val iwgrp = MODE(w_osval "iwgrp")
        val ixgrp = MODE(w_osval "ixgrp")
        val irwxo = MODE(w_osval "irwxo")
        val iroth = MODE(w_osval "iroth")
        val iwoth = MODE(w_osval "iwoth")
        val ixoth = MODE(w_osval "ixoth")
        val isuid = MODE(w_osval "isuid")
        val isgid = MODE(w_osval "isgid")

      end

    structure O =
      struct
        datatype flags = OFL of word

        fun wordTo w = OFL w
        fun toWord (OFL w) = w

        fun flags ms = OFL(List.foldl (fn (OFL m,acc) => m ++ acc) 0w0 ms)
        fun anySet (OFL m, OFL m') = (m & m') <> 0w0
        fun allSet (OFL m, OFL m') = (m & m') = m

        val append   = OFL(w_osval "O_APPEND")
        val dsync    = OFL(w_osval "O_DSYNC")
        val excl     = OFL(w_osval "O_EXCL")
        val noctty   = OFL(w_osval "O_NOCTTY")
        val nonblock = OFL(w_osval "O_NONBLOCK")
        val rsync    = OFL(w_osval "O_RSYNC")
        val sync     = OFL(w_osval "O_SYNC")
        val o_trunc  = w_osval "O_TRUNC"
        val trunc    = OFL o_trunc
        val o_creat  = w_osval "O_CREAT"
        val crflags  = o_wronly ++ o_creat ++ o_trunc

      end


    fun openf (fname : string, omode, O.OFL flags) =
          fd(Ccall (posix_filesys_openf,fname, flags ++ (PrePosix.omodeToWord omode), 0w0))
    fun createf (fname:string, omode, O.OFL oflags, S.MODE mode) = let
          val flags = O.o_creat ++ oflags ++ (PrePosix.omodeToWord omode)
          in
            fd(Ccall(posix_filesys_openf,fname, flags, mode))
          end
    fun creat (fname:string, S.MODE mode) =
          fd(Ccall(posix_filesys_openf,fname, O.crflags, mode))

    fun umask (S.MODE mode) = S.MODE(Ccall(posix_filesys_umask, mode))

    fun link {old : string, new : string} = Ccall(posix_filesys_link,old,new)
    fun rename {old : string, new : string} = Ccall(posix_filesys_rename,old,new)
    fun symlink {old : string, new : string} = Ccall(posix_filesys_symlink,old,new)
    fun mkdir (dirname : string, S.MODE mode) = Ccall(posix_filesys_mkdir,dirname,mode)						 
    fun mkfifo (name : string, S.MODE mode) = Ccall(posix_filesys_mkfifo,name,mode)

    fun unlink name = Ccall(posix_filesys_unlink,name)
    fun rmdir name = Ccall(posix_filesys_rmdir,name)
    fun readlink name = Ccall(posix_filesys_readlink,name)
    fun ftruncate (FD{fd,...}, len) = Ccall(posix_filesys_ftruncate,fd, len)

    datatype dev = DEV of word
    fun devToWord (DEV i) = i
    fun wordToDev i = DEV i

    datatype ino = INO of word
    fun inoToWord (INO i) = i
    fun wordToIno i = INO i

    structure ST =
      struct
        datatype stat = ST of {
                 ftype : int,
                 mode  : S.mode,
                 ino   : ino,
                 dev   : dev,
                 nlink : int,
                 uid   : uid,
                 gid   : gid,
                 size  : Position.int,
                 atime : Time.time,
                 mtime : Time.time,
                 ctime : Time.time
               }
      (* The following assumes the C stat functions pull the
       * file type from the mode field and return the
       * integer below corresponding to the file type.
       *) 
	fun isDir  (ST{ftype, ...}) = (ftype = 0x4000)
	fun isChr  (ST{ftype, ...}) = (ftype = 0x2000)
	fun isBlk  (ST{ftype, ...}) = (ftype = 0x6000)
	fun isReg  (ST{ftype, ...}) = (ftype = 0x8000)
	fun isFIFO (ST{ftype, ...}) = (ftype = 0x1000)
	fun isLink (ST{ftype, ...}) = (ftype = 0xA000)
	fun isSock (ST{ftype, ...}) = (ftype = 0xC000)

        fun mode (ST{mode,...}) = mode
        fun ino (ST{ino,...}) = ino
        fun dev (ST{dev,...}) = dev
        fun nlink (ST{nlink,...}) = nlink
        fun uid (ST{uid,...}) = uid
        fun gid (ST{gid,...}) = gid
        fun size (ST{size,...}) = size
        fun atime (ST{atime,...}) = atime
        fun mtime (ST{mtime,...}) = mtime
        fun ctime (ST{ctime,...}) = ctime
      end (* structure ST *) 

  (* this layout needs to track c-libs/posix-filesys/stat.c *)
    type statrep = (int * word * word * word * word * word * 
                    word * Position.int * int * int * int)
    fun mkStat (sr : statrep) = ST.ST{
	    ftype = #1 sr,
            mode = S.MODE (#2 sr),
            ino = INO (#3 sr),
            dev = DEV (#4 sr),
            nlink = SysWord.toInt(#5 sr),	(* probably should be an int in
						 * the run-time too.
						 *)
            uid = PrePosix.wordToUid(#6 sr),
            gid = PrePosix.wordToGid(#7 sr),
            size = #8 sr,
            atime = Time.fromSeconds (#9 sr),
            mtime = Time.fromSeconds (#10 sr),
            ctime = Time.fromSeconds (#11 sr)
          }


    fun stat fname = mkStat (Ccall(posix_filesys_stat,fname))
    fun lstat fname = mkStat (Ccall(posix_filesys_lstat,fname)) (* POSIX 1003.1a *)
    fun fstat (FD{fd}) = mkStat (Ccall(posix_filesys_fstat,fd))

    datatype access_mode = A_READ | A_WRITE | A_EXEC
    val a_read = w_osval "A_READ"	(* R_OK *)
    val a_write = w_osval "A_WRITE"	(* W_OK *)
    val a_exec = w_osval "A_EXEC"	(* X_OK *)
    val a_file = w_osval "A_FILE"	(* F_OK *)
    fun amodeToWord [] = a_file
      | amodeToWord l = let
          fun amtoi (A_READ,v) = a_read ++ v
            | amtoi (A_WRITE,v) = a_write ++ v
            | amtoi (A_EXEC,v) = a_exec ++ v
          in
            List.foldl amtoi a_file l
          end

    fun access (fname, aml) = Ccall(posix_filesys_access,fname, amodeToWord aml)
    fun chmod (fname, S.MODE m) = Ccall(posix_filesys_chmod,fname, m)
    fun fchmod (FD{fd}, S.MODE m) = Ccall(posix_filesys_fchmod,fd, m)
    fun chown (fname, uid, gid) = Ccall(posix_filesys_chown,fname, PrePosix.uidToWord uid, PrePosix.gidToWord gid)
    fun fchown (fd, uid, gid) = Ccall(posix_filesys_fchown,intOf fd, PrePosix.uidToWord uid, PrePosix.gidToWord gid)

    fun utime (file, NONE) = Ccall(posix_filesys_utime,file, ~1, 0)
      | utime (file, SOME{actime, modtime}) = let
          val atime = Time.toSeconds actime
          val mtime = Time.toSeconds modtime
          in
            Ccall(posix_filesys_utime,file,atime,mtime)
          end
    
(* xxxx can't get option in basis 
    val pathconf  : (string * string) -> word option = cfun "pathconf"
    val fpathconf'  : (int * string) -> word option = cfun "fpathconf"
*)
    fun pathconf  (str1, str2) : word option = 
	(case Ccall(posix_filesys_pathconf,str1,str2) of
	    (0,i) => SOME (int32touint32 i)
	  | _ => NONE)
    fun fpathconf  (FD{fd}, s : string) : word option = 
	(case Ccall(posix_filesys_fpathconf,fd,s) of
	    (0,i) => SOME (int32touint32 i)
	  | _ => NONE)

  end (* structure POSIX_FileSys *)

d7553 2
a7554 2
	  val pos = ref(Position.fromInt 0)
 	  fun incPos k = (pos := Position.+(!pos, Position.fromInt k); k)
@


1.16
log
@*** empty log message ***
@
text
@a8167 7
(* posix-process-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 process submodule
 *
 *)
d8169 2
a8170 268
signature POSIX_PROCESS =
  sig
    eqtype signal
    eqtype pid

    val wordToPid     : SysWord.word -> pid
    val pidToWord     : pid -> SysWord.word

    val fork : unit -> pid option
    
    val exec  : string * string list -> 'a
    val exece : string * string list * string list -> 'a
    val execp : string * string list -> 'a
    
    datatype waitpid_arg
      = W_ANY_CHILD
      | W_CHILD of pid
      | W_SAME_GROUP
      | W_GROUP of pid
    
    datatype exit_status
      = W_EXITED
      | W_EXITSTATUS of Word8.word
      | W_SIGNALED of signal
      | W_STOPPED of signal
    
    structure W :
      sig
        include POSIX_FLAGS

        val untraced : flags
      end

    val wait : unit -> pid * exit_status
    val waitpid : waitpid_arg * W.flags list -> pid * exit_status
    val waitpid_nh : waitpid_arg * W.flags list -> (pid * exit_status) option
    
    val exit : Word8.word -> 'a
    
    datatype killpid_arg
      = K_PROC of pid
      | K_SAME_GROUP
      | K_GROUP of pid

    val kill : killpid_arg * signal -> unit
    
    val alarm : Time.time -> Time.time
    val pause : unit -> unit
    val sleep : Time.time -> Time.time

  end (* signature POSIX_PROCESS *)

(* posix-signal-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 signals.
 *
 *)

signature POSIX_SIGNAL =
  sig
    eqtype signal

    val toWord   : signal -> SysWord.word
    val fromWord : SysWord.word -> signal

    val abrt : signal
    val alrm : signal
    val bus  : signal
    val fpe  : signal
    val hup  : signal
    val ill  : signal
    val int  : signal
    val kill : signal
    val pipe : signal
    val quit : signal
    val segv : signal
    val term : signal
    val usr1 : signal
    val usr2 : signal
    val chld : signal
    val cont : signal
    val stop : signal
    val tstp : signal
    val ttin : signal
    val ttou : signal

  end (* signature POSIX_SIGNAL *)

(* posix-signal.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Structure for POSIX 1003.1 signals.
 *
 *)

structure POSIX_Signal :> POSIX_SIGNAL =
  struct

    datatype signal = SIG of SysInt.int

    fun toWord (SIG i) = SysWord.fromInt i
    fun fromWord w = SIG (SysWord.toInt w)

    fun osval str = Ccall(posix_signal_num,str)

    val abrt = SIG(osval "abrt")
    val alrm = SIG(osval "alrm")
    val fpe  = SIG(osval "fpe")
    val hup  = SIG(osval "hup")
    val ill  = SIG(osval "ill")
    val int  = SIG(osval "int")
    val kill = SIG(osval "kill")
    val pipe = SIG(osval "pipe")
    val quit = SIG(osval "quit")
    val segv = SIG(osval "segv")
    val term = SIG(osval "term")
    val usr1 = SIG(osval "usr1")
    val usr2 = SIG(osval "usr2")
    val chld = SIG(osval "chld")
    val cont = SIG(osval "cont")
    val stop = SIG(osval "stop")
    val tstp = SIG(osval "tstp")
    val ttin = SIG(osval "ttin")
    val ttou = SIG(osval "ttou")
    val bus  = SIG(osval "bus")

  end (* structure POSIX_Signal *)

(* posix-process.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Structure for POSIX 1003.1 process submodule
 *
 *)

structure POSIX_Process :> POSIX_PROCESS where type signal = POSIX_Signal.signal =
  struct

    structure Sig = POSIX_Signal

    val ++ = SysWord.orb
    val & = SysWord.andb
    infix ++ &

    type word = SysWord.word
    type s_int = SysInt.int

    type signal = Sig.signal
    datatype pid = PID of s_int
    fun pidToWord (PID i) = SysWord.fromInt i
    fun wordToPid w = PID (SysWord.toInt w)
    
    fun osval (s : string) : s_int = Ccall(posix_process_num,s)
    val w_osval = SysWord.fromInt o osval

    fun fork () =
          case Ccall(posix_process_fork,()) of
            0 => NONE
          | child_pid => SOME(PID child_pid)
    
    fun exec (x: string, y : string list) : 'a = (Ccall(posix_process_exec, x, y);
						  raise TiltExn.LibFail "exec cannot return")
    fun exece (x: string, y : string list, z : string list) : 'a = (Ccall(posix_process_exece, x, y, z);
								    raise TiltExn.LibFail "exece cannot return")
    fun execp (x: string, y : string list) : 'a = (Ccall(posix_process_execp, x, y);
						  raise TiltExn.LibFail "execp cannot return")

    datatype waitpid_arg
      = W_ANY_CHILD 
      | W_CHILD of pid 
      | W_SAME_GROUP
      | W_GROUP of pid
    
    datatype killpid_arg
      = K_PROC of pid
      | K_SAME_GROUP
      | K_GROUP of pid

    datatype exit_status
      = W_EXITED
      | W_EXITSTATUS of Word8.word
      | W_SIGNALED of signal
      | W_STOPPED of signal
    
      (* (pid',status,status_val) = waitpid' (pid,options)  *)
    fun waitpid' (pid : s_int, opts : word) : s_int * s_int * s_int = Ccall(posix_process_waitpid, pid, opts)

    fun argToInt W_ANY_CHILD = ~1
      | argToInt (W_CHILD (PID pid)) = pid
      | argToInt (W_SAME_GROUP) = 0
      | argToInt (W_GROUP (PID pid)) = ~pid

      (* The exit status from wait is encoded as a pair of integers.
       * If the first integer is 0, the child exited normally, and
       * the second integer gives its exit value.
       * If the first integer is 1, the child exited due to an uncaught
       * signal, and the second integer gives the signal value.
       * Otherwise, the child is stopped and the second integer 
       * gives the signal value that caused the child to stop.
       *)
    fun mkExitStatus (0,0) = W_EXITED
      | mkExitStatus (0,v) = W_EXITSTATUS(Word8.fromInt v)
      | mkExitStatus (1,s) = W_SIGNALED (Sig.fromWord(SysWord.fromInt s))
      | mkExitStatus (_,s) = W_STOPPED (Sig.fromWord(SysWord.fromInt s))


    val wnohang = w_osval "WNOHANG"
    structure W =
      struct
        datatype flags = WF of word

        fun wordTo w = WF w
        fun toWord (WF w) = w

        fun flags ms = WF(List.foldl (fn (WF m,acc) => m ++ acc) 0w0 ms)
        fun anySet (WF m, WF m') = (m & m') <> 0w0
        fun allSet (WF m, WF m') = (m & m') = m

        fun orF (WF f,acc) = f ++ acc

        val untraced =
          WF(PrePosix.sysconf "JOB_CONTROL"; w_osval "WUNTRACED") handle _ => WF 0w0
      end

    fun waitpid (arg,flags) = let
          val (pid,status,sv) = waitpid'(argToInt arg, List.foldl W.orF 0w0 flags)
          in
            (PID pid, mkExitStatus(status,sv))
          end

    fun waitpid_nh (arg,flags) =
          case waitpid'(argToInt arg, List.foldl W.orF wnohang flags) of
            (0,_,_) => NONE
          | (pid,status,sv) => SOME(PID pid, mkExitStatus(status,sv))

    fun wait () = waitpid(W_ANY_CHILD,[])
    
    fun exit (x: Word8.word) : 'a = (Ccall(posix_process_exit, x);
				     raise TiltExn.LibFail "execp cannot return")
    
    fun kill' (x : s_int, y : s_int) : unit = Ccall(posix_process_kill, x, y)
    fun kill (K_PROC (PID pid), s) = kill'(pid, SysWord.toInt(Sig.toWord s))
      | kill (K_SAME_GROUP, s) = kill'(~1, SysWord.toInt(Sig.toWord s))
      | kill (K_GROUP (PID pid), s) = kill'(~pid, SysWord.toInt(Sig.toWord s))
    
    fun alarm' (x : int) : int = Ccall(posix_process_alarm, x)
    val alarm = Time.fromSeconds o alarm' o Time.toSeconds

    fun pause () : unit = Ccall(posix_process_pause,())

    fun sleep' (x : int) : int = Ccall(posix_process_sleep, x)
    val sleep = Time.fromSeconds o sleep' o Time.toSeconds

  end (* structure POSIX_Process *)

structure POSIX_IO :> POSIX_IO where type open_mode = PrePosix.open_mode
				 and type file_desc = POSIX_FileSys.file_desc
				 and type O.flags = POSIX_FileSys.O.flags =

  struct
      
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
d8172 1
a8172 53
    val op^ = String.^

    structure FS = POSIX_FileSys

    datatype open_mode = datatype PrePosix.open_mode

    type word = SysWord.word
    type s_int = SysInt.int

    val ++ = SysWord.orb
    val & = SysWord.andb
    infix ++ &

    fun osval (s : string) : s_int = Ccall(posix_io_num,s)
    val w_osval = SysWord.fromInt o osval
    fun fail (fct,msg) = raise TiltExn.LibFail ("POSIX_IO."^fct^": "^msg)

    type file_desc = FS.file_desc
    type pid = POSIX_Process.pid
    
    fun fs_intof fd = uint32toint32(FS.fdToWord fd)
    fun fs_fd i = FS.wordToFD(int32touint32 i)

   fun pipe () = let
          val (ifd, ofd) = Ccall(posix_io_pipe,())
          in
            {infd = fs_fd ifd, outfd = fs_fd ofd}
          end

     fun dup fd = fs_fd(Ccall(posix_io_dup,fs_intof fd))
    fun dup2 {old, new} = Ccall(posix_io_dup2,fs_intof old, fs_intof new)

    fun close fd = Ccall(posix_io_close, fs_intof fd)

    fun read' (x: int, y : int) : Word8Vector.vector = Ccall(posix_io_read,x,y)
    fun readbuf' (x : int, b : Word8Array.array, y : int, z :  int) : int = Ccall(posix_io_readbuf,x,b,y,z)
    fun readArr (fd, {buf, i, sz=NONE}) = let
          val alen = Word8Array.length buf
          in
            if 0 <= i andalso i <= alen
              then readbuf'(fs_intof fd, buf, alen - i, i)
              else raise Subscript
          end
      | readArr (fd, {buf, i, sz=SOME sz}) = let
          val alen = Word8Array.length buf
          in
            if 0 <= i andalso 0 <= sz andalso i + sz <= alen
              then readbuf'(fs_intof fd, buf, sz, i)
              else raise Subscript
          end
    fun readVec (fd,cnt) = 
          if cnt < 0 then raise Subscript else read'(fs_intof fd, cnt)

d8174 1
a8174 17
    fun writevec' (x : int, v : Word8Vector.vector, y : int, z : int) : int = writearr'(x,unsafe_vector2array v,
											y,z)
    fun writeArr (fd,{buf, i, sz=NONE}) = let
          val alen = Word8Array.length buf
          in
            if 0 <= i andalso i <= alen
              then writearr'(fs_intof fd, buf, alen-i, i)
              else raise Subscript
          end
      | writeArr (fd,{buf, i, sz=SOME sz}) = let
          val alen = Word8Array.length buf
          in
            if 0 <= i andalso 0 <= sz andalso i + sz <= alen
              then writearr'(fs_intof fd, buf, sz, i)
              else raise Subscript
          end
    
a8188 108
    
    datatype whence = SEEK_SET | SEEK_CUR | SEEK_END
    val seek_set = osval "SEEK_SET"
    val seek_cur = osval "SEEK_CUR"
    val seek_end = osval "SEEK_END"
    fun whToWord SEEK_SET = seek_set
      | whToWord SEEK_CUR = seek_cur
      | whToWord SEEK_END = seek_end
    fun whFromWord wh =
          if wh = seek_set then SEEK_SET
          else if wh = seek_cur then SEEK_CUR
          else if wh = seek_end then SEEK_END
          else fail ("whFromWord","unknown whence "^(Int.toString wh))
    
    structure FD =
      struct
        datatype flags = FDF of word

        fun wordTo w = FDF w
        fun toWord (FDF w) = w

        fun flags ms = FDF(List.foldl (fn (FDF m,acc) => m ++ acc) 0w0 ms)
        fun anySet (FDF m, FDF m') = (m & m') <> 0w0
        fun allSet (FDF m, FDF m') = (m & m') = m

        val cloexec = FDF(w_osval "cloexec")
      end

    structure O = POSIX_FileSys.O
	
    fun fcntl_d (x : s_int, y : s_int) : s_int = Ccall(posix_io_fcntl_d,x,y)
    fun fcntl_gfd (x : s_int) : word = Ccall(posix_io_fcntl_gfd, x)
    fun fcntl_sfd (x : s_int, y : word) : unit = Ccall(posix_io_fcntl_sfd, x, y)
    fun fcntl_gfl (x : s_int) : (word * word) = Ccall(posix_io_fcntl_gfl, x)
    fun fcntl_sfl (x : s_int, y : word) : unit = Ccall(posix_io_fcntl_sfl, x, y)
    fun dupfd {old, base} = fs_fd (fcntl_d (fs_intof old, fs_intof base))
    fun getfd fd = FD.FDF (fcntl_gfd (fs_intof fd))
    fun setfd (fd, FD.FDF fl) = fcntl_sfd(fs_intof fd, fl)
    fun getfl fd = let
          val (sts, omode) = fcntl_gfl (fs_intof fd)
          in
            (O.wordTo sts, PrePosix.omodeFromWord omode)
          end
    fun setfl (fd, sts) = fcntl_sfl (fs_intof fd, O.toWord sts)

    datatype lock_type = F_RDLCK | F_WRLCK | F_UNLCK

    structure FLock =
      struct
        datatype flock = FLOCK of {
             l_type : lock_type,
             l_whence : whence,
             l_start : Position.int,
             l_len : Position.int,
             l_pid : pid option
           }

        fun flock fv = FLOCK fv
        fun ltype (FLOCK{l_type,...}) = l_type
        fun whence (FLOCK{l_whence,...}) = l_whence
        fun start (FLOCK{l_start,...}) = l_start
        fun len (FLOCK{l_len,...}) = l_len
        fun pid (FLOCK{l_pid,...}) = l_pid
      end

    type flock_rep = s_int * s_int * Position.int * Position.int * s_int

    fun fcntl_l (x : s_int, y : s_int, z : flock_rep) : flock_rep = Ccall(posix_io_fcntl_l, x, y, z)
    val f_getlk = osval "F_GETLK"
    val f_setlk = osval "F_SETLK"
    val f_setlkw = osval "F_SETLKW"
    val f_rdlck = osval "F_RDLCK"
    val f_wrlck = osval "F_WRLCK"
    val f_unlck = osval "F_UNLCK"

    fun flockToRep (FLock.FLOCK{l_type,l_whence,l_start,l_len,...}) = let
          fun ltypeOf F_RDLCK = f_rdlck
            | ltypeOf F_WRLCK = f_wrlck
            | ltypeOf F_UNLCK = f_unlck
          in
            (ltypeOf l_type,whToWord l_whence, l_start, l_len, 0)
          end
    fun flockFromRep (usepid,(ltype,whence,start,len,pid)) = let
          fun ltypeOf ltype = 
                if ltype = f_rdlck then F_RDLCK
                else if ltype = f_wrlck then F_WRLCK
                else if ltype = f_unlck then F_UNLCK
                else fail ("flockFromRep","unknown lock type "^(Int.toString ltype))
          in
            FLock.FLOCK { 
              l_type = ltypeOf ltype,
              l_whence = whFromWord whence,
              l_start = start,
              l_len = len,
              l_pid = if usepid then SOME(POSIX_Process.wordToPid(int32touint32 pid)) else NONE
            }
          end

    fun getlk (fd, flock) =
          flockFromRep(true,fcntl_l(fs_intof fd,f_getlk,flockToRep flock))
    fun setlk (fd, flock) =
          flockFromRep(false,fcntl_l(fs_intof fd,f_setlk,flockToRep flock))
    fun setlkw (fd, flock) =
          flockFromRep(false,fcntl_l(fs_intof fd,f_setlkw,flockToRep flock))

    fun lseek (fd,offset,whence) = Ccall(posix_io_lseek,fs_intof fd,offset, whToWord whence)
    fun fsync fd = Ccall(posix_io_fsync, fs_intof fd)

@


1.15
log
@*** empty log message ***
@
text
@a5928 3
(** This probably should be
	datatype iodesc = IODesc of Posix.FileSys.file_desc
 **)
a8434 8
(* posix-io.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Structure for POSIX 1003.1 primitive I/O operations
 *
 *)

a8639 830
(* posix-procenv-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 process environment submodule
 *
 *)

signature POSIX_PROC_ENV =
  sig

    eqtype pid
    eqtype uid
    eqtype gid
    eqtype file_desc

    val uidToWord : uid -> SysWord.word
    val wordToUid : SysWord.word -> uid
    val gidToWord : gid -> SysWord.word
    val wordToGid : SysWord.word -> gid

    val getpid  : unit -> pid
    val getppid : unit -> pid

    val getuid  : unit -> uid
    val geteuid : unit -> uid
    val getgid  : unit -> gid
    val getegid : unit -> gid

    val setuid : uid -> unit
    val setgid : gid -> unit

    val getgroups : unit -> gid list

    val getlogin : unit -> string

    val getpgrp : unit -> pid
    val setsid  : unit -> pid
    val setpgid : {pid : pid option, pgid : pid option} -> unit

    val uname : unit -> (string * string) list

    val time : unit -> Time.time

    val times : unit -> {
            elapsed : Time.time,  (* elapsed system time *)
            utime   : Time.time,  (* user time of process *)
            stime   : Time.time,  (* system time of process *)
            cutime  : Time.time,  (* user time of terminated child processes *)
            cstime  : Time.time   (* system time of terminated child processes *)
          }

    val getenv  : string -> string option
    val environ : unit -> string list

    val ctermid : unit -> string
    val ttyname : file_desc -> string
    val isatty : file_desc -> bool

    val sysconf : string -> SysWord.word

  end (* signature POSIX_PROC_ENV *)

(* posix-procenv.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 process environment submodule
 *
 *)

structure POSIX_ProcEnv :> POSIX_PROC_ENV 
	where type pid = POSIX_Process.pid 
	and   type file_desc = POSIX_FileSys.file_desc 
	and   type uid = PrePosix.uid 
	and   type gid = PrePosix.gid =
  struct

    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32
	
    structure FS = POSIX_FileSys
    structure P  = POSIX_Process


    type pid = P.pid
    type uid = PrePosix.uid
    type gid = PrePosix.gid
    type file_desc = FS.file_desc

    type s_int = SysInt.int

    val uidToWord = PrePosix.uidToWord
    val wordToUid = PrePosix.wordToUid

    val gidToWord = PrePosix.gidToWord
    val wordToGid = PrePosix.wordToGid


    fun getpid () = P.wordToPid(int32touint32(Ccall(posix_procenv_getpid,())))
    fun getppid () = P.wordToPid(int32touint32(Ccall(posix_procenv_getpid,())))

    fun getuid () = wordToUid(Ccall(posix_procenv_getuid,()))
    fun geteuid () = wordToUid(Ccall(posix_procenv_geteuid,()))
    fun getgid () = wordToGid(Ccall(posix_procenv_getgid,()))
    fun getegid () = wordToGid(Ccall(posix_procenv_getegid,()))

    fun setuid uid = Ccall(posix_procenv_setuid,uidToWord uid)
    fun setgid gid = Ccall(posix_procenv_setgid, gidToWord gid)

    fun getgroups () = List.map wordToGid (Ccall(posix_procenv_getgroups,()))
    fun getlogin () : string = Ccall(posix_procenv_getlogin, ())

    fun getpgrp () = P.wordToPid(int32touint32(Ccall(posix_procenv_getpgrp, ())))
    fun setsid () = P.wordToPid(int32touint32(Ccall(posix_procenv_setsid, ())))
    fun setpgid {pid : pid option, pgid : pid option} = let
          fun cvt NONE = 0
            | cvt (SOME(pid)) = uint32toint32(P.pidToWord pid)
          in
            Ccall(posix_procenv_setpgid,cvt pid, cvt pgid)
          end

    fun uname () : (string * string) list = Ccall(posix_procenv_uname, ())

    val sysconf = PrePosix.sysconf

    fun time () = Time.fromSeconds(Ccall(posix_procenv_time, ()))

      (* times in clock ticks *)
    fun times' () :  int * int * int * int * int = Ccall(posix_procenv_times, ())
    val ticksPerSec = Real.fromInt (SysWord.toIntX (sysconf "CLK_TCK"))
    fun times () = let
          fun cvt ticks = Time.fromReal ((Real.fromInt ticks)/ticksPerSec)
          val (e,u,s,cu,cs) = times' ()
          in
            { elapsed = cvt e,
              utime = cvt u, 
              stime = cvt s, 
              cutime = cvt cu, 
              cstime = cvt cs }
          end

    fun getenv  (s : string) :  string option = Ccall(posix_procenv_getenv, s)
    fun environ () :  string list = Ccall(posix_procenv_environ, ())

    fun ctermid () : string = Ccall(posix_procenv_ctermid, ())

    fun ttyname' (x : s_int) : string = Ccall(posix_procenv_ttyname, x)
    fun ttyname fd = ttyname' (uint32toint32(FS.fdToWord fd))

    fun isatty' (x : s_int) : bool = Ccall(posix_procenv_isatty, x)
    fun isatty fd = isatty' (uint32toint32(FS.fdToWord fd))

  end (* structure POSIX_Proc_Env *)

(* posix-tty-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 operations on terminal devices
 *
 *)

signature POSIX_TTY =
  sig

    eqtype pid       (* process ID *)
    eqtype file_desc (* file descriptor *)
    
    structure V :
      sig
        val eof   : int
        val eol   : int
        val erase : int
        val intr  : int
        val kill  : int
        val min   : int
        val quit  : int
        val susp  : int
        val time  : int
        val start : int
        val stop  : int

        val nccs : int

        type cc

        val cc     : (int * char) list -> cc
        val update : cc * (int * char) list -> cc
        val sub    : cc * int -> char
      end
  
    structure I :
      sig
        include POSIX_FLAGS
        
        val brkint : flags
        val icrnl  : flags
        val ignbrk : flags
        val igncr  : flags
        val ignpar : flags
        val inlcr  : flags
        val inpck  : flags
        val istrip : flags
        val ixoff  : flags
        val ixon   : flags
        val parmrk : flags
      end

    structure O :
      sig
        include POSIX_FLAGS
        
        val opost : flags
      end

    structure C :
      sig
        include POSIX_FLAGS
        
        val clocal : flags
        val cread  : flags
        val cs5    : flags
        val cs6    : flags
        val cs7    : flags
        val cs8    : flags
        val csize  : flags
        val cstopb : flags
        val hupcl  : flags
        val parenb : flags
        val parodd : flags
      end

    structure L :
      sig
        include POSIX_FLAGS
        
        val echo   : flags
        val echoe  : flags
        val echok  : flags
        val echonl : flags
        val icanon : flags
        val iexten : flags
        val isig   : flags
        val noflsh : flags
        val tostop : flags
      end


    eqtype speed
    val compareSpeed : speed * speed -> General.order
    val speedToWord : speed -> SysWord.word
    val wordToSpeed : SysWord.word -> speed
    val b0     : speed
    val b50    : speed
    val b75    : speed
    val b110   : speed
    val b134   : speed
    val b150   : speed
    val b200   : speed
    val b300   : speed
    val b600   : speed
    val b1200  : speed
    val b1800  : speed
    val b2400  : speed
    val b4800  : speed
    val b9600  : speed
    val b19200 : speed
    val b38400 : speed
    
    type termios
    
    val termios : { iflag : I.flags,
                    oflag : O.flags,
                    cflag : C.flags,
                    lflag : L.flags,
                    cc : V.cc,
                    ispeed : speed,
                    ospeed : speed } -> termios

    val fieldsOf : termios -> { iflag : I.flags,
                                oflag : O.flags,
                                cflag : C.flags,
                                lflag : L.flags,
                                cc : V.cc,
                                ispeed : speed,
                                ospeed : speed }

    val getiflag  : termios -> I.flags
    val getoflag  : termios -> O.flags
    val getcflag  : termios -> C.flags
    val getlflag  : termios -> L.flags
    val getcc     : termios -> V.cc

    structure CF :
      sig
	  val getospeed : termios -> speed
	  val setospeed : termios * speed -> termios
	  val getispeed : termios -> speed
	  val setispeed : termios * speed -> termios
      end
    
    structure TC :
      sig
        eqtype set_action

        val sanow   : set_action
        val sadrain : set_action
        val saflush : set_action

        eqtype flow_action

        val ooff : flow_action
        val oon  : flow_action
        val ioff : flow_action
        val ion  : flow_action

        eqtype queue_sel

        val iflush  : queue_sel
        val oflush  : queue_sel
        val ioflush : queue_sel
	val getattr : file_desc -> termios
	val setattr : file_desc * set_action * termios -> unit
	val sendbreak : file_desc * int -> unit
	val drain : file_desc -> unit
	val flush : file_desc * queue_sel -> unit
	val flow : file_desc * flow_action -> unit
      end

    val getpgrp : file_desc -> pid
    val setpgrp : file_desc * pid -> unit

  end (* signature POSIX_TTY *)

(* posix-tty.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Structure for POSIX 1003.1 operations on terminal devices
 *
 *)

structure POSIX_TTY :> POSIX_TTY where type pid = POSIX_Process.pid
				   and type file_desc = POSIX_FileSys.file_desc =
  struct
    val int32touint32 = TiltPrim.int32touint32
    val uint32toint32 = TiltPrim.uint32toint32

    structure FS = POSIX_FileSys
    structure P = POSIX_Process

    type pid = POSIX_Process.pid
    type file_desc = POSIX_FileSys.file_desc
    
    type word = SysWord.word
    type s_int = SysInt.int

    val ++ = SysWord.orb
    val & = SysWord.andb
    infix ++ &

    fun osval (s : string) : s_int = Ccall(posix_tty_num,s)
    val w_osval = SysWord.fromInt o osval

    structure I =
      struct
        datatype flags = F of word

        fun wordTo w = F w
        fun toWord (F w) = w

        fun flags ms = F(List.foldl (fn (F m,acc) => m ++ acc) 0w0 ms)
        fun anySet (F m, F m') = (m & m') <> 0w0
        fun allSet (F m, F m') = (m & m') = m

        val brkint = F (w_osval "BRKINT")
        val icrnl  = F (w_osval "ICRNL")
        val ignbrk = F (w_osval "IGNBRK")
        val igncr  = F (w_osval "IGNCR")
        val ignpar = F (w_osval "IGNPAR")
        val inlcr  = F (w_osval "INLCR")
        val inpck  = F (w_osval "INPCK")
        val istrip = F (w_osval "ISTRIP")
        val ixoff  = F (w_osval "IXOFF")
        val ixon   = F (w_osval "IXON")
        val parmrk = F (w_osval "PARMRK")
      end

    structure O =
      struct
        datatype flags = F of word

        fun wordTo w = F w
        fun toWord (F w) = w

        fun flags ms = F(List.foldl (fn (F m,acc) => m ++ acc) 0w0 ms)
        fun anySet (F m, F m') = (m & m') <> 0w0
        fun allSet (F m, F m') = (m & m') = m

        val opost = F (w_osval "OPOST")
      end

    structure C =
      struct
        datatype flags = F of word

        fun wordTo w = F w
        fun toWord (F w) = w

        fun flags ms = F(List.foldl (fn (F m,acc) => m ++ acc) 0w0 ms)
        fun anySet (F m, F m') = (m & m') <> 0w0
        fun allSet (F m, F m') = (m & m') = m

        val clocal = F (w_osval "CLOCAL")
        val cread  = F (w_osval "CREAD")
        val csize  = F (w_osval "CSIZE")
        val cs5    = F (w_osval "CS5")
        val cs6    = F (w_osval "CS6")
        val cs7    = F (w_osval "CS7")
        val cs8    = F (w_osval "CS8")
        val cstopb = F (w_osval "CSTOPB")
        val hupcl  = F (w_osval "HUPCL")
        val parenb = F (w_osval "PARENB")
        val parodd = F (w_osval "PARODD")
      end

    structure L =
      struct
        datatype flags = F of word

        fun wordTo w = F w
        fun toWord (F w) = w

        fun flags ms = F(List.foldl (fn (F m,acc) => m ++ acc) 0w0 ms)
        fun anySet (F m, F m') = (m & m') <> 0w0
        fun allSet (F m, F m') = (m & m') = m

        val echo   = F (w_osval "ECHO")
        val echoe  = F (w_osval "ECHOE")
        val echok  = F (w_osval "ECHOK")
        val echonl = F (w_osval "ECHONL")
        val icanon = F (w_osval "ICANON")
        val iexten = F (w_osval "IEXTEN")
        val isig   = F (w_osval "ISIG")
        val noflsh = F (w_osval "NOFLSH")
        val tostop = F (w_osval "TOSTOP")
      end

    structure V =
      struct
        structure WV = Word8Vector
        structure WA = Word8Array
        structure B = Byte

        val nccs = osval "NCCS"

        val eof   = (osval "EOF")
        val eol   = (osval "EOL")
        val erase = (osval "ERASE")
        val intr  = (osval "INTR")
        val kill  = (osval "KILL")
        val min   = (osval "MIN")
        val quit  = (osval "QUIT")
        val susp  = (osval "SUSP")
        val time  = (osval "TIME")
        val start = (osval "START")
        val stop  = (osval "STOP")

        datatype cc = CC of WV.vector

        fun mkCC (arr, l) = let
              fun update (i, c) = WA.update(arr, i, B.charToByte c)
              in
                List.app update l;
                CC (WA.extract (arr, 0, NONE))
              end

        fun cc vals = mkCC (WA.array(nccs, #"\000"), vals)
        fun update (CC v, vals) =
              mkCC (WA.tabulate (nccs, fn i => WV.sub(v,i)), vals)
        fun sub (CC v, i) = B.byteToChar (WV.sub(v,i))
      end

    datatype speed = B of word
    fun compareSpeed (B w, B w') =
          if SysWord.<(w, w') then LESS
          else if w = w' then EQUAL
          else GREATER
    fun speedToWord (B w) = w
    fun wordToSpeed w = B w
    val b0 = B (w_osval "B0")
    val b50 = B (w_osval "B50")
    val b75 = B (w_osval "B75")
    val b110 = B (w_osval "B110")
    val b134 = B (w_osval "B134")
    val b150 = B (w_osval "B150")
    val b200 = B (w_osval "B200")
    val b300 = B (w_osval "B300")
    val b600 = B (w_osval "B600")
    val b1200 = B (w_osval "B1200")
    val b1800 = B (w_osval "B1800")
    val b2400 = B (w_osval "B2400")
    val b4800 = B (w_osval "B4800")
    val b9600 = B (w_osval "B9600")
    val b19200 = B (w_osval "B19200")
    val b38400 = B (w_osval "B38400")
    
    datatype termios = TIOS of {
        iflag : I.flags,
        oflag : O.flags,
        cflag : C.flags,
        lflag : L.flags,
        cc : V.cc,
        ispeed : speed,
        ospeed : speed
      }

    fun termios arg = TIOS arg
    fun fieldsOf (TIOS arg) = arg
    fun getiflag (TIOS{iflag, ...}) = iflag
    fun getoflag (TIOS{oflag, ...}) = oflag
    fun getcflag (TIOS{cflag, ...}) = cflag
    fun getlflag (TIOS{lflag, ...}) = lflag
    fun getcc (TIOS{cc,...}) = cc

    structure CF =
      struct
	fun getospeed (TIOS{ospeed,...}) = ospeed
	fun getispeed (TIOS{ispeed,...}) = ispeed

	fun setospeed (TIOS r, ospeed) =
	    TIOS {
		  iflag = #iflag r,
		  oflag = #oflag r,
		  cflag = #cflag r,
		  lflag = #lflag r,
		  cc = #cc r,
		  ispeed = #ispeed r,
		  ospeed = ospeed
		  }
	fun setispeed (TIOS r, ispeed) =
	    TIOS {
		  iflag = #iflag r,
		  oflag = #oflag r,
		  cflag = #cflag r,
		  lflag = #lflag r,
		  cc = #cc r,
		  ispeed = ispeed,
		  ospeed = #ospeed r
		  }
      end
    
    fun fs_intof fd = uint32toint32(FS.fdToWord fd)
	
    structure TC =
      struct
        datatype set_action = SA of s_int

        val sanow = SA (osval "TCSANOW")
        val sadrain = SA (osval "TCSADRAIN")
        val saflush = SA (osval "TCSAFLUSH")

        datatype flow_action = FA of s_int

        val ooff = FA (osval "TCOOFF")
        val oon = FA (osval "TCOON")
        val ioff = FA (osval "TCIOFF")
        val ion = FA (osval "TCION")

        datatype queue_sel = QS of s_int

        val iflush = QS (osval "TCIFLUSH")
        val oflush = QS (osval "TCOFLUSH")
        val ioflush = QS (osval "TCIOFLUSH")

(*
	type termio_rep = (
			   word *       	(* iflags *)
			   word *       	(* oflags *)
			   word *       	(* cflags *)
			   word *       	(* lflags *)
			   V.WV.vector *	(* cc *)
			   word *		(* inspeed *)
			   word			(* outspeed *)
			   )
*)
	fun getattr fd = let
			     val (ifs,ofs,cfs,lfs,cc,isp,osp) = Ccall(posix_tty_tcgetattr, fs_intof fd)
			 in
			     TIOS {
				   iflag = I.F ifs,
				   oflag = O.F ofs,
				   cflag = C.F cfs,
				   lflag = L.F lfs,
				   cc = V.CC cc,
				   ispeed = B isp,
				   ospeed = B osp
				   }
			 end
		     
	fun setattr (fd, SA sa, TIOS tios) = let
						 val (I.F iflag) = #iflag tios
						 val (O.F oflag) = #oflag tios
						 val (C.F cflag) = #cflag tios
						 val (L.F lflag) = #lflag tios
						 val (V.CC cc) = #cc tios
						 val (B ispeed) = #ispeed tios
						 val (B ospeed) = #ospeed tios
						 val trep = (iflag,oflag,cflag,lflag,cc,ispeed,ospeed)
					     in
						 Ccall(posix_tty_tcsetattr,fs_intof fd, sa, trep)
					     end

	fun sendbreak (fd, duration) = Ccall(posix_tty_tcsendbreak, fs_intof fd, duration)
	    
	fun drain fd = Ccall(posix_tty_tcdrain, fs_intof fd)
	    
	fun flush (fd, QS qs) = Ccall(posix_tty_tcflush,fs_intof fd, qs)
	    
	fun flow (fd, FA action) = Ccall(posix_tty_tcflow,fs_intof fd, action)
	    
      end

    fun getpgrp fd = P.wordToPid(int32touint32(Ccall(posix_tty_tcgetpgrp,fs_intof fd)))

    fun setpgrp (fd, pid) = Ccall(posix_tty_tcsetpgrp,fs_intof fd, 
				  uint32toint32(P.pidToWord pid))

  end (* structure POSIX_TTY *)

(* posix-sysdb-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 system data-base operations
 *
 *)

signature POSIX_SYS_DB =
  sig
    eqtype uid
    eqtype gid
    
    structure Passwd :
      sig
        type passwd

        val name  : passwd -> string
        val uid   : passwd -> uid
        val gid   : passwd -> gid
        val home  : passwd -> string
        val shell : passwd -> string

      end

    structure Group :
      sig
        type group

        val name    : group -> string
        val gid     : group -> gid
        val members : group -> string list
    
      end
    
    val getgrgid : gid -> Group.group
    val getgrnam : string -> Group.group
    val getpwuid : uid -> Passwd.passwd
    val getpwnam : string -> Passwd.passwd

  end (* signature POSIX_SYS_DB *)

(* posix-sysdb.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Structure for POSIX 1003.1 system data-base operations
 *
 *)

structure POSIX_Sys_DB :> POSIX_SYS_DB 
    where type uid = PrePosix.uid
      and type gid = PrePosix.gid =
  struct

    type word = SysWord.word
    type uid = PrePosix.uid
    type gid = PrePosix.gid
    
    structure Passwd =
      struct
        datatype passwd = PWD of {             (* extensible *)
             name : string,
             uid : uid,
             gid : gid,
             home : string,
             shell : string
           }

        fun name (PWD{name,...}) = name
        fun uid (PWD{uid,...}) = uid
        fun gid (PWD{gid,...}) = gid
        fun home (PWD{home,...}) = home
        fun shell (PWD{shell,...}) = shell

      end

    structure Group =
      struct
        datatype group = GROUP of {              (* extensible *)
             name : string,
             gid : gid,
             members : string list
           }

        fun name (GROUP{name,...}) = name
        fun gid (GROUP{gid,...}) = gid
        fun members (GROUP{members,...}) = members
    
      end
    
    fun getgrgid gid = let val gid = PrePosix.gidToWord gid
          val (name,gid,members) = Ccall(posix_sysdb_getgrgid, gid)
          in
            Group.GROUP { name = name,
              gid = PrePosix.wordToGid gid,
              members = members
            }
          end
    fun getgrnam gname = let
          val (name,gid,members) = Ccall(posix_sysdb_getgrnam, gname)
          in
            Group.GROUP { name = name,
              gid = PrePosix.wordToGid gid,
              members = members
            }
          end

    fun getpwuid uid = let val uid = PrePosix.uidToWord uid
          val (name,uid,gid,dir,shell) = Ccall(posix_sysdb_getpwuid, uid)
          in
            Passwd.PWD { name = name,
              uid = PrePosix.wordToUid uid,
              gid = PrePosix.wordToGid gid,
              home = dir,
              shell = shell
            }
          end
    fun getpwnam name = let
          val (name,uid,gid,dir,shell) = Ccall(posix_sysdb_getpwnam, name)
          in
            Passwd.PWD { name = name,
              uid = PrePosix.wordToUid uid,
              gid = PrePosix.wordToGid gid,
              home = dir,
              shell = shell
            }
          end

  end (* structure POSIX_Sys_DB *)

(* posix-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Signature for POSIX 1003.1 binding
 *
 *)

signature POSIX =
  sig

    structure Error   : POSIX_ERROR
    structure Signal  : POSIX_SIGNAL
    structure Process : POSIX_PROCESS

    structure ProcEnv : POSIX_PROC_ENV
    structure FileSys : POSIX_FILE_SYS
    structure IO      : POSIX_IO
    structure SysDB   : POSIX_SYS_DB
    structure TTY     : POSIX_TTY

    (* These hold for TILT but are not part of this signature.
        type Error.syserror = int
	  
	sharing type Process.pid = ProcEnv.pid = TTY.pid
	    and type Process.signal = Signal.signal
	    and type ProcEnv.file_desc = FileSys.file_desc = TTY.file_desc = IO.file_desc
	    and type FileSys.open_mode = IO.open_mode
	    and type ProcEnv.uid = FileSys.uid = SysDB.uid
	    and type ProcEnv.gid = FileSys.gid = SysDB.gid
	    and type FileSys.O.flags = IO.O.flags
     *)
  end (* signature POSIX *)

(* posix.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Structure for POSIX 1003.1 binding
 *
 *)

structure Posix :>
    sig
	include POSIX
	  where type Error.syserror = int
	  
	sharing type Process.pid = ProcEnv.pid = TTY.pid
	    and type Process.signal = Signal.signal
	    and type ProcEnv.file_desc = FileSys.file_desc = TTY.file_desc = IO.file_desc
	    and type FileSys.open_mode = IO.open_mode
	    and type ProcEnv.uid = FileSys.uid = SysDB.uid
	    and type ProcEnv.gid = FileSys.gid = SysDB.gid
	    and type FileSys.O.flags = IO.O.flags
    end =
  struct

    structure Error   = POSIX_Error
    structure Signal  = POSIX_Signal
    structure Process = POSIX_Process
    structure ProcEnv = POSIX_ProcEnv
    structure FileSys = POSIX_FileSys
    structure IO      = POSIX_IO
    structure SysDB   = POSIX_Sys_DB
    structure TTY     = POSIX_TTY

  end (* structure Posix *)

d8648 1
a8648 1
	  fun putV x = incPos(announce "writeVec" Posix.IO.writeVec (fd, x))
d8658 1
a8658 1
val pv = IO.mkWriter Posix.FileSys.stdout
@


1.14
log
@*** empty log message ***
@
text
@d9481 1
a9481 5
functor PosixPrimIO(structure PrimIO : PRIM_IO
			where type vector = Word8Vector.vector
			  and type array = Word8Array.array
			  and type elem = char
			  and type pos = Position.int) =
a9482 2
      
    structure PrimIO = PrimIO
d9486 1
a9486 3
    val bufferSzB = 4096

    fun mkWriter {fd, name, initBlkMode, appendMode, chunkSize} = let
d9497 1
a9497 2
structure IO = PosixPrimIO(structure PrimIO = TextPrimIO)
structure P = IO.PrimIO
d9499 1
a9499 7
val pv = IO.mkWriter{
	    fd		= Posix.FileSys.stdout,
	    name	= "<stdOut>",
	    initBlkMode	= true,
	    appendMode	= false,
	    chunkSize	= IO.bufferSzB
	  }
@


1.13
log
@*** empty log message ***
@
text
@a9480 392
(* os-path.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This is the UNIX implementation of the generic OS.Path structure.
 *
 *)

structure OS_Path = OS_PathFn (
  struct
    val unsafe_vsub = TiltPrim.unsafe_vsub
    val op ^ = String.^
					 
    exception Path
    exception InvalidArc

    datatype arc_kind = Null | Parent | Current | Arc of string

    fun classify "" = Null
      | classify "." = Current
      | classify ".." = Parent
      | classify a = Arc a

    val parentArc = ".."

    val currentArc = "."

    fun validVolume (_, vol)= Substring.isEmpty vol

    val volSS = Substring.all ""

    (* Note: we are guaranteed that this is never called with "" *)
    fun splitVolPath s = if (unsafe_vsub(s, 0w0) = #"/")
	  then (true, volSS, Substring.triml 1 (Substring.all s))
	  else (false, volSS, Substring.all s)

    fun joinVolPath (true, "", "") = "/"
      | joinVolPath (true, "", s) = "/" ^ s
      | joinVolPath (false, "", s) = s
      | joinVolPath _ = raise Path (* invalid volume *)

    val arcSepChar = #"/"

    fun toUnixPath (s : string) = s
    fun fromUnixPath (s : string) = s
  end);

(* os-filesys.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * The Posix implementation of the generic file system interface.
 *
 *)

structure OS_FileSys :> OS_FILE_SYS =
  struct

    structure P_FSys = Posix.FileSys

(*    val sysWordToWord = Word.fromLargeWord o SysWord.toLargeWord *)
    fun sysWordToWord (x : SysWord.word) = x

    type dirstream = P_FSys.dirstream

    val openDir   = P_FSys.opendir
    val readDir   = P_FSys.readdir
    val rewindDir = P_FSys.rewinddir
    val closeDir  = P_FSys.closedir

    val chDir  = P_FSys.chdir
    val getDir = P_FSys.getcwd
    local
      structure S = P_FSys.S
      val mode777 = S.flags[S.irwxu, S.irwxg, S.irwxo]
    in
    fun mkDir path = P_FSys.mkdir(path, mode777)
    end
    val rmDir  = P_FSys.rmdir
    val isDir  = P_FSys.ST.isDir o P_FSys.stat

    val isLink   = P_FSys.ST.isLink o P_FSys.lstat
    val readLink = P_FSys.readlink

  (* the maximum number of links allowed *)
    val maxLinks = 64

    structure P = OS_Path

  (* A UNIX specific implementation of fullPath *)
    fun fullPath p = let
	  val oldCWD = getDir()
	  fun mkPath pathFromRoot =
		P.toString{isAbs=true, vol="", arcs=List.rev pathFromRoot}
	  and walkPath (0, _, _) = raise TiltExn.SysErr ("too many links", NONE)
	    | walkPath (n, pathFromRoot, []) =
		mkPath pathFromRoot
	    | walkPath (n, pathFromRoot, ""::al) =
		walkPath (n, pathFromRoot, al)
	    | walkPath (n, pathFromRoot, "."::al) =
		walkPath (n, pathFromRoot, al)
	    | walkPath (n, [], ".."::al) =
		walkPath (n, [], al)
	    | walkPath (n, _::r, ".."::al) = (
		chDir ".."; walkPath (n, r, al))
	    | walkPath (n, pathFromRoot, [arc]) =
		if (isLink arc)
		  then expandLink (n, pathFromRoot, arc, [])
		  else mkPath (arc::pathFromRoot)
	    | walkPath (n, pathFromRoot, arc::al) =
		if (isLink arc)
		  then expandLink (n, pathFromRoot, arc, al)
		  else (chDir arc; walkPath (n, arc::pathFromRoot, al))
	  and expandLink (n, pathFromRoot, link, rest) = (
		case (P.fromString(readLink link))
		 of {isAbs=false, arcs, ...} =>
		      walkPath (n-1, pathFromRoot, List.@@(arcs, rest))
		  | {isAbs=true, arcs, ...} =>
		      gotoRoot (n-1, List.@@(arcs, rest))
		(* end case *))
	  and gotoRoot (n, arcs) = 
	       (chDir "/";
	       walkPath (n, [], arcs))
	  fun computeFullPath arcs =
	      (gotoRoot(maxLinks, arcs) before chDir oldCWD)
	      handle ex => (chDir oldCWD; raise ex)
	  in
	    case (P.fromString p)
	     of {isAbs=false, arcs, ...} => let
		  val {arcs=arcs', ...} = P.fromString(oldCWD)
		  in
		    computeFullPath (List.@@(arcs', arcs))
		  end
	      | {isAbs=true, arcs, ...} => computeFullPath arcs
	    (* end case *)
	  end

    fun realPath p = if (P.isAbsolute p)
	  then fullPath p
	  else P.mkRelative (fullPath p, fullPath(getDir()))

    val fileSize = P_FSys.ST.size o P_FSys.stat
    val modTime  = P_FSys.ST.mtime o P_FSys.stat
    fun setTime (path, NONE) = P_FSys.utime(path, NONE)
      | setTime (path, SOME t) = P_FSys.utime(path, SOME{actime=t, modtime=t})
    val remove   = P_FSys.unlink
    val rename   = P_FSys.rename

    datatype access_mode = datatype Posix.FileSys.access_mode

    fun access (path, al) = let
	  fun cvt A_READ = P_FSys.A_READ
	    | cvt A_WRITE = P_FSys.A_WRITE
	    | cvt A_EXEC = P_FSys.A_EXEC
	  in
	    P_FSys.access (path, List.map cvt al)
	  end

(*    val tmpName : unit -> string = CInterface.c_function "POSIX-OS" "tmpname" *)
    fun tmpName() : string = Ccall(posix_os_tmpname,())

    datatype file_id = FID of {dev : SysWord.word, ino : SysWord.word}

    fun fileId fname = let
	  val st = P_FSys.stat fname
	  in
	    FID{
		dev = P_FSys.devToWord(P_FSys.ST.dev st),
		ino = P_FSys.inoToWord(P_FSys.ST.ino st)
	      }
	  end

    fun hash (FID{dev, ino}) = sysWordToWord(
	  SysWord.+(SysWord.<<(dev, 0w16), ino))

    fun compare (FID{dev=d1, ino=i1}, FID{dev=d2, ino=i2}) =
	  if (SysWord.<(d1, d2))
	    then General.LESS
	  else if (SysWord.>(d1, d2))
	    then General.GREATER
	  else if (SysWord.<(i1, i2))
	    then General.LESS
	  else if (SysWord.>(i1, i2))
	    then General.GREATER
	    else General.EQUAL

  end;

(* os-process.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * The Posix-based implementation of the generic process control
 * interface (OS.Process).
 *
 *)

structure OS_Process :> OS_PROCESS =
  struct

    structure P_Proc = Posix.Process
    structure CU = CleanUp

    type status = PreOS.Process.status (* int *)

    val success = 0
    val failure = 1

    fun system cmd = (case P_Proc.fork()
	   of NONE => (
		P_Proc.exec ("/bin/sh", ["sh", "-c", cmd])
		P_Proc.exit 0w127)
	    | (SOME pid) => let
(*  xxxxxxxxxx
		fun savSig s = Signals.setHandler (s, Signals.IGNORE)
		val savSigInt = savSig UnixSignals.sigINT
		val savSigQuit = savSig UnixSignals.sigQUIT
		fun restore () = (
		      Signals.setHandler (UnixSignals.sigINT, savSigInt);
		      Signals.setHandler (UnixSignals.sigQUIT, savSigQuit))
*)
		fun restore() = ()
		fun wait () = (case #2(P_Proc.waitpid(P_Proc.W_CHILD pid, []))
		       of P_Proc.W_EXITED => success
			| (P_Proc.W_EXITSTATUS w) => Word8.toInt w
			| (P_Proc.W_SIGNALED s) => failure (* ?? *)
			| (P_Proc.W_STOPPED s) => failure (* this shouldn't happen *)
		      (* end case *))
		in
		  (wait() before restore())
		    handle ex => (restore(); raise ex)
		end
	  (* end case *))

    local
      val hooks = ref ([] : (unit -> unit) list)
      val _ = CU.addCleaner (
	    "OS.Process",
	    [CU.AtExit],
	    fn _ => List.app (fn f => (f ()) handle _ => ()) (! hooks))
    in
    fun atExit hook = hooks := hook :: !hooks
    end

    fun terminate x = P_Proc.exit(Word8.fromInt x)
    fun exit sts = (CU.clean CU.AtExit; terminate sts)

    val getEnv = Posix.ProcEnv.getenv

  end

(* os-io.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * NOTE: this interface has been proposed, but not yet adopted by the
 * Standard basis committee.
 *
 *)

structure OS_IO :> OS_IO where type iodesc = PreOS.IO.iodesc 
			   and type poll_desc = PreOS.IO.poll_desc 
                           and type poll_info = PreOS.IO.poll_info = 
  struct

  (* an iodesc is an abstract descriptor for an OS object that
   * supports I/O (e.g., file, tty device, socket, ...).
   *)
    type iodesc = PreOS.IO.iodesc

    datatype iodesc_kind = K of string

  (* return a hash value for the I/O descriptor. *)
    fun hash (PreOS.IO.IODesc fd) = Word.fromInt fd

  (* compare two I/O descriptors *)
    fun compare (PreOS.IO.IODesc fd1, PreOS.IO.IODesc fd2) = Int.compare(fd1, fd2)

    structure Kind =
      struct
	val file = K "FILE"
	val dir = K "DIR"
	val symlink = K "LINK"
	val tty = K "TTY"
	val pipe = K "PIPE"
	val socket = K "SOCK"
	val device = K "DEV"
      end

  (* return the kind of I/O descriptor *)
    fun kind (PreOS.IO.IODesc fd) = let
	  val fd = Posix.FileSys.wordToFD(SysWord.fromInt fd)
	  val stat = Posix.FileSys.fstat fd
	  in
	    if      (Posix.FileSys.ST.isReg stat) then Kind.file
	    else if (Posix.FileSys.ST.isDir stat) then Kind.dir
	    else if (Posix.FileSys.ST.isChr stat) then Kind.tty
	    else if (Posix.FileSys.ST.isBlk stat) then Kind.device (* ?? *)
	    else if (Posix.FileSys.ST.isLink stat) then Kind.symlink
	    else if (Posix.FileSys.ST.isFIFO stat) then Kind.pipe
	    else if (Posix.FileSys.ST.isSock stat) then Kind.socket
	    else K "UNKNOWN"
	  end

    type poll_flags = {rd : bool, wr : bool, pri : bool}
    datatype poll_desc = datatype PreOS.IO.poll_desc       (* PollDesc of (iodesc * poll_flags) *)
    datatype poll_info = datatype PreOS.IO.poll_info       (* PollInfo of (iodesc * poll_flags) *)

  (* create a polling operation on the given descriptor; note that
   * not all I/O devices support polling, but for the time being, we
   * don't test for this.
   *)
    fun pollDesc iod = SOME(PollDesc(iod, {rd=false, wr=false, pri=false}))

  (* return the I/O descriptor that is being polled *)
    fun pollToIODesc (PollDesc(iod, _)) = iod

    exception Poll

  (* set polling events; if the polling operation is not appropriate
   * for the underlying I/O device, then the Poll exception is raised.
   *)
    fun pollIn (PollDesc(iod, {rd, wr, pri})) =
	  PollDesc(iod, {rd=true, wr=wr, pri=pri})
    fun pollOut (PollDesc(iod, {rd, wr, pri})) =
	  PollDesc(iod, {rd=rd, wr=true, pri=pri})
    fun pollPri (PollDesc(iod, {rd, wr, pri})) =
	  PollDesc(iod, {rd=rd, wr=wr, pri=true})

  (* polling function *)
    local
(*      val poll' : ((int * word) list * (int * int) option) -> (int * word) list =
	    CInterface.c_function "POSIX-OS" "poll" *)
      fun join (false, _, w) = w
        | join (true, b, w) = Word.orb(w, b)
      fun test (w, b) = (Word.andb(w, b) <> 0w0)
      val rdBit = 0w1 and wrBit = 0w2 and priBit = 0w4
      fun fromPollDesc (PollDesc(PreOS.IO.IODesc fd, {rd, wr, pri})) =
	    ( fd,
	      join (rd, rdBit, join (wr, wrBit, join (pri, priBit, 0w0)))
	    )
      fun toPollInfo (fd, w) = PollInfo(PreOS.IO.IODesc fd, {
	      rd = test(w, rdBit), wr = test(w, wrBit), pri = test(w, priBit)
	    })
    in
    fun poll (pds, timeOut) = let
	  val timeOut = (case timeOut
		 of SOME(PreTime.TIME{sec, usec}) => SOME(sec, usec)
		  | NONE => NONE
		(* end case *))
	  val info = Ccall(posix_os_poll, List.map fromPollDesc pds, timeOut)
	  in
	    List.map toPollInfo info
	  end
    end (* local *)

  (* check for conditions *)
    fun isIn (PollInfo(_, flgs)) = #rd flgs
    fun isOut (PollInfo(_, flgs)) = #wr flgs
    fun isPri (PollInfo(_, flgs)) = #pri flgs
    fun infoToPollDesc  (PollInfo arg) = PollDesc arg

  end (* OS_IO *)


(* os.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * Generic OS interface (NEW BASIS)
 *
 *)

structure OS :> OS where type IO.iodesc = PreOS.IO.iodesc 
                     and type IO.poll_desc = PreOS.IO.poll_desc 
                     and type IO.poll_info = PreOS.IO.poll_info
		     and type syserror = Posix.Error.syserror = 
  struct

    open PreOS (* open type-only structure to get types *)

    val errorMsg = Posix.Error.errorMsg
    val errorName = Posix.Error.errorName
    val syserror = Posix.Error.syserror

    structure FileSys = OS_FileSys
    structure Path = OS_Path
    structure Process : OS_PROCESS = OS_Process
    structure IO = OS_IO

  end (* OS *)

@


1.12
log
@*** empty log message ***
@
text
@d9882 1
a9882 11
    structure Vec = Word8Vector
    structure PF = Posix.FileSys
    structure PIO = Posix.IO

    type file_desc = PF.file_desc

    val toFPI = Position.fromInt

    fun announce s x y = (
	  (*print "Posix: "; print (s:string); print "\n"; *)
	  x y)
a9885 30
    fun isRegFile fd = PF.ST.isReg(PF.fstat fd)

    fun posFns (closed, fd) = if (isRegFile fd)
	  then let
	    val pos = ref(Position.fromInt 0)
	    fun getPos () = !pos
	    fun setPos p = (
		  if !closed then raise IO.ClosedStream else ();
		  pos := announce "lseek" PIO.lseek(fd,p,PIO.SEEK_SET))
	    fun endPos () = (
		  if !closed then raise IO.ClosedStream else ();
		  PF.ST.size(announce "fstat" PF.fstat fd))
	    fun verifyPos () = let
		  val curPos = PIO.lseek(fd, Position.fromInt 0, PIO.SEEK_CUR)
		  in
		    pos := curPos; curPos
		  end
	    in
	      ignore (verifyPos());
	      { pos = pos,
		getPos = SOME getPos,
		setPos = SOME setPos,
		endPos = SOME endPos,
		verifyPos = SOME verifyPos
	      }
	    end
	  else {
	      pos = ref(Position.fromInt 0),
	      getPos = NONE, setPos = NONE, endPos = NONE, verifyPos = NONE
	    }
d9887 4
a9890 43
	  val closed = ref false
          val {pos, getPos, setPos, endPos, verifyPos} = posFns (closed, fd)
	  fun incPos k = (pos := Position.+(!pos, toFPI k); k)
	  val blocking = ref initBlkMode
	  val appendFS = PIO.O.flags(if appendMode then [PIO.O.append] else nil)
	  fun updateStatus() = let
		val flgs = if !blocking
		      then appendFS
		      else PIO.O.flags[PIO.O.nonblock, appendFS]
		in
		  announce "setfl" PIO.setfl(fd, flgs)
		end
	  fun ensureOpen () = if !closed then raise IO.ClosedStream else ()
	  fun ensureBlock (x) =
		if !blocking = x then () else (blocking := x; updateStatus())
	  fun putV x = incPos(announce "writeVec" PIO.writeVec x)
	  fun putA x = incPos(announce "writeArr" PIO.writeArr x)
	  fun write (put, block) arg = (
		ensureOpen(); ensureBlock block; 
		put(fd, arg))
	  fun handleBlock writer arg = SOME(writer arg)
		handle (e as OS.SysErr(_, SOME cause)) => 
 		  if cause = Posix.Error.again then NONE else raise e
	  fun close () = if !closed
		then ()
		else (closed:=true; announce "close" PIO.close fd)
	  in
	    PrimIO.WR{
		name		= name,
		chunkSize	= chunkSize,
		writeVec	= SOME(write(putV,true)),
		writeArr	= SOME(write(putA,true)),
		writeVecNB	= SOME(handleBlock(write(putV,false))),
		writeArrNB	= SOME(handleBlock(write(putA,false))),
		block		= NONE,
		canOutput	= NONE,
		getPos		= getPos,
		setPos		= setPos,
		endPos		= endPos,
		verifyPos	= verifyPos,
		ioDesc		= SOME(PF.fdToIOD fd),
		close		= close
	      }
d9900 1
a9900 1
val wr : P.writer = IO.mkWriter{
d9907 5
a9911 10
val P.WR{writeVec,...} = wr
val _ = (case writeVec
	   of NONE => Ccall(hack_print,"writeVec unimplemented\n")
	    | SOME wv =>
	      let val text = "die\n"
	          val textlen = 4
	          val n = wv {buf=text, i=0, sz=NONE}
	      in  if n = textlen then ()
	          else Ccall(hack_print,"writeVec partial\n")
	      end)
@


1.11
log
@*** empty log message ***
@
text
@a9925 66

    fun mkReader {fd, name, initBlkMode} = let
	  val closed = ref false
          val {pos, getPos, setPos, endPos, verifyPos} = posFns (closed, fd)
          val blocking = ref initBlkMode
          fun blockingOn () = (PIO.setfl(fd, PIO.O.flags[]); blocking := true)
	  fun blockingOff () = (PIO.setfl(fd, PIO.O.nonblock); blocking := false)
	  fun incPos k = pos := Position.+(!pos, toFPI k)
	  fun readVec n = let
		val v = announce "read" PIO.readVec(fd, n)
		in
		  incPos (Vec.length v); v
		end
	  fun readArr arg = let
		val k = announce "readBuf" PIO.readArr(fd, arg)
		in
		  incPos k; k
		end
	  fun blockWrap f x = (
		if !closed then raise IO.ClosedStream else ();
		if !blocking then () else blockingOn();
		f x)
	  fun noBlockWrap f x = (
		if !closed then raise IO.ClosedStream else ();
		if !blocking then blockingOff() else ();
		((* try *) SOME(f x)
		  handle (e as OS.SysErr(_, SOME cause)) =>
                     if cause = Posix.Error.again then NONE else raise e
		(* end try *)))
	  fun close () = if !closed
		then ()
		else (closed:=true; announce "close" PIO.close fd)
	  val isReg = isRegFile fd
	  fun avail () = if !closed
		  then SOME 0
		else if isReg
		  then SOME(Position.-(PF.ST.size(PF.fstat fd), !pos))
		  else NONE
	  in
	    PrimIO.RD{
		name		= name,
		chunkSize	= bufferSzB,
		readVec		= SOME(blockWrap readVec),
		readArr		= SOME(blockWrap readArr),
		readVecNB	= SOME(noBlockWrap readVec),
		readArrNB	= SOME(noBlockWrap readArr),
		block		= NONE,
		canInput	= NONE,
		avail		= avail,
		getPos		= getPos,
		setPos		= setPos,
		endPos		= endPos,
		verifyPos	= verifyPos,
		close		= close,
		ioDesc		= SOME(PF.fdToIOD fd)
	      }
	  end

	     
    fun openRd name = mkReader{
	    fd = announce "openf" PF.openf(name,PIO.O_RDONLY,PF.O.flags[]),
	    name = name,
	    initBlkMode = true
	  }


a9970 25

    val standardMode = PF.S.flags[	(* mode 0666 *)
	    PF.S.irusr, PF.S.iwusr,
	    PF.S.irgrp, PF.S.iwgrp,
	    PF.S.iroth, PF.S.iwoth
	  ]
    fun createFile (name, mode, flags) =
	  announce "createf" PF.createf(name, mode, flags, standardMode)

    fun openWr name = mkWriter{
	    fd=createFile(name, PIO.O_WRONLY, PF.O.trunc),
	    name=name,
	    initBlkMode=true,
	    appendMode=false,
	    chunkSize=bufferSzB
	  }

    fun openApp name = mkWriter{
	    fd		= createFile(name, PIO.O_WRONLY, PF.O.append),
	    name	= name,
	    initBlkMode	= true,
	    appendMode	= true,
	    chunkSize	= bufferSzB
	  }

@


1.10
log
@*** empty log message ***
@
text
@d10064 2
a10065 7
structure PosixTextCoreIO = PosixPrimIO(structure PrimIO = TextPrimIO)

structure PosixTextPrimIO =
struct

    structure PF = Posix.FileSys
    structure PrimIO = TextPrimIO
d10067 2
a10068 9
    type file_desc = PF.file_desc

    open PosixTextCoreIO

    fun stdIn () = mkReader{
	    fd		= PF.stdin,
	    name	= "<stdIn>",
	    initBlkMode	= true (* Bug!  Should check! *)
	  }
d10070 2
a10071 2
    fun stdOut () = mkWriter{
	    fd		= PF.stdout,
d10073 3
a10075 3
	    initBlkMode	= true (* Bug!  Should check! *),
	    appendMode	= false (* Bug!  Should check! *),
	    chunkSize	= bufferSzB
a10076 68

    fun stdErr () = mkWriter{
	    fd		= PF.stderr,
	    name	= "<stdErr>",
	    initBlkMode	= true, (* Bug!  Should check! *)
	    appendMode	= false, (* Bug!  Should check! *)
	    chunkSize	= bufferSzB
	  }

    fun strReader src = let
	  val pos = ref 0
	  val closed = ref false
	  fun checkClosed () = if !closed then raise IO.ClosedStream else ()
	  val len = String.size src
	  fun avail () = (len - !pos)
	  fun readV n = let
		val p = !pos
		val m = Int.min(n, len-p)
		in
		  checkClosed ();
		  pos := p+m;
(** NOTE: could use unchecked operations here **)
		  String.substring (src, p, m)
		end
	  fun readA {buf, i, sz} = let
		val p = !pos
		val m = (case sz
		       of NONE => Int.min(CharArray.length buf-i, len-p)
			| (SOME n) => Int.min(n, len-p)
		      (* end case *))
		in
		  checkClosed ();
		  pos := p+m;
		  CharArray.copyVec {src=src, si=p, len=SOME m, dst=buf, di=i};
		  m
		end
	  fun getPos () = (checkClosed(); !pos)
	  in
	    PrimIO.RD{
		name      = "<string>", 
		chunkSize = len,
		readVec   = SOME(readV),
        	readArr   = SOME(readA),
		readVecNB = SOME(SOME o readV),
		readArrNB = SOME(SOME o readA),
		block     = SOME(checkClosed),
		canInput  = SOME(fn () => (checkClosed(); true)),
		avail     = SOME o avail,
		getPos    = SOME getPos,
		setPos    = SOME(fn i => (
				checkClosed();
				if (i < 0) orelse (len < i)
				  then raise Subscript
				  else ();
				pos := i)),
        	endPos    = SOME(fn () => (checkClosed(); len)),
		verifyPos = SOME getPos,
		close     = fn () => closed := true,
		ioDesc    = NONE
	      }
	  end

  end;
extern hack_print : (string, unit) -->
val _ = Ccall(hack_print,"die\n")

structure P = PosixTextPrimIO.PrimIO
val wr : P.writer = PosixTextPrimIO.stdOut()
@


1.9
log
@*** empty log message ***
@
text
@a9872 888

(* text-io-fn.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * QUESTION: what operations should raise exceptions when the stream is
 * closed?
 *
 *)

functor TextIOFn (structure OSPrimIO :
		      sig
		          include OS_PRIM_IO
                          val stdIn   : unit -> PrimIO.reader
			  val stdOut  : unit -> PrimIO.writer
			  val stdErr  : unit -> PrimIO.writer
			  val strReader : string -> PrimIO.reader
		      end
		      where PrimIO = TextPrimIO)
    =
struct
    
    structure PIO = OSPrimIO.PrimIO
    structure A = CharArray
    structure V = CharVector

  (* an element for initializing buffers *)
    val someElem = #"\000"

(** Fast, but unsafe version (from CharVector) **
    val vecSub = InlineT.CharVector.sub
    val arrUpdate = InlineT.CharArray.update
  (* fast vector extract operation.  This should never be called with
   * a length of 0.
   *)
    fun vecExtract (v, base, optLen) = let
	  val len = V.length v
	  fun newVec n = let
		val newV = Assembly.A.create_s n
		fun fill i = if (i < n)
		      then (
			InlineT.CharVector.update(newV, i, vecSub(v, base+i));
			fill(i+1))
		      else ()
		in
		  fill 0; newV
		end
	  in
	    case (base, optLen)
	     of (0, NONE) => v
	      | (_, NONE) => newVec (len - base)
	      | (_, SOME n) => newVec n
	    (* end case *)
	  end
**)
    val vecExtract = V.extract
    val vecSub = V.sub
    val arrUpdate = A.update
    val substringBase = Substring.base
    val empty = ""

    structure StreamIO =
      struct
	type vector = V.vector
	type elem = V.elem
	type reader = PIO.reader
	type writer = PIO.writer
	type pos = PIO.pos

      (*** Functional input streams ***)
	datatype instream = ISTRM of (in_buffer * int)
	and in_buffer = IBUF of {
	    basePos : pos option,
	    more : more ref,
	    data : vector,
	    info : info
	  }
	and more
	  = MORE of in_buffer	(* forward link to additional data *)
	  | NOMORE		(* placeholder for forward link *)
	  | TERMINATED		(* termination of the stream *)

	and info = INFO of {
	    reader : reader,
	    readVec : int -> vector,
	    readVecNB : (int -> vector) option,
	    closed : bool ref,
	    getPos : unit -> pos option,
	    tail : more ref ref, (* points to the more cell of the last buffer *)
	    cleanTag : CleanIO.tag
	  }

	fun infoOfIBuf (IBUF{info, ...}) = info
	fun chunkSzOfIBuf buf = let
	      val INFO{reader=PIO.RD{chunkSize, ...}, ...} = infoOfIBuf buf
	      in
		chunkSize
	      end
	fun readVec (IBUF{info=INFO{readVec=f, ...}, ...}) = f

	fun inputExn (INFO{reader=PIO.RD{name, ...}, ...}, mlOp, exn) =
	      raise IO.Io{function=mlOp, name=name, cause=exn}

      (* this exception is raised by readVecNB in the blocking case *)
	exception WouldBlock

	datatype more_data = EOF | DATA of in_buffer

	fun extendStream (readFn, mlOp, buf as IBUF{more, info, ...}) = (let
	      val INFO{getPos, tail, ...} = info
              val basePos = getPos()
	      val chunk = readFn (chunkSzOfIBuf buf)
	      in
		if (V.length chunk = 0)
		  then EOF
		  else let
		    val newMore = ref NOMORE
		    val buf' = IBUF{
                            basePos = basePos, data = chunk,
			    more = newMore, info = info
			  }
		    in
		      more := MORE buf';
		      tail := newMore;
		      DATA buf'
		    end
	      end
		handle ex => inputExn(info, mlOp, ex))

	fun getBuffer (readFn, mlOp) (buf as IBUF{more, info, ...}) = (
	      case !more
	       of TERMINATED => EOF
		| NOMORE => extendStream (readFn, mlOp, buf)
		| (MORE buf') => DATA buf'
	      (* end case *))

      (* read a chunk that is at least the specified size *)
	fun readChunk buf = let
	      val INFO{readVec, reader=PIO.RD{chunkSize, ...}, ...} =
		     infoOfIBuf buf
	      in
		case (chunkSize - 1)
		 of 0 => (fn n => readVec n)
		  | k => (* round up to next multiple of chunkSize *)
		      (fn n => readVec(Int.quot((n+k), chunkSize) * chunkSize))
		(* end case *)
	      end

	fun generalizedInput getBuf = let
	      fun get (ISTRM(buf as IBUF{data, ...}, pos)) = let
		    val len = V.length data
		    in
		      if (pos < len)
			then (vecExtract(data, pos, NONE), ISTRM(buf, len))
			else (case (getBuf buf)
			   of EOF => (empty, ISTRM(buf, len))
			    | (DATA rest) => get (ISTRM(rest, 0))
			  (* end case *))
		    end
	      in
		get
	      end


      (* terminate an input stream *)
	fun terminate (INFO{tail, cleanTag, ...}) = (case !tail
	       of (m as ref NOMORE) => (
		    CleanIO.removeCleaner cleanTag;
		    m := TERMINATED)
		| (m as ref TERMINATED) => ()
	      (* end case *))

      (* find the end of the stream *)
	fun findEOS (IBUF{more=ref(MORE buf), ...}) = findEOS buf
	  | findEOS (buf as IBUF{data, ...}) = ISTRM(buf, V.length data)

	fun input (strm as ISTRM(buf, _)) =
	      generalizedInput (getBuffer (readVec buf, "input")) strm
	fun input1 (ISTRM(buf, pos)) = let
	      val IBUF{data, more, ...} = buf
	      in
		if (pos < V.length data)
		  then SOME(vecSub(data, pos), ISTRM(buf, pos+1))
		  else (case !more
		     of (MORE buf) => input1 (ISTRM(buf, 0))
		      | NOMORE => (
			  case extendStream (readVec buf, "input1", buf)
			   of EOF => NONE
			    | (DATA rest) => input1 (ISTRM(rest, 0))
			  (* end case *))
		      | TERMINATED => NONE
		    (* end case *))
	      end
	fun inputN (ISTRM(buf, pos), n) = let
	      fun join (item, (list, strm)) = (item::list, strm)
	      fun inputList (buf as IBUF{data, ...}, i, n) = let
		    val len = V.length data
		    val remain = len-i
		    in
		      if (remain >= n)
			then ([vecExtract(data, i, SOME n)], ISTRM(buf, i+n))
		      else join (
			vecExtract(data, i, NONE),
			nextBuf(buf, n-remain))
		    end
	      and nextBuf (buf as IBUF{more, data, ...}, n) = (case !more
		     of (MORE buf) => inputList (buf, 0, n)
		      | NOMORE => (
			  case extendStream (readVec buf, "inputN", buf)
			   of EOF => ([], ISTRM(buf, V.length data))
			    | (DATA rest) => inputList (rest, 0, n)
			  (* end case *))
		      | TERMINATED => ([], ISTRM(buf, V.length data))
		    (* end case *))
	      val (data, strm) = inputList (buf, pos, n)
	      in
		(V.concat data, strm)
	      end
	fun inputAll (strm as ISTRM(buf, _)) = let
	      val INFO{reader=PIO.RD{avail, ...}, ...} = infoOfIBuf buf
 	    (* read a chunk that is as large as the available input.  Note
	     * that for systems that use CR-LF for #"\n", the size will be
	     * too large, but this should be okay.
	     *)
	      fun bigChunk _ = let
		    val delta = (case avail()
			   of NONE => chunkSzOfIBuf buf
			    | (SOME n) => n
			  (* end case *))
		    in
		      readChunk buf delta
		    end
	      val bigInput =
		    generalizedInput (getBuffer (bigChunk, "inputAll"))
	      fun loop (v, strm) =
		    if (V.length v = 0) then [] else v :: loop(bigInput strm)
	      val data = V.concat (loop (bigInput strm))
	      in
		(data, findEOS buf)
	      end
      (* Return SOME k, if k <= amount characters can be read without blocking. *)
	fun canInput (strm as ISTRM(buf, pos), amount) = let
	      val readVecNB = (case buf
		   of (IBUF{info as INFO{readVecNB=NONE, ...}, ...}) =>
			inputExn(info, "canInput", IO.NonblockingNotSupported)
		    | (IBUF{info=INFO{readVecNB=SOME f, ...}, ...}) => f
		  (* end case *))
	      fun tryInput (buf as IBUF{data, ...}, i, n) = let
		    val len = V.length data
		    val remain = len - i
		    in
		      if (remain >= n)
			then SOME n
			else nextBuf (buf, n - remain)
		    end
	      and nextBuf (IBUF{more, ...}, n) = (case !more
		     of (MORE buf) => tryInput (buf, 0, n)
		      | TERMINATED => SOME(amount - n)
		      | NOMORE => ((
			  case extendStream (readVecNB, "canInput", buf)
			   of EOF => SOME(amount - n)
			    | (DATA b) => tryInput (b, 0, n)
			  (* end case *))
			    handle IO.Io{cause=WouldBlock, ...} => SOME(amount - n))
		    (* end case *))
	      in
		if (amount < 0)
		  then raise Size
		  else tryInput (buf, pos, amount)
	      end
	fun closeIn (ISTRM(buf, _)) = (case (infoOfIBuf buf)
	       of INFO{closed=ref true, ...} => ()
		| (info as INFO{closed, reader=PIO.RD{close, ...}, ...}) => (
		    terminate info;
		    closed := true;
		    close() handle ex => inputExn(info, "closeIn", ex))
	      (* end case *))
	fun endOfStream (ISTRM(buf, pos)) = (case buf
	       of (IBUF{more=ref(MORE _), ...}) => false
		| (IBUF{more, data, info=INFO{closed, ...}, ...}) =>
		    if (pos = V.length data)
		      then (case (!more, !closed)
			 of (NOMORE, false) => (
			      case extendStream (readVec buf, "endOfStream", buf)
			       of EOF => true
				| _ => false
			    (* end case *))
			  | _ => true
			(* end case *))
		      else false
	      (* end case *))
	fun mkInstream (reader, optData) = let
	      val PIO.RD{readVec, readVecNB, getPos, setPos, ...} = reader
	      val readVec' = (case readVec
		     of NONE => (fn _ => raise IO.BlockingNotSupported)
		      | (SOME f) => f
		    (* end case *))
	      val readVecNB' = (case readVecNB
		     of NONE => NONE
		      | (SOME f) => SOME(fn arg => case (f arg)
			   of (SOME x) => x
			    | NONE => raise WouldBlock
			  (* end case *))
		    (* end case *))
	      val getPos = (case (getPos, setPos)
		     of (SOME f, SOME _) => (fn () => SOME(f()))
		      | _ => (fn () => NONE)
		    (* end case *))
	      val more = ref NOMORE
	      val closedFlg = ref false
	      val tag = CleanIO.addCleaner {
		      init = fn () => (closedFlg := true),
		      flush = fn () => (),
		      close = fn () => (closedFlg := true)
		    }
	      val info = INFO{
		      reader=reader, readVec=readVec', readVecNB=readVecNB',
		      closed = closedFlg, getPos = getPos, tail = ref more,
		      cleanTag = tag
		    }
	      val buf = (case optData
		     of NONE => IBUF{
			    basePos = getPos(), data=empty,
			    info=info, more=more
			  }
(** What should we do about the position in this case ?? **)
(** Suggestion: When building a stream with supplied initial data,
 ** nothing can be said about the positions inside that initial
 ** data (who knows where that data even came from!).
 **) 
		      | (SOME v) => IBUF{
			    basePos = NONE, data=v,
			    info=info, more=more}
		    (* end case *))
	      in
		ISTRM(buf, 0)
	      end

	fun getReader (ISTRM(buf, pos)) = let
	      val IBUF{data, info as INFO{reader, ...}, more, ...} = buf
	      fun getData (MORE(IBUF{data, more, ...})) = data :: getData(!more)
		| getData _ = []
	      in
		terminate info;
		if (pos < V.length data)
		  then (
		      reader,
		      V.concat(vecExtract(data, pos, NONE) :: getData(!more))
		    )
		  else (reader, V.concat(getData(!more)))
	      end

      (** Position operations on instreams **)
	datatype in_pos = INP of {
	    base : pos,
	    offset : int,
	    info : info
	  }

	fun getPosIn (ISTRM(buf, pos)) = (case buf
	       of IBUF{basePos=NONE, info, ...} =>
		    inputExn (info, "getPosIn", IO.RandomAccessNotSupported)
		| IBUF{basePos=SOME p, info, ...} => INP{
		      base = p, offset = pos, info = info
		    }
	      (* end case *))
	fun filePosIn (INP{base, offset=0, ...}) = base
	  | filePosIn (INP{base, offset, info}) = let
	      val INFO{reader=PIO.RD rd, readVec, ...} = info
	      in
		case (#getPos rd, #setPos rd)
		 of (SOME getPos, SOME setPos) => let
		      val tmpPos = getPos()
		      fun readN 0 = ()
			| readN n = (case V.length(readVec n)
			     of 0 => inputExn (
				    info, "filePosIn", TiltExn.LibFail "bogus position")
			      | k => readN(n-k)
			    (* end case *))
		      in
			setPos base;
			readN offset;
			getPos () before setPos tmpPos
		      end
		  | _ => raise TiltExn.LibFail "filePosIn: impossible"
		(* end case *)
	      end
	fun setPosIn (pos as INP{info as INFO{reader, ...}, ...}) = let
	      val fpos = filePosIn pos
	      val (PIO.RD rd) = reader
	      in
		terminate info;
		Option.valOf (#setPos rd) fpos;
		mkInstream (PIO.RD rd, NONE)
	      end

      (** Text stream specific operations **)
	fun inputLine (ISTRM(buf as IBUF{data, ...}, pos)) = let
	      fun join (item, (list, strm)) = (item::list, strm)
	      fun nextBuf (isEmpty, buf as IBUF{more, data, ...}) = let
		    fun last () =
			  (if isEmpty then [] else ["\n"], ISTRM(buf, V.length data))
		    in
		      case !more
		       of (MORE buf) => scanData (buf, 0)
			| NOMORE => (
			    case extendStream (readVec buf, "inputLine", buf)
			     of EOF => last ()
			      | (DATA rest) => scanData (rest, 0)
			    (* end case *))
			| TERMINATED => last ()
		      (* end case *)
		    end
	      and scanData (buf as IBUF{data, more, ...}, i) = let
		    val len = V.length data
		    fun scan j = if (j = len)
			    then join(vecExtract(data, i, NONE), nextBuf(false, buf))
			  else if (vecSub(data, j) = #"\n")
			    then ([vecExtract(data, i, SOME(j+1-i))], ISTRM(buf, j+1))
			    else scan (j+1)
		    in
		      scan i
		    end
	      val (data, strm) = if (V.length data = pos)
		    then nextBuf (true, buf)
		    else scanData (buf, pos)
	      in
		(V.concat data, strm)
	      end

      (*** Output streams ***)
	datatype outstream = OSTRM of {
	    buf : A.array,
	    pos : int ref,
	    closed : bool ref,
	    bufferMode : IO.buffer_mode ref,
	    writer : writer,
	    writeArr : {buf : A.array, i : int, sz : int option} -> unit,
	    writeVec : {buf : V.vector, i : int, sz : int option} -> unit,
	    cleanTag : CleanIO.tag
	  }

	fun outputExn (OSTRM{writer=PIO.WR{name, ...}, ...}, mlOp, exn) =
	      raise IO.Io{function=mlOp, name=name, cause=exn}

	fun isNL #"\n" = true
	  | isNL _ = false

	fun isClosedOut (strm as OSTRM{closed=ref true, ...}, mlOp) =
	      outputExn (strm, mlOp, IO.ClosedStream)
	  | isClosedOut _ = ()

	fun flushBuffer (strm as OSTRM{buf, pos, writeArr, ...}, mlOp) = (
	      case !pos
	       of 0 => ()
		| n => ((
		    writeArr {buf=buf, i=0, sz=SOME n}; pos := 0)
		      handle ex => outputExn (strm, mlOp, ex))
	      (* end case *))

      (* A version of copyVec that checks for newlines, while it is copying.
       * This is used for LINE_BUF output of strings and substrings.
       *)
	fun lineBufCopyVec (src, srcI, srcLen, dst, dstI) = let
	      val stop = srcI+srcLen
	      fun cpy (srcI, dstI, lb) =
		    if (srcI < stop)
		      then let val c = vecSub(src, srcI)
			in
			  arrUpdate (dst, dstI, c);
			  cpy (srcI+1, dstI+1, lb orelse isNL c)
			end
		      else lb
	      in
		cpy (srcI, dstI, false)
	      end

      (* a version of copyVec for BLOCK_BUF output of strings and substrings. *)
	fun blockBufCopyVec (src, srcI, srcLen, dst, dstI) = (
	      A.copyVec {
		  src = src, si = srcI, len = SOME srcLen, dst = dst, di = dstI
		};
	      false)

	fun output (strm as OSTRM os, v) = let
	      val _ = isClosedOut (strm, "output")
	      val {buf, pos, bufferMode, ...} = os
	      fun flush () = flushBuffer (strm, "output")
	      fun writeDirect () = (
		    case !pos
		     of 0 => ()
		      | n => (#writeArr os {buf=buf, i=0, sz=SOME n}; pos := 0)
		    (* end case *);
		    #writeVec os {buf=v, i=0, sz=NONE})
		      handle ex => outputExn (strm, "output", ex)
	      fun insert copyVec = let
		    val bufLen = A.length buf
		    val dataLen = V.length v
		    in
		      if (dataLen >= bufLen)
			then writeDirect()
			else let
			  val i = !pos
			  val avail = bufLen - i
			  in
			    if (avail < dataLen)
			      then let
				val _ = A.copyVec{
					src=v, si=0, len=SOME avail, dst=buf, di=i
				      }
				val _ = #writeArr os {buf=buf, i=0, sz=NONE}
				      handle ex => (
					pos := bufLen;
					outputExn (strm, "output", ex))
				val needsFlush = copyVec(v, avail, dataLen-avail, buf, 0)
				in
				  pos := dataLen-avail;
				  if needsFlush then flush() else ()
				end
			      else let
			 	val needsFlush = copyVec(v, 0, dataLen, buf, i)
				in
				  pos := i + dataLen;
				  if (needsFlush orelse (avail = dataLen))
				    then flush()
				    else ()
				end
			  end
		    end
	      in
		case !bufferMode
		 of IO.NO_BUF => writeDirect ()
		  | IO.LINE_BUF => insert lineBufCopyVec
		  | IO.BLOCK_BUF => insert blockBufCopyVec
		(* end case *)
	      end

	fun output1 (strm as OSTRM{buf, pos, bufferMode, writeArr, ...}, elem) = (
	      isClosedOut (strm, "output1");
	      case !bufferMode
	       of IO.NO_BUF => (
		    arrUpdate (buf, 0, elem);
		    writeArr {buf=buf, i=0, sz=SOME 1}
		      handle ex => outputExn (strm, "output1", ex))
		| IO.LINE_BUF => let val i = !pos val i' = i+1
		    in
		      arrUpdate (buf, i, elem); pos := i';
		      if ((i' = A.length buf) orelse (isNL elem))
			then flushBuffer (strm, "output1")
			else ()
		    end
		| IO.BLOCK_BUF => let val i = !pos val i' = i+1
		    in
		      arrUpdate (buf, i, elem); pos := i';
		      if (i' = A.length buf)
			then flushBuffer (strm, "output1")
			else ()
		    end
	      (* end case *))

	fun flushOut strm = (
	      flushBuffer (strm, "flushOut"))

	fun closeOut (strm as OSTRM{writer=PIO.WR{close, ...}, closed, cleanTag, ...}) =
	      if !closed
		then ()
		else (
		  flushBuffer (strm, "closeOut");
		  closed := true;
		  CleanIO.removeCleaner cleanTag;
		  close())

	fun mkOutstream (wr as PIO.WR{chunkSize, writeArr, writeVec, ...}, mode) =
	      let
	      fun iterate f (buf, i, sz) = let
		    fun lp (_, 0) = ()
		      | lp (i, n) = let val n' = f{buf=buf, i=i, sz=SOME n}
			  in lp (i+n', n-n') end
		    in
		      lp (i, sz)
		    end
	      val writeArr' = (case writeArr
		     of NONE => (fn _ => raise IO.BlockingNotSupported)
		      | (SOME f) => let
			  fun write {buf, i, sz} = let
				val len = (case sz
				       of NONE => A.length buf - i
					| (SOME n) => n
				      (* end case *))
				in
				  iterate f (buf, i, len)
				end
			  in
			    write
			  end
		    (* end case *))
	      val writeVec' = (case writeVec
		     of NONE => (fn _ => raise IO.BlockingNotSupported)
		      | (SOME f) => let
			  fun write {buf, i, sz} = let
				val len = (case sz
				       of NONE => V.length buf - i
					| (SOME n) => n
				      (* end case *))
				in
				  iterate f (buf, i, len)
				end
			  in
			    write
			  end
		    (* end case *))
	    (* install a dummy cleaner *)
	      val tag = CleanIO.addCleaner {
		      init = fn () => (),
		      flush = fn () => (),
		      close = fn () => ()
		    }
	      val strm = OSTRM{
		      buf = A.array(chunkSize, someElem),
		      pos = ref 0,
		      closed = ref false,
		      bufferMode = ref mode,
		      writer = wr,
		      writeArr = writeArr',
		      writeVec = writeVec',
		      cleanTag = tag
		    }
	      in
		CleanIO.rebindCleaner (tag, {
		    init = fn () => closeOut strm,
		    flush = fn () => flushOut strm,
		    close = fn () => closeOut strm
		  });
		strm
	      end

	fun getWriter (strm as OSTRM{writer, bufferMode, ...}) = (
	      flushBuffer (strm, "getWriter");
	      (writer, !bufferMode))

      (** Position operations on outstreams **)
	datatype out_pos = OUTP of {
	    pos : PIO.pos,
	    strm : outstream
	  }

	fun getPosOut (strm as OSTRM{writer, ...}) = (
	      flushBuffer (strm, "getPosOut");
	      case writer
	       of PIO.WR{getPos=SOME f, ...} => (
		    OUTP{pos = f(), strm = strm}
		      handle ex => outputExn(strm, "getPosOut", ex))
		| _ => outputExn(strm, "getPosOut", IO.RandomAccessNotSupported)
	      (* end case *))
	fun filePosOut (OUTP{pos, strm}) = (
	      isClosedOut (strm, "filePosOut"); pos)
	fun setPosOut (OUTP{pos, strm as OSTRM{writer, ...}}) = (
	      isClosedOut (strm, "setPosOut");
	      case writer
	       of PIO.WR{setPos=SOME f, ...} => (
		    (f pos)
		      handle ex => outputExn(strm, "setPosOut", ex))
		| _ => outputExn(strm, "getPosOut", IO.RandomAccessNotSupported)
	      (* end case *))

      (** Text stream specific operations **)
	fun outputSubstr (strm as OSTRM os, ss) = let
	      val _ = isClosedOut (strm, "outputSubstr")
	      val (v, dataStart, dataLen) = substringBase ss
	      val {buf, pos, bufferMode, ...} = os
	      val bufLen = A.length buf
	      fun flush () = flushBuffer (strm, "outputSubstr")
	      fun writeDirect () = (
		    case !pos
		     of 0 => ()
		      | n => (#writeArr os {buf=buf, i=0, sz=SOME n}; pos := 0)
		    (* end case *);
		    #writeVec os {buf=v, i=dataStart, sz=SOME dataLen})
		      handle ex => outputExn (strm, "outputSubstr", ex)
	      fun insert copyVec = let
		    val bufLen = A.length buf
		    in
		      if (dataLen >= bufLen)
			then writeDirect()
			else let
			  val i = !pos
			  val avail = bufLen - i
			  in
			    if (avail < dataLen)
			      then let
				val _ = A.copyVec{
					src=v, si=dataStart, len=SOME avail, dst=buf, di=i
				      }
				val _ = #writeArr os {buf=buf, i=0, sz=NONE}
				      handle ex => (
					pos := bufLen;
					outputExn (strm, "outputSubstr", ex))
				val needsFlush = copyVec(v, avail, dataLen-avail, buf, 0)
				in
				  pos := dataLen-avail;
				  if needsFlush then flush() else ()
				end
			    else let
			      val needsFlush = copyVec(v, dataStart, dataLen, buf, i)
			      in
				pos := i + dataLen;
				if (needsFlush orelse (avail = dataLen))
				  then flush()
				  else ()
			      end
			  end
		    end
	      in
		case !bufferMode
		 of IO.NO_BUF => writeDirect()
		  | IO.LINE_BUF => insert lineBufCopyVec
		  | IO.BLOCK_BUF => insert blockBufCopyVec
		(* end case *)
	      end

	fun setBufferMode (strm as OSTRM{bufferMode, ...}, IO.NO_BUF) = (
	      flushBuffer (strm, "setBufferMode");
	      bufferMode := IO.NO_BUF)
	  | setBufferMode (strm as OSTRM{bufferMode, ...}, mode) = (
	      isClosedOut (strm, "setBufferMode");
	      bufferMode := mode)
	fun getBufferMode (strm as OSTRM{bufferMode, ...}) = (
	      isClosedOut (strm, "getBufferMode");
	      !bufferMode)

      end (* StreamIO *)

    type vector = V.vector
    type elem = V.elem
    type instream = StreamIO.instream ref
    type outstream = StreamIO.outstream ref

  (** Input operations **)
    fun input strm = let val (v, strm') = StreamIO.input(!strm)
	  in
	    strm := strm'; v
	  end
    fun input1 strm = (case StreamIO.input1(!strm)
	   of NONE => NONE
	    | (SOME(elem, strm')) => (strm := strm'; SOME elem)
	  (* end case *))
    fun inputN (strm, n) = let val (v, strm') = StreamIO.inputN (!strm, n)
	  in
	    strm := strm'; v
	  end
    fun inputAll (strm : instream) = let
	  val (v, strm') = StreamIO.inputAll(!strm)
	  in
	    strm := strm'; v
	  end
    fun canInput (strm, n) = StreamIO.canInput (!strm, n)
    fun lookahead (strm : instream) = (case StreamIO.input1(!strm)
	   of NONE => NONE
	    | (SOME(elem, _)) => SOME elem
	  (* end case *))
    fun closeIn strm = let
	  val (s as StreamIO.ISTRM(buf as StreamIO.IBUF{data, ...}, _)) = !strm
	  in
	    StreamIO.closeIn s;
	    strm := StreamIO.findEOS buf
	  end
    fun endOfStream strm = StreamIO.endOfStream(! strm)
    fun getPosIn strm = StreamIO.getPosIn(!strm)
    fun setPosIn (strm, p) = (strm := StreamIO.setPosIn p)

  (** Output operations **)
    fun output (strm, v) = StreamIO.output(!strm, v)
    fun output1 (strm, c) = StreamIO.output1(!strm, c)
    fun flushOut strm = StreamIO.flushOut(!strm)
    fun closeOut strm = StreamIO.closeOut(!strm)
    fun getPosOut strm = StreamIO.getPosOut(!strm)
    fun setPosOut (strm, p as StreamIO.OUTP{strm=strm', ...}) = (
	  strm := strm'; StreamIO.setPosOut p)

    fun mkInstream (strm : StreamIO.instream) = ref strm
    fun getInstream (strm : instream) = !strm
    fun setInstream (strm : instream, strm') = strm := strm'

    fun mkOutstream (strm : StreamIO.outstream) = ref strm
    fun getOutstream (strm : outstream) = !strm
    fun setOutstream (strm : outstream, strm') = strm := strm'

  (* figure out the proper buffering mode for a given writer *)
    fun bufferMode (PIO.WR{ioDesc=NONE, ...}) = IO.BLOCK_BUF
      | bufferMode (PIO.WR{ioDesc=SOME iod, ...}) =
	  if (OS.IO.kind iod = OS.IO.Kind.tty) then IO.LINE_BUF else IO.BLOCK_BUF

  (** Open files **)
    fun openIn fname =
	  mkInstream(StreamIO.mkInstream(OSPrimIO.openRd fname, NONE))
	    handle ex => raise IO.Io{function="openIn", name=fname, cause=ex}
    fun openOut fname = let
	  val wr = OSPrimIO.openWr fname
	  in
	    mkOutstream (StreamIO.mkOutstream (wr, bufferMode wr))
	  end
	    handle ex => raise IO.Io{function="openOut", name=fname, cause=ex}
    fun openAppend fname =
	  mkOutstream(StreamIO.mkOutstream(OSPrimIO.openApp fname, IO.NO_BUF))
	    handle ex => raise IO.Io{function="openAppend", name=fname, cause=ex}

  (** Text stream specific operations **)
    fun inputLine strm = let val (s, strm') = StreamIO.inputLine (!strm)
	  in
	    strm := strm'; s
	  end
    fun outputSubstr (strm, ss) = StreamIO.outputSubstr (!strm, ss)
    fun openString src =
	  mkInstream(StreamIO.mkInstream(OSPrimIO.strReader src, NONE))
	    handle ex => raise IO.Io{function="openIn", name="<string>", cause=ex}

  (* the standard streams *)
    local
      structure SIO = StreamIO
      fun mkStdIn () = let
	    val (strm as SIO.ISTRM(SIO.IBUF{info=SIO.INFO{cleanTag, ...}, ...}, _)) =
		  SIO.mkInstream(OSPrimIO.stdIn(), NONE)
	    in
	      CleanIO.rebindCleaner (cleanTag, {
		  init = fn () => (),
		  flush = fn () => (),
		  close = fn () => ()
		});
	      strm
	    end
      fun mkStdOut () = let
	    val wr = OSPrimIO.stdOut()
	    val (strm as SIO.OSTRM{cleanTag, ...}) =
		  SIO.mkOutstream(wr, bufferMode wr)
	    in
	      CleanIO.rebindCleaner (cleanTag, {
		 init = fn () => (),
		 flush = fn () => SIO.flushOut strm,
		 close = fn () => SIO.flushOut strm
		});
	      strm
	    end

      fun mkStdErr () = let
	    val (strm as SIO.OSTRM{cleanTag, ...}) =
		  SIO.mkOutstream(OSPrimIO.stdErr(), IO.NO_BUF)
	    in
	      CleanIO.rebindCleaner (cleanTag, {
		 init = fn () => (),
		 flush = fn () => SIO.flushOut strm,
		 close = fn () => SIO.flushOut strm
		});
	      strm
	    end
    in


    val stdIn = mkInstream(mkStdIn()) 
    val stdOut = mkOutstream(mkStdOut()) 
    val stdErr = mkOutstream(mkStdErr())

  (* Establish a hook function to rebuild the I/O stack *)
    val _ = CleanIO.stdStrmHook := (fn () => (
	  setInstream (stdIn, mkStdIn());
	  setOutstream (stdOut, mkStdOut());
	  setOutstream (stdErr, mkStdErr())))
    end (* local *)

    fun print s = (output (stdOut, s); flushOut stdOut)

    fun scanStream scanFn = let
	  val scan = scanFn StreamIO.input1
	  fun doit strm = let
		val instrm = getInstream strm
		in
		  case scan instrm
		   of NONE => NONE
		    | SOME(item, instrm') => (
			setInstream(strm, instrm');
			SOME item)
		  (* end case *)
		end
	  in
	    doit
	  end

  end

a10063 2
structure PosixBinPrimIO = PosixPrimIO(structure PrimIO = BinPrimIO)

a10069 1
    structure BinPrimIO = PosixBinPrimIO
a10151 2

structure TextIO = TextIOFn (structure OSPrimIO = PosixTextPrimIO);
d10154 13
a10166 1
val _ = TextIO.print "die\n"
@


1.8
log
@*** empty log message ***
@
text
@a6592 4
	(* this function is defined in TextIOFn, and is called after the osHook,
	 * but before the per-stream init functions.  It is used to rebuild the
	 * standard streams.
	 *)
d10759 1
a10759 11
  end (* TextIOFn *)

(* posix-bin-prim-io.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This implements the UNIX version of the OS specific binary primitive
 * IO structure.  The Text IO version is implemented by a trivial translation
 * of these operations (see posix-text-prim-io.sml).
 *
 *)
d10950 1
a10950 1
  end; (* PosixBinPrimIO *)
d10952 1
d10954 1
d10956 2
a10957 37
(* posix-bin-prim-io.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This implements the UNIX version of the OS specific binary primitive
 * IO structure.  The Text IO version is implemented by a trivial translation
 * of these operations (see posix-text-prim-io.sml).
 *
 *)

structure PosixBinPrimIO : OS_PRIM_IO = PosixPrimIO(structure PrimIO = BinPrimIO)
(* posix-text-prim-io.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 * This implements the UNIX version of the OS specific text primitive
 * IO structure.  It is implemented by a trivial translation of the
 * binary operations (see posix-bin-prim-io.sml).
 *
 *)

structure PosixTextPrimIO = PosixPrimIO(structure PrimIO = TextPrimIO)

structure PosixTextPrimIO : sig

    include OS_PRIM_IO
      where PrimIO = TextPrimIO
      where type file_desc = Posix.ProcEnv.file_desc

    val stdIn  : unit -> PrimIO.reader
    val stdOut : unit -> PrimIO.writer
    val stdErr : unit -> PrimIO.writer

    val strReader : string -> PrimIO.reader

  end
  = struct
d10965 1
a10965 1
    open PosixTextPrimIO
d11042 1
a11042 1
  end; (* PosixTextPrimIO *)
@


1.7
log
@*** empty log message ***
@
text
@d6040 1
a6040 80

(* text-stream-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature TEXT_STREAM_IO =
  sig
    include STREAM_IO
      where type vector = string
        and type elem = char
    val inputLine    : instream -> string * instream
    val outputSubstr : outstream * Substring.substring -> unit
  end

(* text-io-sig.sml
 *
 * COPYRIGHT (c) 1995 AT&T Bell Laboratories.
 *
 *)

signature TEXT_IO =
sig

    structure StreamIO : TEXT_STREAM_IO

    type vector = StreamIO.vector
    type elem = StreamIO.elem

    type instream
    type outstream

    val input    : instream -> vector
    val input1   : instream -> elem option
    val inputN   : instream * int -> vector
    val inputAll : instream -> vector
    val canInput : instream * int -> int option
	
    val lookahead : instream -> elem option
    val closeIn : instream -> unit
    val endOfStream : instream -> bool

    val output   : outstream * vector -> unit
    val output1  : outstream * elem -> unit
    val flushOut : outstream -> unit
    val closeOut : outstream -> unit

    val getPosIn    : instream -> StreamIO.in_pos
    val setPosIn    : instream * StreamIO.in_pos -> unit
    val mkInstream  : StreamIO.instream -> instream
    val getInstream : instream -> StreamIO.instream
    val setInstream : instream * StreamIO.instream -> unit

    val getPosOut    : outstream -> StreamIO.out_pos
    val setPosOut    : outstream * StreamIO.out_pos -> unit
    val mkOutstream  : StreamIO.outstream -> outstream
    val getOutstream : outstream -> StreamIO.outstream
    val setOutstream : outstream * StreamIO.outstream -> unit

    val inputLine    : instream -> string
    val outputSubstr : outstream * PreString.substring -> unit

    val openIn     : string -> instream
    val openOut    : string -> outstream
    val openAppend : string -> outstream
    val openString : string -> instream

    val stdIn  : instream
    val stdOut : outstream
    val stdErr : outstream

    val print : string -> unit

    val scanStream : ((elem, StreamIO.instream) StringCvt.reader
		      -> ('a, StreamIO.instream) StringCvt.reader)
		     -> instream -> 'a option

  end;

d9896 1
a9896 3
    :> TEXT_IO where type StreamIO.pos = TextPrimIO.pos
                 and type StreamIO.reader = TextPrimIO.reader
		 and type StreamIO.writer = TextPrimIO.writer =
@


1.6
log
@*** empty log message ***
@
text
@d1 11171
a11171 1
(*$import Firstlude TiltPrim Prelude TextIOFn PosixTextPrimIO *)
@


1.5
log
@*** empty log message ***
@
text
@d1 1
a1 1
(*$import Firstlude TiltPrim Prelude TextIOFn TEXT_IO PosixTextPrimIO TextPrimIO *)
@


1.4
log
@*** empty log message ***
@
text
@d1 4
a4 1
(*$import Firstlude TiltPrim Prelude TextIO *)
@


1.3
log
@*** empty log message ***
@
text
@d1 2
a2 2
(*$import *)
val _ = print "die\n"
@


1.2
log
@*** empty log message ***
@
text
@d1 2
a2 193
(*$import TextIO CommandLine OS String Posix Date Time *)

signature HELP =
sig
    val fail : string -> 'a

    (* (execute path args) executes program with arguments.  Path must
       be absolute. *)
    val execute : string -> string list -> unit

    (* (join dir file) is dir/file. *)
    val join : string -> string -> string

    (* (joinExt ext file) is file.ext *)
    val joinExt : string -> string -> string

    datatype ty = FILE | DIR
    type ent = ty * string

    (* (expand path) examines the filesystem to find a partially
       sorted list of files and directories reachable from path.  The
       partial order: A directory is listed after its contents.
       Parent and current arcs (eg, .. and . on Unix) are never
       listed.  If path does not exist, the list is empty.  If path
       exists and is a directory, the list will include the directory
       and all its contents.  If path exists and is not a directory,
       the list will be a singleton.  *)
    val expand : string -> ent list
end

structure Help : HELP =
struct
    fun fail (s : string) : 'a =
	let val print = fn s => TextIO.output (TextIO.stdErr, s)
	in
	    print (CommandLine.name() ^ ": ");
	    print s;
	    print "\n";
	    OS.Process.exit (OS.Process.failure)
	end

    fun execute' (path : string) (args : string list) : OS.Process.status =
	(Posix.Process.exec (path, OS.Path.file path :: args);
	 Posix.Process.exit 0w127)
(*
	(case Posix.Process.fork()
	   of NONE => (Posix.Process.exec (path, OS.Path.file path :: args);
		       Posix.Process.exit 0w127)
	    | SOME pid =>
	       (case #2 (Posix.Process.waitpid (Posix.Process.W_CHILD pid, []))
		  of Posix.Process.W_EXITED => OS.Process.success
		   | _ => OS.Process.failure))
*)

    fun execute (path : string) (args : string list) : unit =
	if execute' path args = OS.Process.success
	    then ()
	else 
	    let val cmd = foldr (fn (s,a) => " " :: s :: a) nil (path :: args)
		val msg = "command returned non-zero exit status:" :: cmd
	    in  fail (String.concat msg)
	    end
	 
    fun join (dir : string) (file : string) : string =
	OS.Path.joinDirFile {dir = dir, file = file}

    fun joinExt (ext : string) (file : string) : string =
	OS.Path.joinBaseExt {base=file, ext=SOME ext}

    datatype ty = FILE | DIR
    type ent = ty * string
    
    fun expand' (path : string, acc : ent list) : ent list =
	if not (OS.FileSys.access (path, [])) then []
	else
	    if OS.FileSys.isDir path
		then
		    let val join = join path
			val dirstream = OS.FileSys.openDir path
			fun loop acc = (case OS.FileSys.readDir dirstream
					  of "" => acc
					   | path => loop ((join path) :: acc))
			val contents = loop nil
			val _ = OS.FileSys.closeDir dirstream
		    in	foldl expand' ((DIR, path) :: acc) contents
		    end
	    else (FILE, path) :: acc
		
    fun expand (path : string) : ent list =
	expand' (path, nil)
end

signature CONFIG =
sig
    (* Absolute paths to the binaries we need. *)
    val cvs : string
    val gnuTar : string
	      
    (* Temporary space. *)
    val tmpdir : string
	      
    val destdir : string		(* Where to store files *)
    val release : string		(* How to name files *)
	      
    (* Where to find TILT in CVS. *)
    val cvsroot : string
    val cvsmodule : string
    val cvsversion : string

    (* Files and directories that may exist in CVS but do not need to
       be released. *)
    val private : string list
end

structure Config : CONFIG =
struct
    val cvs = "/usr/local/bin/cvs"
    val gnuTar = "/usr/local/bin/gtar"
	
    val tmpdir = "/usr/tmp"

    val destdir = tmpdir
	
    (* Base release tag on today's date; eg, 20020514. *)
    val release = Date.fmt "%Y%m%d" (Date.fromTimeUniv (Time.now()))

    (* Get repository and version from command line. *)
    val (cvsroot, cvsversion) =
	(case CommandLine.arguments()
	   of [a,b] => (a,b)
	    | _ => Help.fail "expected CVS root and module version (eg, -Ddate or -rtag) as arguments")
    val cvsmodule = "ml96"

    val private =
	[
	 "Apps","Bench","BenchData",
	 "Bin/makeRelease",
	 "Bin/run",
	 "Doc/buglist.txt",
	 "Doc/issue.txt",
	 "Doc/log.txt",
	 "Doc/overview.txt",		(* needs updating *)
	 "Doc/tm.txt",
	 "MLRISC",
	 "Preludes",
	 "README.CMU",
	 "Release",
	 "RtlToMLRISC",
	 "Self",
	 "Wizard",
	 "icfp"
	 ]
end

(* A source release is made via "cvs export".  Some files in the CVS
   tree do not need to be released and are deleted.  *)

fun makeRelease () =
    let
	open Help
    
	val _ = OS.FileSys.chDir Config.tmpdir
	    
	val tiltRelease : string
	    = "tilt-" ^ Config.release

	val _ = print "Performing CVS export.\n"
	val _ = if OS.FileSys.access (tiltRelease, [])
		    then print "(CVS export unnecessary.)\n"
		else execute Config.cvs ["-Q", "-d", Config.cvsroot, "export",
					 Config.cvsversion, "-d", tiltRelease, Config.cvsmodule]

	fun removeEnt ((ty, path) : ent) : unit =
	    (case ty
	       of FILE => OS.FileSys.remove
		| DIR => OS.FileSys.rmDir) path

	val remove : string -> unit =
	    (app removeEnt) o expand

	val _ = print "Removing unnecessary files.\n"
	val _ = app (remove o (join tiltRelease)) Config.private

	val tarFile : string
	    = ((joinExt "gz") o (joinExt "tar") o (join Config.destdir)) tiltRelease
    
	val _ = print "Creating tarball.\n"
	val _ = (remove tarFile;
		 execute Config.gnuTar ["czf",tarFile,tiltRelease])
    in  ()
    end

val _ = makeRelease() handle e => Help.fail ("uncaught exception: " ^ exnMessage e)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
(*$import TextIO CommandLine OS String Posix *)
a91 1
(*$import Help Date Time CommandLine *)
a153 1
(*$import Help Config OS *)
@
