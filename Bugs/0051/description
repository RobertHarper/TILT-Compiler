Number: 0051
Title:       Vararg violating bound variable invariant.
Keywords:    Nil, Vararg, Hoist
Submitter:   David Swasey <swasey@cs.cmu.edu>
Date:        5/14/2001
Version:     CVS
System:	     any
Severity:    major
Problem:
	Compilation of the code below fails during Optimize2 phase when compiling EqualBug.  This came up while testing some
	changes to the equality compiler.
Code:
	[Supporting files in CVS prior to 1/6/04.]

	This has been simplified further.  See ./mapfile.
	
	EqualBugSetup:
	(*$import Prelude TopLevel *)

	signature NAME = sig type var = int end
	structure Name :> NAME = struct type var = int end
	signature IL = sig type var = Name.var end
	structure Il :> IL = struct open Name type var = Name.var end

	EqualBug:
	(*$import Prelude TopLevel EqualBugSetup *)

	structure Equal =
	struct
	    type 'a bindparm = {fromVar  : Il.var -> 'a}
	    fun bind (parm : 'a bindparm) = ()
	end
Transcript:
	  [0 imports of total size 0 were cached.
	   111 imports of total size 426617 were uncached and took 2.3 seconds.]
	  [Added contexts.]
	  [Parsing equal-bug.sml]
	  [Elaborating equal-bug.sml non-constrained]
	gc_context: 351 items in original context.  4 items in reduced context.
	  [writing TM/any/equal-bug.sml.il - unnecessary]
	===== Starting Phasesplit: EqualBug                      =====
	  Initial context is phase-split
	  Bindings are phase-split
	  Imports are computed
	  Exports are phase-split
	===== Starting Rename: EqualBug                          =====
	===== Starting Optimize1: EqualBug                       =====
	===== Starting Vararg: EqualBug                          =====
	===== Starting Inline1: EqualBug                         =====
	  0 functions inlined once.
	  0 copies of 0 other functions inlined.
	===== Starting Reify1: EqualBug                          =====
	===== Starting Specialize: EqualBug                      =====
	  0 optimizable candidates.
	  0 impure.
	  2 escaping.
	  0 used polymorphically.
	===== Starting Hoist: EqualBug                           =====
	Imports Processed
	===== Starting Optimize2: EqualBug                       =====
	tilt: nilcontext.sml::Vinsert: Variable already occurs in context: type_8287
Comments:
	First Vararg duplicates the code ``LET type_962 = _c947.var IN type_962 END'' then Hoist hoists each occurrence of
	type_962 to the top-level.  The module generated by Hoist isn't well-formed due to duplicate bindings of the form
	``type_962 = _c_947.var''.

	We can fix this bug by performing another Linearize after Hoist.  However Hoist should really return a valid module so I
	don't consider this the right fix.

	Here is the code before Vararg:
	          [_951 = 
	*          FUN('a_950 ::  TYPE)
	*              = RECORD[fromVar]
	*                  (ALLARROW(Open; PARTIAL; (); (LET  type_962 = _c_947.var
	*                                                IN   type_962
	*                                                END); 0; 'a_950)),
	*          /LEAF\bind_r_961
	*            (var_poly_c_953 :: REC_K{'a > 'a_TYV_955 :  TYPE} ;; 
	*             var_poly_r_954 : Unknown : DEP_RECORD[ ] ;; 
	*             )
	*          =>LET  type_966 = ALLARROW(Open; PARTIAL; (); 
	*                               (LET  type_964 = var_poly_c_953.'a
	*                                     type_965 = APP(_951,(type_964))
	*                                IN   type_965
	*                                END); 0; 
	*                               UNIT)
	*            IN   type_966
	*            END =
	*          Let  /\ bind_inner_959
	*                 ( ;; mvar_957 : Unknown : APP(_951,(var_poly_c_953.'a)) ;; )
	*               ->UNIT =
	*               Let  _963 : Unknown = record()
	*               In   _963
	*               End
	*          In   bind_inner_959
	*          End]
	
	Here is the code after Vararg:
	          [_951 = 
	*          FUN('a_950 ::  TYPE)
	*              = RECORD[fromVar](VARARG[Open->](LET  type_962 = _c_947.var
	*                                               IN   type_962
	*                                               END, 'a_950)),
	*          /LEAF\bind_r_961
	*            (var_poly_c_953 :: REC_K{'a > 'a_TYV_955 :  TYPE} ;; 
	*             var_poly_r_954 : Unknown : DEP_RECORD[ ] ;; 
	*             )
	*          =>LET  type_966 = ALLARROW(Open; PARTIAL; (); 
	*                               (VARARG[Open->]
	*                                  (LET  type_962 = _c_947.var
	*                                   IN   type_962
	*                                   END, var_poly_c_953.'a)); 0; 
	*                               UNIT)
	*            IN   type_966
	*            END =
	*          Let  /\ bind_inner_959
	*                 ( ;; 
	*                  fromVar_973 : 
	*                    Unknown : 
	*                    VARARG[Open->](LET  type_962 = _c_947.var
	*                                   IN   type_962
	*                                   END, var_poly_c_953.'a) ;; 
	*                  )
	*               ->UNIT =
	*               Let  mvar_957 : Unknown = record(fromVar>fromVar_973)
	*                    _963 : Unknown = record()
	*               In   _963
	*               End
	*          In   bind_inner_959
	*          End]

	Here is the code after Hoist:
	          [type_962 = _c_947.var,
	*          _951 = 
	*          FUN('a_950 ::  TYPE) = RECORD[fromVar](VARARG[Open->](type_962, 'a_950)),
	*          type_962 = _c_947.var,
	*          type_962 = _c_947.var,
	*          _963 : Trace = record(),
	*          /LEAF\bind_r_961
	*            (var_poly_c_953 :: REC_K{'a > 'a_TYV_955 :  TYPE} ;; 
	*             var_poly_r_954 : Trace : DEP_RECORD[ ] ;; 
	*             )
	*          =>ALLARROW(Open; PARTIAL; (); 
	*               (VARARG[Open->](type_962, var_poly_c_953.'a)); 0; 
	*               UNIT) =
	*          Let  /\ bind_inner_959
	*                 ( ;; 
	*                  fromVar_973 : Trace : VARARG[Open->](type_962, var_poly_c_953.'a) ;; 
	*                  )
	*               =>UNIT =
	*               Let  mvar_957 : Trace = record(fromVar>fromVar_973)
	*               In   _963
	*               End
	*          In   bind_inner_959
	*          End]

	There is an invariant during optimization that all bound variables are distinct.  Vararg is violating this invariant.  The
	fix I implemented was to add some missing renaming inside the vararg pass.

	I believe that in vararg, constructor level variables get duplicated only as a result of reduction.  We could easily
	arrange to blindly rename all values returned by the normalizer (by renaming inside getarrow, getsum, getrecord, and
	reduce_hnf).  This would lead to some unnecessary renaming, however, which is (I guess) why we've opted for the more
	tedious solution of renaming by hand after reduction.  In keeping with the current design:

	(1) In the constructor translation for arrows (in do_arrow), portions of the argument constructor which show up in the
	    translation get renamed.
	    
	(2) Similarly for constructors classifying term arguments in function bindings (in do_fun).

	(3) There was no constructor renaming added at function application sites (in do_app) because the code was already
            correct.

	Note (1) fixed the bugs demonstrated by ./mapfile.  I believe (2) is necessary but haven't got an SML sample which
	requires it.
Fix:
Test:
Owner: swasey
Status: closed
