Number: 0036
Title:       Incorret code generation on the alpha.
Keywords:    alpha, LSR, code generation, register allocation
Submitter:   David Swasey <swasey@cs.cmu.edu>
Date:        12/1/00
Version:     CVS
System:	     alpha
Severity:    major
Problem:
	Build an executable from the following code.  This exe does not terminate.
		structure Format : sig
		
		    val wordToHex : word -> int * char list
		
		  end = struct
		
		    fun mkDigit (w : word) = TiltPrim.unsafe_vsub("0123456789abcdef", w)
		
		    fun wordToOct w = let
			  fun f1 (w, n, l) = if TiltPrim.ult(w, 0w8)
				then (TiltPrim.iplus(n, 1), (mkDigit w) :: l)
				else f1(TiltPrim.>>(w, 3),
					TiltPrim.iplus(n : int, 1),
					mkDigit(TiltPrim.&&(w, 0wx7)) :: l)
			  in
			    f1 (w, 0, [])
			  end
		    fun wordToDec w = let
			  fun f2 (w, n, l) = if TiltPrim.ult(w,0w10)
				then (TiltPrim.iplus(n, 1), (mkDigit w) :: l)
				else let val j = TiltPrim.udiv(w, 0w10)
				  in
				    f2 (j,
					TiltPrim.iplus(n, 1),
					mkDigit(TiltPrim.uminus(w,TiltPrim.umult(0w10,j))) :: l)
				  end
			  in
			    f2 (w, 0, [])
			  end
		    fun wordToHex w = let
			  fun f3 (w, n, l) = if TiltPrim.ult(w, 0w16)
				then (TiltPrim.iplus(n, 1), (mkDigit w) :: l)
				else f3(TiltPrim.>>(w, 4),
					TiltPrim.iplus(n, 1),
					mkDigit(TiltPrim.&&(w, 0wxf)) :: l)
			  in
			    f3 (w, 0, [])
			  end
		
		    fun fmtW 8 = wordToOct
		      | fmtW 10 = wordToDec
		      | fmtW 16 = wordToHex
		
		    fun fmtWord radix = fmtW radix
		  end;
		val _ = Format.wordToHex 0wxFFFFFFFF
Code:
	[Supporting files in CVS prior to 1/6/04.]

	The generated alpha assembler looks like short_bad.sml.s.
Transcript:
Comments:
	The alpha doesn't provide a 32-bit right shift.  Compaq recommends a
	sequence like:

		;; Rtl.SRL (Rw,4,Rdest)
		zap	Rw, 240, Rdest		; w & FFFFFFFF
		srl	Rdest, 4, Rdest		; (w & FFFFFFFF) >> 4
		addl	Rdest, Rzero, Rdest	; sign_extend((w & FFFFFFFF) >> 4)

	which uses the 64-bit "srl" instruction, takes a canonical source, and
	leaves a canonical result.  (On the alpha, the canonical 64-bit
	representation of a 32-bit quantity w is sign_extend(w).) This is the
	right shift sequence generated by TILT.  Unfortunately it interacts
	poorly with spilling.

	When a spilled integer value is read off the stack into a register, it
	is sign extended so the register contains a canonical form value.  This
	sign extension is not always correct.  It breaks the code sequence
	above when "dest" is spilled:

		;; actual code generated for Rtl.SRL(Rw,4,Rdest)
		;; when Rdest is spilled to destOffset.
		zap	Rw, 240, Rtmp
		stl	Rtmp, destOffset($sp)
		ldl	Rtmp, destOffset($sp)		; sign extends
		srl	Rtmp, 4, Rtmp
		stl	Rtmp, destOffset($sp)
		ldl	Rtmp, destOffset($sp)		; sign extends
		addl	Rtmp, Rzero, Rtmp
		stl	Rtmp, destOffset($sp)

	To see that this is wrong, suppose that Rw contains FFFFFFFFFFFFFFFF,
	the canonical form for FFFFFFFF.  After the second sequence, the 32-bit
	value at destOffset + $sp will be FFFFFFFF, not 0FFFFFFF as expected.

	The problem is that Rdest is temporarily being used as a full 64-bit
	quantity and not merely as the 64-bit encoding of a 32-bit quantity.
	This violates an assumption of the register allocator.
Fix: (from Chris)
	Off hand, it seems safe to have the code generator directly generate:

	 	zap	Rw, 240, Rtmp		; w & FFFFFFFF
	 	srl	Rtmp, 4, Rtmp		; (w & FFFFFFFF) >> 4
	 	addl	Rtmp, Rzero, Rdest	; sign_extend((w & FFFFFFFF) >> 4)

	where Rtmp could be either $at or the other temporary register reserved
	by TILT.
Test:
Owner: swasey
Status: closed
