Number: 0036
Title:       Incorret code generation on the alpha.
Keywords:    alpha, LSR, code generation, register allocation
Submitter:   David Swasey <swasey@cs.cmu.edu>
Date:        12/1/00
Version:     CVS
System:	     alpha
Severity:    major
Problem:
	Build an executable from short and short.sml.  This exe does not terminate.
Code:
	The generated alpha assembler looks like short_bad.sml.s.
Transcript:
Comments:
	The alpha doesn't provide a 32-bit right shift.  Compaq recommends a
	sequence like:

		;; Rtl.SRL (Rw,4,Rdest)
		zap	Rw, 240, Rdest		; w & FFFFFFFF
		srl	Rdest, 4, Rdest		; (w & FFFFFFFF) >> 4
		addl	Rdest, Rzero, Rdest	; sign_extend((w & FFFFFFFF) >> 4)

	which uses the 64-bit "srl" instruction, takes a canonical source, and
	leaves a canonical result.  (On the alpha, the canonical 64-bit
	representation of a 32-bit quantity w is sign_extend(w).) This is the
	right shift sequence generated by TILT.  Unfortunately it interacts
	poorly with spilling.

	When a spilled integer value is read off the stack into a register, it
	is sign extended so the register contains a canonical form value.  This
	sign extension is not always correct.  It breaks the code sequence
	above when "dest" is spilled:

		;; actual code generated for Rtl.SRL(Rw,4,Rdest)
		;; when Rdest is spilled to destOffset.
		zap	Rw, 240, Rtmp
		stl	Rtmp, destOffset($sp)
		ldl	Rtmp, destOffset($sp)		; sign extends
		srl	Rtmp, 4, Rtmp
		stl	Rtmp, destOffset($sp)
		ldl	Rtmp, destOffset($sp)		; sign extends
		addl	Rtmp, Rzero, Rtmp
		stl	Rtmp, destOffset($sp)

	To see that this is wrong, suppose that Rw contains FFFFFFFFFFFFFFFF,
	the canonical form for FFFFFFFF.  After the second sequence, the 32-bit
	value at destOffset + $sp will be FFFFFFFF, not 0FFFFFFF as expected.

	The problem is that Rdest is temporarily being used as a full 64-bit
	quantity and not merely as the 64-bit encoding of a 32-bit quantity.
	This violates an assumption of the register allocator.
Fix: (from Chris)
	Off hand, it seems safe to have the code generator directly generate:

	 	zap	Rw, 240, Rtmp		; w & FFFFFFFF
	 	srl	Rtmp, 4, Rtmp		; (w & FFFFFFFF) >> 4
	 	addl	Rtmp, Rzero, Rdest	; sign_extend((w & FFFFFFFF) >> 4)

	where Rtmp could be either $at or the other temporary register reserved
	by TILT.
Test:
Owner: swasey
Status: closed
