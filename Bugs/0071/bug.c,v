head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	2002.03.06.10.55.52;	author swasey;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.04.13.44.21;	author swasey;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.27.14.57.10;	author swasey;	state Exp;
branches;
next	;


desc
@@


1.3
log
@*** empty log message ***
@
text
@#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "thread.h"
#include "tag.h"
#include "exn.h"
#include "create.h"

typedef ptr_t unit;
typedef int word;

extern void raise_exception_raw(Thread_t *th, ptr_t exn_arg);
unit raise_an_exception(ptr_t exn)
{
  Thread_t* th = getThread();
  volatile unsigned long* saveregs = th->saveregs;
  int i;
  fprintf(stderr,"\n\n--------raise_an_exception------\n");
  for (i=0; i<32; i++) {
    fprintf(stderr,"  saveregs[%d] is 0x%lx\n",i,saveregs[i]);
  }
  fprintf(stderr,"NumGC = %d\n", NumGC);

  /* The exception raised does not seem to matter.  We see the illegal
     instruction when we raise SysErr, Div, and Overflow.  */
/*
  runtime_error_msg("here's your exception");
  raise_exn(getDivExn());
  raise_exn(getOverflowExn());
*/
/* Avoids the error:  raise_exception_raw(th,exn); */
  raise_exn(exn);
  return empty_record;		/* not reached */
}
#if 0
unit my_openf(word oflag)
{
  int fd;
  (void)open("/dev/null",oflag,0);
  abort();
  return empty_record;
}
#endif
@


1.2
log
@*** empty log message ***
@
text
@d35 1
a35 1

d38 3
a40 1
  int fd = open("/dev/null",oflag,0);
d43 1
@


1.1
log
@Initial revision
@
text
@d12 1
d31 1
@
