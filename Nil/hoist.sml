(*$import Prelude TopLevel Ppnil List Sequence Listops Int ORD_KEY SplayMapFn  HOIST Nil NilUtil ListPair Stats Name Util *)

(* Known problems:
      Loses phase annotations on term-level constructor bindings.
      So reifier must be re-run afterwards.
 *)

structure Hoist :> HOIST = 

struct
    open Nil Name
	
    fun error s = Util.error "hoist.sml" s

    (************************************************************************
     Flags:
      debug                : Print debugging information during hoisting
     ************************************************************************)

    val debug = Stats.ff("HoistDebug")

    (************************************************************************
     Tracing effects:
     It seems too expensive --- and unnecessary --- to maintain a full
     typing context during the hoisting transformation.  However, it
     is important to know which term applications are total (e.g., 
     polymorphic instantiations) and can be hoisted.  Therefore,
     we maintain a mapping from term variables to "abstract" types.
     The abstraction preserves only the outermost arrow (total or
     partial) and record structure, in positive positions.     
     ************************************************************************)

    datatype hoist_effs =
	ARROW_EFF of effect * hoist_effs 
      | REC_EFF of (label * hoist_effs) list
      | UNKNOWN_EFF
	
    type econtext = hoist_effs VarMap.map
	
    val empty_econtext  = VarMap.empty : econtext
	
    fun lookupvar(vmap, v) = 
	(case VarMap.find(vmap, v) of
	     NONE => (print "missing variable ";
		      Ppnil.pp_var v; print "\n";
		      error "lookupvar: variable not found")
	   | SOME level => level)
	     
    (* ereclookup (effs, l)
         Returns the hoist_effs value associated with
	 label l in the given REC_EFF,
         and UNKNOWN_EFF if given UNKNOWN_EFF.
	 Because the abstraction on types is sound (though
	 not complete), we should never get ARROW_EFF here.
     *)
    fun ereclookup (effs, l) =
	(case effs of
	     REC_EFF lst => 
		 (case (Listops.assoc_eq (Name.eq_label,l,lst)) of
		      SOME effs => effs
		    | NONE => UNKNOWN_EFF)
		      
	   | UNKNOWN_EFF => UNKNOWN_EFF
	   | _ => error "ereclookup got ARROW_EFF")
	     
    (* con2eff (con)
         Does a best-effort abstraction of con into the
	 hoist_effs datatype.  Because we don't have a context,
	 this is sound but not complete.

         XXX  After hoisting, best-effort may not be enough, since what
              used to be a let_c is now simply a variable, with the 
              information-containing bindings not visible, having been
              hoisted to an outer level.

              If this turns out to be a problem, the environment could
              maintain bindings for type variables as well.
     *)
    local
	fun cbndsToSubst ([], accum) = accum
          | cbndsToSubst ((Con_cb args)::rest, accum) = 
	       cbndsToSubst (rest, args :: accum)
          | cbndsToSubst (_::rest, accum) = 
	       cbndsToSubst (rest, accum)

	fun con2eff' subst (AllArrow_c{effect,body_type,...}) =
	      ARROW_EFF (effect, con2eff' subst body_type)
	  | con2eff' subst (Prim_c(Record_c (lbls,_), types)) =
	      REC_EFF (ListPair.zip (lbls, map (con2eff' subst) types))
	  | con2eff' subst (Var_c v) =
	      (case (Listops.assoc_eq(Name.eq_var, v, subst)) of
		   NONE => UNKNOWN_EFF
		 | SOME c => con2eff' subst c)
	  | con2eff' subst (Let_c(Sequential, cbnds, c)) = 
	      con2eff' (cbndsToSubst(cbnds,subst)) c
	  | con2eff' _ _ = UNKNOWN_EFF
    in
	val con2eff = con2eff' []
    end

    (************************************************************************
     Levels:
     Each variable-binding site has a nesting depth, which is called
     its level.  The top-level is level 0, and the level increases
     with increasing level depth.

     Roughly speaking, the hoisting algorithm proceeds as follows:
     Each variable will be associated with a level (where the binding
     of that variable will be hoisted to).  For each bnd, we look at
     the right-hand side, and look at the levels of each of its free
     variables.  Since this bnd cannot be hoisted above the bindings
     of any of its free variables, we look at the maximum of the
     free-variable levels.  This is the level to which we will hoist
     the bnd.  (Non-valuable bnds, variables bound as function
     arguments, etc. obviously cannot be hoisted, and so are assigned
     the level of their binding site.)

     Unfortunately, this is overly simplistic and we must make two
     refinements.  First, for each list of bindings we remember *all*
     the levels of the free variables on the right-hand sides.  This
     makes it more efficient to determine the levels of the free
     variables of let-expressions (including those generated by the
     hoisting process itself).

     Secondly, we have to decide what to do about switches.  In
     general hoisting code out of switches will slow down the program,
     because we're now doing parts of multiple arms before picking the
     "correct" arm rather than just doing the work of the correct arm.
     (This is also potientially a problem with hoisting code out of
     functions.  However, since most functions get at least once and
     often multiple times, on average it is a win to hoist
     computations out of functions.)

     The simplest heuristic would be to never hoist code out of the
     arms of a switch, but this seems too restricted.  The
     second-simplest heuristic is to hoist only closed bindings out of
     switches (to the top level).  Since we're only hoisting valuable
     bindings (and the compiler isn't very smart) the cost of
     evaluating a valuable binding once at top level is pretty small,
     so this heuristic is very likely to be safe.  Unfortunately, it's
     pretty restrictive.

     Therefore we will implement the following heuristic: hoist any
     valuable binding out of a switch if it can also be hoisted
     outside the enclosing function.  If not, hoist it just to the
     beginning of the arm.

     Note that if we run hoist before uncurrying, this is guaranteed
     to lift all type computations in a polymorphic function outside
     of the term lambda, though they may be blocked by the enclosing
     type lambda.  For SML, this effectively lets us do all the
     required type computations "first" and then just refer to
     closures later [see optimal type lifting, etc.].
     ************************************************************************)

    type level     = int
    type levels    = int list  (* invariant: sorted in decreasing order *)
    val  toplevel = 0
    val  emptyLevels = []

    (************************************************************************
     The information maintained by the hoisting algorithm is divided into 
     an environment and a state.  The distinction is whether the information
     is threaded through the translation (state) or maintained in a 
     stack-like fashion (environment).

     The environment includes:
           currentlevel  = The level number of the immediately enclosing
                           binding site;

           econtext      = A mapping from term-level variables to
                           the hoist_effs abstraction of its type;

           levelmap      = A mapping from term- and type-level variables to
                           the level number of the binding site to which
                           their binding will be (initially) hoisted.

	   lastfnlevel   = level number of the binding site of the 
                           enclosing function.  

     The state includes:
           hoistmap      = Mapping from binding site numbers to 
                           term-level bindings that we want to hoist to here.
                           NB: Bindings are kept in reversed order!
                           Each level also contains a sorted list of
                           level numbers corresponding to the
                           free variables in these bindings.

           choistmap     = Mapping from binding site numbers to 
                           type-level bindings that we want to hoist to here.
                           NB: Bindings are kept in reversed order!
                           Each level also contains a sorted list of
                           level numbers corresponding to the
                           free variables in these bindings.
     ************************************************************************)

    local
	structure IntKey : ORD_KEY = struct
					 type ord_key = int
					 val compare = Int.compare
				     end
	structure IntMap = SplayMapFn(IntKey) 

	fun lookup (imap, i, default) = 
	    (case IntMap.find(imap, i) of
		 NONE => default
	       | SOME answer => answer)

        fun pp_levelmap levelmap =
	    let 
		fun printer (v, l) = (print "[";
				      Ppnil.pp_var v;
				      print "=>";
				      print (Int.toString l);
				      print "] ")
	    in
		VarMap.appi printer levelmap;
		print "\n"
	    end


        fun pp_hoistmap (hoistmap: (bnd list * levels * bool) IntMap.map) =
	    let
		val (top_bnds,_,_) = lookup (hoistmap, 0, ([],[], true))
	    in
		print "top bnds: ";
                print (Int.toString (List.length top_bnds));
		print "\n";
		Ppnil.pp_bnds top_bnds;
		print "\n"
	    end

        fun pp_choistmap (choistmap: (conbnd list * levels) IntMap.map) =
	    let
		val (top_cbnds,_) = lookup (choistmap, 0, ([],[]))
	    in
		print "top cbnds: ";
                print (Int.toString (List.length top_cbnds));
		print "\n";
		Ppnil.pp_conbnds top_cbnds;
		print "\n"
	    end


    in
	type hoistmap = (bnd list * levels * bool) IntMap.map
        type choistmap = (conbnd list * levels) IntMap.map
	datatype env = ENV of {currentlevel : level, 
			       econtext : econtext,
			       levelmap : level VarMap.map,
			       lastfnlevel : level}
	datatype state = STATE of {hoistmap : hoistmap, 
				   choistmap : choistmap}

	val empty_env = ENV{currentlevel = toplevel,
			    econtext = empty_econtext,
			    levelmap = VarMap.empty,
			    lastfnlevel = toplevel}

	val empty_state = STATE{hoistmap = IntMap.empty,
				choistmap = IntMap.empty}

	fun pp_env (ENV{levelmap,...}) = pp_levelmap levelmap

        fun pp_state (STATE{hoistmap,choistmap}) =
	    (pp_hoistmap hoistmap;
	     pp_choistmap choistmap)

	(* mergeLevels : levels * levels -> levels
	     Merges two sorted (in decreasing order) lists of integers
	 *)
	fun mergeLevels' ([] : levels, levels' : levels) : levels = levels'
          | mergeLevels' (levels, []) = levels
          | mergeLevels' (levels as level::rest, levels' as level'::rest') =
	    if (level > level') then
		level :: (mergeLevels' (rest, levels'))
	    else if (level = level') then
		level :: (mergeLevels' (rest, rest'))
	    else
		level' :: (mergeLevels' (levels, rest'))

        and mergeLevels (levels1, levels2) =
	    let
(*		val _ = (print "merging ";
			 app (print o Int.toString) levels1;
			 print " with ";
			 app (print o Int.toString) levels2)
*)
		val ans = mergeLevels' (levels1, levels2)
(*
		val _= (print " to get ";
			app (print o Int.toString) ans;
			print "\n")
*)
	    in
		ans
	    end

        (* mergeStates : state * state -> state *)
        fun mergeStates (STATE{hoistmap = hoistmap1,
	                       choistmap = choistmap1},
                         STATE{hoistmap = hoistmap2,
	                       choistmap = choistmap2}) =
	    let
		fun folder (level, (bnds,levels,valuable), accum_map) =
		    let val (newbnds, newlevels, newvaluable) = 
                          (case IntMap.find (accum_map, level)
			       of NONE => (bnds,levels,valuable)
                                | SOME (bnds',levels',valuable') => 
				   (bnds @ bnds',
				    mergeLevels (levels,levels'),
				    valuable andalso valuable'))
		    in
			IntMap.insert(accum_map, level, 
				      (newbnds, newlevels, newvaluable))
		    end

		fun cfolder (level, (bnds,levels), accum_map) =
		    let val (newbnds, newlevels) = 
                          (case IntMap.find (accum_map, level)
			       of NONE => (bnds,levels)
                                | SOME (bnds',levels') => 
				   (bnds @ bnds',
				    mergeLevels (levels,levels')))
		    in
			IntMap.insert(accum_map, level, (newbnds, newlevels))
		    end

		val hoistmap =
		    IntMap.foldli folder hoistmap1 hoistmap2
		val choistmap =
		    IntMap.foldli cfolder choistmap1 choistmap2
	    in
		STATE{hoistmap = hoistmap, choistmap = choistmap}
	    end

        (* currentLevel : env -> level *)
	fun currentLevel (ENV{currentlevel,...}) = currentlevel

        (* lookupLevel : var -> level 
              Tells what level the binding of this variable is
              being hoisted to *)
	fun lookupLevel (ENV{levelmap,...}, v) = lookupvar(levelmap, v)

        (* lookupEff : env * var -> hoist_effs *)
	fun lookupEff (ENV{econtext,...}, v) = 
                (lookupvar(econtext, v))
                handle e => (print "exception detected in lookupEff\n";
			     raise e)

        (* bindEff : env * var * hoist_effs -> env *)
	fun bindEff (ENV{econtext,currentlevel,levelmap,lastfnlevel}, 
		      v, effs) = 
	    let
		val econtext' = VarMap.insert(econtext, v, effs)
	    in
		ENV{econtext = econtext',
		    currentlevel = currentlevel, 
		    levelmap = levelmap,
		    lastfnlevel = lastfnlevel}
	    end

        fun bindsEff (env, [], []) = env
          | bindsEff (env, v::vs, eff::effs) =
	    bindsEff (bindEff(env, v, eff), vs, effs)
          | bindsEff _ = error "bindsEff: length mismatch"

        (* clearLevel : level * state -> state *)
	fun clearLevel (levnum, STATE{hoistmap,choistmap}) = 
	    let
		val hoistmap' = 
		    IntMap.insert(hoistmap, levnum, ([], emptyLevels, true))
		val choistmap' = 
		    IntMap.insert(choistmap, levnum, ([], emptyLevels))
	    in
		STATE{hoistmap = hoistmap', choistmap = choistmap'}
	    end
		
        (* bumpCurrentlevel : env * state -> env * state * level
              increments the current level counter, clears this level
              in the state, returns updated env and state and returns
              the new current level 
         *)
	fun bumpCurrentlevel (ENV{currentlevel,econtext,levelmap,lastfnlevel},
			      state) =
	    let 
		val newlevel = currentlevel + 1
		val env' = ENV{currentlevel = newlevel,
			       econtext = econtext,
			       levelmap = levelmap,
			       lastfnlevel = lastfnlevel}
		val state' = clearLevel (newlevel, state)
	    in
		(env', state', newlevel)
	    end

	fun enterFunction (ENV{currentlevel, econtext, levelmap, lastfnlevel})=
	    ENV{currentlevel = currentlevel,
		econtext = econtext,
		levelmap = levelmap,
		lastfnlevel = currentlevel}
		
		    
	fun lastFnLevel (ENV{lastfnlevel,...}) = lastfnlevel

        fun deepestLevel [] = toplevel 
          | deepestLevel (level::_) = level

        fun splitLevels [] = (toplevel, [])
          | splitLevels (level::rest) = (level, rest)

        (* bindLevel : env * var * level -> env
              Record that the binding of the var will be at the
              given level (for now)
         *)
	fun bindLevel(ENV{currentlevel, econtext, levelmap, lastfnlevel}, 
		       v, level) = 
	    ENV{currentlevel = currentlevel,
		econtext = econtext,
		levelmap = VarMap.insert(levelmap, v, level),
		lastfnlevel = lastfnlevel}

	fun bindsLevel(env, [], level) = env
          | bindsLevel(env, v::vs, level) = 
	    bindsLevel(bindLevel(env, v, level), vs, level)

	fun hoistCbnd(STATE{hoistmap,choistmap}, cbndlevels, cbnd) =
	    let
		val (hoistlevel, levels) = splitLevels cbndlevels
(*
		val _ = (print "Hoisting cbnd ";
			 Ppnil.pp_conbnd cbnd;
			 print "\nto level ";
			 print (Int.toString hoistlevel);
			 print "\n")
*)
		val (rev_cbnds, levels') = 
                    lookup (choistmap, hoistlevel, ([],[]))
		val levels'' = mergeLevels (levels, levels') 
		val choistmap' =
		    IntMap.insert(choistmap, hoistlevel, 
				  (cbnd :: rev_cbnds, levels''))
	    in
		STATE{hoistmap = hoistmap,
		      choistmap = choistmap'}
	    end

	fun hoistBnd(STATE{hoistmap,choistmap}, bndlevels, bnd, bnds_valuable)=
	    let
		val (hoistlevel, levels) = splitLevels bndlevels
(*
		val _ = (print "Hoisting ";
			 Ppnil.pp_bnd bnd;
			 print "\nto level ";
			 print (Int.toString hoistlevel);
			 print "\n")
*)
		val (rev_bnds, levels', bnds_valuable') = 
                    lookup (hoistmap, hoistlevel, ([],[], true))
		val levels = mergeLevels (levels, levels') 
		val bnds_valuble = bnds_valuable' andalso bnds_valuable
		val hoistmap' =
		    IntMap.insert(hoistmap, hoistlevel, 
				  (bnd :: rev_bnds, levels, bnds_valuable))
	    in
		STATE{hoistmap = hoistmap',
		      choistmap = choistmap}
	    end

        fun extractCbnds (STATE{choistmap,hoistmap}, levnum) = 
	    let
		val (cbnds, levels) = 
		    (case IntMap.find(choistmap, levnum) of
			 NONE => ([], emptyLevels)
		       | SOME (rev_choists, levels) => 
			     (rev rev_choists, levels))

                (* Sanity check: We're expecting a bunch of cbnds.  If
                   we find we have hoisted term bindings to this site
                   something went wrong --- especially since we don't
                   hoist anything out of typeof's. *)
		val _ =
		    (case IntMap.find(hoistmap, levnum) of
				NONE => ()
			      | SOME ([],_,_) => ()
			      | SOME (bnds,_,_) => 
				    (print "ERROR:  found term bindings:\n";
				     Ppnil.pp_bnds bnds;
				     print "\nat level ";
				     print (Int.toString levnum);
				     print "\nwith cbnds:\n";
				     Ppnil.pp_conbnds cbnds;
				     print "\n";
				     error "extractCbnds:found term bindings"))

		val choistmap' = 
		    IntMap.insert(choistmap, levnum, ([], emptyLevels))
		val state' = STATE{hoistmap = hoistmap,
				   choistmap = choistmap'}
	    in
		(cbnds, levels, state')
	    end

        fun extractBnds (STATE{hoistmap,choistmap}, level) = 
	    let
		val (cbnds, clevels) = 
		    (case IntMap.find(choistmap, level) of
			 NONE => ([], emptyLevels)
		       | SOME (rev_choists, clevels) => 
			     (rev rev_choists, clevels))
		val (bnds, levels, bnds_valuable) = 
		    (case IntMap.find(hoistmap, level) of
			 NONE => ([], emptyLevels, true)
		       | SOME (rev_hoists, levels, bnds_valuable) => 
			     (rev rev_hoists, levels, bnds_valuable))
		val choistmap' = 
		    IntMap.insert(choistmap, level, ([], emptyLevels))
		val hoistmap' = 
		    IntMap.insert(hoistmap, level, ([], emptyLevels, true))
		val state' = STATE{hoistmap = hoistmap',
				   choistmap = choistmap'}
		val bnds' = (map (fn cb => Con_b(Runtime, cb)) cbnds) @ bnds
		val levels' = mergeLevels (clevels, levels)
	    in
		(bnds', levels', state', bnds_valuable)
	    end

	(* limitLevels: level * levels -> levels
	     Delete all level numbers in the list >= given level 
             Assumes levels is sorted in decreasing order.
         *)
	fun limitLevels (levnum, []) = []
          | limitLevels (levnum, levels as lev::levs) = 
	    if (levnum <= lev) then
		limitLevels (levnum, levs)
	    else
		levels

	fun limitCon (limitlevel, con, env, state, levels) =
	    let
		val currentlevel = currentLevel env
		fun loop (levnum, cbnds, levels, state) =
		    if (levnum > currentlevel) then
			(cbnds, levels, state)
		    else
			let     
			    val (cbnds', levels', state') = 
				extractCbnds(state, levnum)
			    val levels'' = mergeLevels (levels, levels')
			in
			    loop(levnum + 1, cbnds @ cbnds', levels'', state')
			end
		    
		val (cbnds, levels', state') = 
		    loop (limitlevel, [], levels, state)
		val levels'' = limitLevels (limitlevel, levels')
		val con' = NilUtil.makeLetC cbnds con
	    in
		(con', state', levels'')
	    end

	fun limitExp (limitlevel : level, exp : exp, exp_valuable : bool, 
		      env : env, state : state, levels : level list)
	       : exp * state * level list * bool =
	    let

		val currentlevel = currentLevel env
(*
		val _ = (print "limitExp:  levels were ";
			 app (print o Int.toString) levels;
			 print "\ncurrentlevel = ";
			 print (Int.toString currentlevel);
			 print "\nlimitlevel = ";
			 print (Int.toString limitlevel);
			 print "\n")
*)
		fun loop (levnum, bnds, levels, state, bnds_valuable) =
		    if (levnum > currentlevel) then
			(bnds, bnds_valuable, levels, state)
		    else
			let     
			    val (bnds', levels', state', bnds_valuable') = 
				extractBnds(state, levnum)
			    val levels'' = mergeLevels (levels, levels')
			in
			    loop(levnum + 1, bnds @ bnds', levels'', state',
				 bnds_valuable' andalso bnds_valuable)
			end
		    
		val (bnds, bnds_valuable, levels', state) = 
		    loop (limitlevel, [], levels, state, true)

		val levels'' = limitLevels (limitlevel, levels')
(*
		val _ = (print "limitExp:  levels' = ";
			 app (print o Int.toString) levels'; 
			 print "\nlimitExp:  levels'' = ";
			 app (print o Int.toString) levels'';
			 print "\n")
*)
		val exp' = NilUtil.makeLetE Sequential bnds exp
		val exp_valuable = exp_valuable andalso bnds_valuable
	    in
		(exp', state, levels'', exp_valuable)
	    end

    end (* local *)

    (************************************************************************
     

     val rcon  : con      * env * state -> con      * state * levels
     val rcons : con list * env * state -> con list * state * levels

     val rcbnd : conbnd      * env * state -> env * state 
     val rcbnds: conbnd list * env * state -> env * state 

     val rexp  : exp      * env * state -> 
                   exp      * state * levels * hoist_effs * bool
     val rexps : exp list * env * state -> 
                   exp list * state * levels * hoist_effs list * bool

     ************************************************************************)

  fun rcon (args as (con,_,_)) =
      let
	  val _ = if (! debug) then
	              (print "rcon: "; Ppnil.pp_con con; print "\n")
		  else
		      ()
      in
	  rcon' args
      end
	  

  and rcon' (Prim_c (primop as Record_c (labels,SOME vars),cons), env, state) =
      let
	  val (env, state, varlevel) = bumpCurrentlevel (env, state)

	  fun loop ([], [], rev_accum, env, state, levels) =
	      (rev rev_accum, state, levels)
            | loop (v::vs, c::cs, rev_accum, env, state, levels) = 
	      let
		  val (c, state, new_levels) = 
		      rcon_limited varlevel (c, env, state)
		  val env = bindLevel(env, v, varlevel)
		  val env = bindEff(env, v, con2eff c)
		  val levels = mergeLevels(levels, new_levels)
	      in
		  loop(vs, cs, c::rev_accum, env, state, levels)
	      end
            | loop _ = error "rcon': var/type mismatch in dependent Record_c"

	  val (cons, state, levels) = 
	      loop (vars, cons, [], env, state, emptyLevels)
      in
	  (Prim_c(primop, cons), state, levels)
      end

	  
    | rcon' (Prim_c (primcon,cons), env, state) =
      let
	  val (cons, state, levels) = rcons (cons, env, state)
      in
	  (Prim_c(primcon, cons), state, levels)
      end

    | rcon' (Mu_c (isRecursive, vcseq), env, state) = 
      let
	  val (vars, cons) = Listops.unzip (Sequence.toList vcseq)

	  val (env, state, mulevel) = bumpCurrentlevel (env, state)
	  val env = bindsLevel (env, vars, mulevel)

	  val (cons, state, levels) = rcons_limited mulevel (cons, env, state)

	  val vcseq = Sequence.fromList (Listops.zip vars cons)
      in
	  (Mu_c (isRecursive, vcseq), state, levels)
      end

    | rcon' (con as AllArrow_c {openness, effect, isDependent, tFormals,
			       eFormals, fFormals, body_type}, 
	    env, state) =
      let
	  val (env, state, arglevel) = bumpCurrentlevel (env, state)
  
          val (tFormals, env, state, levels1) = 
	        rtFormals(tFormals, env, state, arglevel)
          val (eFormals, env, state, levels2) = 
	        reFormals_arrow(eFormals, env, state, arglevel)

          val (body_type, state, levels3) = 
                rcon_limited arglevel (body_type, env, state)

	  val levels = mergeLevels(mergeLevels(levels1, levels2), levels3)

      in
	  (AllArrow_c{openness=openness,
		      effect=effect,
		      isDependent = isDependent,
		      tFormals = tFormals,
		      eFormals = eFormals,
		      fFormals = fFormals,
		      body_type = body_type},
	   state, levels)
      end

    | rcon' (ExternArrow_c (cons, con), env, state) = 
      let
	  val (cons, state, levels1) = rcons(cons, env, state)
	  val (con,  state, levels2) = rcon (con,  env, state)
	  val levels = mergeLevels(levels1,levels2)
      in
	  (ExternArrow_c(cons, con), state, levels)
      end

    | rcon' (c as Var_c v, env, state) = 
      let
	  val level = lookupLevel (env, v)
      in
	  (c, state, [level])
      end
      
    | rcon' (Let_c(Sequential,cbnds,cbody), env, state) = 
      let
	  val (env, state, bndlevel) = bumpCurrentlevel (env, state)
	  val (env, state) = rcbnds(cbnds, env, state)
      in  
          rcon_limited bndlevel (cbody, env, state)
      end

    | rcon' (Let_c(Parallel,_,_),_,_) = error "rcon: Parallel Let_c found"

    | rcon' (Crecord_c lclist, env, state) = 
      let
	  val (labels, cons) = Listops.unzip lclist
	  val (cons, state, levels) = rcons(cons, env, state)
	  val lclist = Listops.zip labels cons
      in
	  (Crecord_c lclist, state, levels)
      end

    | rcon' (Proj_c (con,lab), env, state) = 
      let
	  val (con, state, levels) = rcon(con, env, state)
      in
	  (Proj_c(con,lab), state, levels)
      end

    | rcon' (Typeof_c e, env, state) = 
      let
	  (* We do not hoist any bindings outside of a typeof.
             In practice, typeof's generally refer to variables in
             dependent (term-level) record or function types, and
             there's no place to hoist these references to anyway.
             Further, typeof's don't affect space or time properties
             of generated code. *)
	  val (e, _, _, _, _) = 
	      rexp_limited toplevel (e, env, empty_state)
      in
	  (Typeof_c e, state, emptyLevels)
      end
  
    | rcon' (Closure_c(c1, c2), env, state) = 
      let
	  val (c1, state, levels1) = rcon (c1, env, state)
	  val (c2, state, levels2) = rcon (c2, env, state)
	  val levels = mergeLevels (levels1, levels2)
      in
	  (Closure_c(c1,c2), state, levels)
      end

    | rcon' (App_c(con,cons), env, state) = 
      let
	  val (con,  state, levels1) = rcon (con,  env, state)
	  val (cons, state, levels2) = rcons(cons, env, state)
	  val levels = mergeLevels (levels1, levels2)
      in
	  (App_c(con,cons), state, levels)
      end

    | rcon' (Typecase_c _,_, _) = 
      (error "rcon of Typecase_c unimplemented")

    | rcon' (Annotate_c (_,con), env, state) = 
      let
	  val (con, state, level) = rcon (con, env, state)
      in
	  (* The free variable information in an annotation
	   is no longer trustworthy, so we discard all
	   annotations *)
	  (con, state, level)
      end

  and rcons (cons, env, state) = 
      let 
	  fun loop ([], rev_accum, state, levels) = 
                 (rev rev_accum, state, levels)
            | loop (con::cons, rev_accum, state, levels) = 
	      let
		  val (con, state, new_levels) = rcon (con, env, state)
		  val levels = mergeLevels(levels, new_levels)
	      in
		  loop(cons, con::rev_accum, state, levels)
	      end
      in
	  loop (cons, [], state, [])
      end

  and rcons_limited levnum (cons, env, state) = 
      let 
	  fun loop ([], rev_accum, state, levels) = 
              (rev rev_accum, state, levels)
            | loop (con::cons, rev_accum, state, levels) = 
	      let
		  val (con, state, new_levels) =
                        rcon_limited levnum (con, env, state)
		  val levels = mergeLevels(levels, new_levels)
	      in
		  loop(cons, con::rev_accum, state, levels)
	      end
      in
	  loop (cons, [], state, [])
      end

  and rcon_limited levnum (con, env, state) = 
      let
	  val (con, state, levels') = rcon (con, env, state)
      in
	  limitCon (levnum, con, env, state, levels')
      end

  and rcbnd (Con_cb(v,con), env, state) = 
      let
	  val (con, state, levels) = rcon (con, env, state)
	  val env = bindLevel (env, v, deepestLevel levels)
	  val state = hoistCbnd (state, levels, Con_cb(v,con))
      in
	  (env, state)
      end

    | rcbnd (Open_cb(v,tFormals,body), env, state) = 
	let
	    val inner_env = enterFunction env
	    val (inner_env, state, arglevel) = 
		bumpCurrentlevel (inner_env, state)

	    val (tFormals, inner_env, state, levels1) = 
		rtFormals(tFormals, inner_env, state, arglevel)

	    val (body, state, levels2) = 
	        rcon_limited arglevel (body, inner_env, state)

	    val levels = mergeLevels(levels1, levels2)
	    val env = bindLevel (env, v, deepestLevel(levels))
	    val cbnd = Open_cb(v, tFormals, body)
	    val state = hoistCbnd (state, levels, cbnd)
	in
	    (env, state)
	end

    | rcbnd (Code_cb _, _, _) = error "rcbnd: found code_cb"

  and rcbnds ([], env, state) = (env, state)
    | rcbnds (cbnd::cbnds, env, state) = 
      let
	  val (env,state) = rcbnd(cbnd, env, state)
      in
	  rcbnds (cbnds, env, state)
      end

  and rexp (args as (exp, env, state)) =
      let
	  val _ = 
	      if (! debug) then
		  (print "rexp: "; Ppnil.pp_exp exp; print "\n"
		   ; print "  env = "; pp_env env
		   ; print " state = "; pp_state state)
	      else
		  ()
      in
	  rexp' args
      end

  and rexp' (exp as Var_e v, env : env, state : state) = 
      let
	  val level = lookupLevel (env, v)
	  val effs = lookupEff(env, v)
(*
	  val _ = (print "looking up variable";
		   Ppnil.pp_var v;
		   print "and got level";
		   print (Int.toString level);
		   print "\n")
*)
      in
	  (exp, state, [level], effs, true)
      end

    | rexp' (exp as Const_e c, env, state) = 
	 (exp, state, [], UNKNOWN_EFF, true)

    | rexp' (Let_e(Sequential, bnds, body), env, state) =
      let
	  val (env, state, bndlevel) = bumpCurrentlevel (env, state)
	  val (env, state, bnds_valuable) = rbnds(bnds, env, state)
	  val (exp, state, levels, eff, body_valuable) =
	      rexp_limited bndlevel (body, env, state)
	  val valuable = bnds_valuable andalso body_valuable
      in
	  (exp, state, levels, eff, valuable)
      end

    | rexp' (exp as Prim_e (prim,cons,exps), env, state) =
      let
	  val (cons, state, levels1) = rcons(cons, env, state)
	  val (exps, state, levels2, eff_list, args_valuable) = 
	         rexps(exps, env, state)
          
	  (* we don't try very hard to track effect types through primops. *)
	  val eff =
	      (case (prim, eff_list) of
		   (NilPrimOp (record lbls),  _) =>
		       REC_EFF(ListPair.zip (lbls, eff_list))
                 | (NilPrimOp (select lbl), [eff]) =>
		       ereclookup (eff, lbl)
		 | _ => UNKNOWN_EFF)

	  val levels = mergeLevels(levels1, levels2)
	  val valuable = (not (NilUtil.effect exp)) andalso args_valuable
      in
	  (Prim_e (prim, cons, exps), state, levels, eff, valuable)
      end

    | rexp' (Switch_e sw, env, state) = 
      let
	  val (sw, state, levels, effs, valuable) = 
	      rswitch (sw, env, state)
      in
	  (Switch_e sw, state, levels, effs, valuable)
      end

    | rexp' (App_e (openness, exp, cons, exps1, exps2), env, state) =
      let
	  val (exp, state, levels1, exp_effs, valuable1) = 
	      rexp(exp, env, state)
	  val (cons, state, levels2) = 
              rcons(cons, env, state)
	  val (exps1, state, levels3, _, valuable3) = 
	      rexps(exps1, env, state)
	  val (exps2, state, levels4, _, valuable4) = 
	      rexps(exps2, env, state)

	  val (valuable, effs) = 
	      (case exp_effs of
		   (ARROW_EFF (Total,rest)) => 
		       (valuable1 andalso valuable3 andalso valuable4, rest)
		 | (ARROW_EFF (Partial,rest)) => (false, rest)
		 | _ => (false, UNKNOWN_EFF))

	  val levels = mergeLevels(mergeLevels(levels1,levels2),
 				   mergeLevels(levels3,levels4))

      in
	  (App_e (openness, exp, cons, exps1, exps2),
	   state, levels, effs, valuable)
      end
  
    | rexp' (ExternApp_e (exp,exps), env, state) =
      let
	  val (exp, state, levels1, _, valuable1) = rexp(exp, env, state)
	  val (exps, state, levels2, _, valuable2) = rexps(exps, env, state)
	  val levels = mergeLevels(levels1,levels2)
	  val effs = UNKNOWN_EFF
	  val valuable = false
      in
	(ExternApp_e (exp,exps), state, levels, effs, valuable)
      end

    | rexp' (Raise_e(exp,con), env, state) = 
      let
	  val (exp, state, levels1, _, _) = rexp(exp, env, state)
	  val (con, state, levels2) = rcon(con, env, state)
	  val levels = mergeLevels(levels1,levels2)
	  val effs = UNKNOWN_EFF
	  val valuable = false
      in
	  (Raise_e(exp,con), state, levels, effs, valuable)
      end
  
    | rexp' (Handle_e {body,bound,handler,result_type}, env, state) =
      let
	  val (body, state, levels1, _, _)  =  rexp (body, env, state)
	  val (result_type, state, levels2) =  rcon (result_type, env, state)

	  val (inner_env, state, handlerlevel) = bumpCurrentlevel (env, state)
	  val inner_env = bindLevel(inner_env, bound, handlerlevel)
          val inner_env = bindEff(inner_env, bound, UNKNOWN_EFF)

	  val limitlevel = lastFnLevel env
	  val (handler, handler_leftover_state, levels3, _, _) = 
              rexp_limited limitlevel (handler, inner_env, empty_state)
          val state = mergeStates (state, handler_leftover_state)

	  val levels = mergeLevels(mergeLevels(levels1, levels2), levels3)
	  val eff = UNKNOWN_EFF
	  val valuable = false	
      in
	  (Handle_e {body = body, bound = bound,
		     handler = handler, result_type = result_type},
	   state, levels, eff, valuable)
      end

  and rexp_limited levnum (exp, env, state) = 
      let
	  val (exp, state, levels, eff, valuable) = rexp (exp, env, state)
	  val (exp, state, levels, valuable) = 
	      limitExp (levnum, exp, valuable, env, state, levels)
      in
	  (exp, state, levels, eff, valuable)
      end

  and rexps' (limitopt, exps, env, state) = 
      let
	  fun loop ([], rev_accum, state, levels, rev_eff_list, valuable) = 
	      (rev rev_accum, state, levels, rev rev_eff_list, valuable)
	    | loop (exp::exps,rev_accum,state,levels,rev_eff_list,valuable) = 
	      let
		  val (exp, state, new_levels, new_eff, new_valuable) = 
		      rexp(exp, env, state)
		  val (exp, state, new_levels, new_valuable) = 
		      (case limitopt of
			   NONE => (exp, state, new_levels, new_valuable)
			 | SOME limit => 
			       limitExp(limit, exp, new_valuable, 
					env, state, new_levels))
			       
	      in
		  loop(exps, exp::rev_accum, state, 
		       mergeLevels(levels, new_levels),
		       new_eff :: rev_eff_list, 
		       valuable andalso new_valuable)
	      end
      in
	  loop(exps, [], state, emptyLevels, [], true)
      end

  and rexps (exps, state, env) = rexps' (NONE, exps, state, env)

  and rexps_limited limit (exps, state, env) = 
      rexps' (SOME limit, exps, state, env)

  and rbnd (Con_b(p,cb), env, state) = 
      (* Here's where we lose the phase information *)
      let
	  val (env, state) = rcbnd(cb, env, state)
	  val valuable = true
      in
	  (env, state, valuable)
      end

    | rbnd (Exp_b(v,nt,e), env, state) = 
      let
	  val (e, state, levels, effs, valuable) = rexp(e, env, state)
	  val newbnd = Exp_b(v,nt,e)

          (* We can only hoist valuable bindings to higher levels.
             If it is not valuable, we "hoist" to the current level
             (i.e., don't move the binding).  This is accomplished
             by stipulating that the binding is dependent on a
             binding at the current level.
           *)
	  val levels = 
	      if valuable then 
		  levels
	      else
		  mergeLevels ([currentLevel env], levels)

	  val hoistlevel = deepestLevel levels

	  val env = bindLevel(env, v, hoistlevel)
	  val env = bindEff(env, v, effs)

	  val state = hoistBnd (state, levels, newbnd, valuable)
      in
	  (env, state, valuable)
      end

    | rbnd (Fixopen_b vfseq, env : env, state : state) = 
	let
	    val vfs = Sequence.toList vfseq
	    val (vars, functions) = Listops.unzip vfs

	    (* Inside the recursion we cannot treat these functions
               as total, even if their bodies are lambdas.  Otherwise
               we might hoist applications of these functions to the
               top of the function body, introducing an infinite loop. *)
	    val partial_effs = map (fn _ => UNKNOWN_EFF) functions
            val env = bindsEff(env, vars, partial_effs)

	    (* We temporarily assign the functions in this nest
               to a new level.  This prevents references to
               the function from being hoisted out of the function.
               Further, we need to be able to distinguish recursive
               references (which do not prevent these functions from
               being hoisted) from references to prior definitions
               in a sequence of bindings. We re-assign levels
               to the functions defined here after we know
	       where the recursive nest is going. *)
            val (inner_env, state, fixopenlevel) = 
		bumpCurrentlevel (env, state)
            val inner_env = enterFunction inner_env 
	    val inner_env = bindsLevel (inner_env, vars, fixopenlevel)

	    fun loop ([], rev_fns, rev_fn_effs, state, levels) = 
		(rev rev_fns, rev rev_fn_effs, state, levels)
	      | loop ((v,f)::rest, rev_fns, rev_fn_effs, state, levels) = 
		let
		    val (f, eff, state, new_levels) = 
			rfun (v, f, inner_env, state)
		    val levels = mergeLevels (levels, new_levels)
		in
		    loop (rest, (v,f)::rev_fns, eff :: rev_fn_effs, 
			  state, levels)
		end
	    
	    val (vfs, function_effs, state, levels) = 
		loop (vfs, [], [], state, emptyLevels)

	    val hoistlevel = deepestLevel levels

	    (* Fix effects *)
            val env = bindsEff(env, vars, function_effs)

	    val env = bindsLevel (env, vars, hoistlevel)
	    val newbnd = Fixopen_b(Sequence.fromList vfs)
	    val state = hoistBnd (state, levels, newbnd, true)

	    val valuable = true
	in
	    (env, state, valuable)
	end	

    | rbnd (Fixcode_b _, _, _) = error "rbnd: found fixcode"
    | rbnd (Fixclosure_b _, _, _) = error "rbnd: found fixclosure"

  and rbnds ([], env, state) = (env, state, true)
    | rbnds (Exp_b(v,nt,Let_e(Sequential,bnds,body))::rest, env, state) =
         (* A bit of on-the-fly flattening. Doesn't happen automatically
            for non-valuable bindings because they're never hoisted. *)
         rbnds (bnds @ [Exp_b(v,nt,body)] @ rest, env, state)
    | rbnds (bnd::bnds, env, state) = 
      let
(*	  val _ = (print "rbnd: "; Ppnil.pp_bnd bnd; print "\n") *)
	  val (env, state, bnd_valuable) = rbnd(bnd, env, state)
	  val (env, state, rest_valuable) = rbnds(bnds, env, state)
	  val valuable = rest_valuable andalso bnd_valuable
      in
	  (env, state, valuable)
      end

  and rswitch (Intsw_e{arg,size,arms,default,result_type}, env, state) =
      let
	  val (arg, state, levels1, _, _) = rexp(arg, env, state)
	      
	  val (ints, exps) = Listops.unzip arms
          val limitlevel = lastFnLevel env

	  val (exps, arms_leftover_state, levels2, _, _) = 
		  rexps_limited limitlevel (exps, env, empty_state)
	  val arms = ListPair.zip(ints, exps)

          val state = mergeStates(state, arms_leftover_state)

	  val (default, default_leftover_state, levels3, _, _) = 
		  rexpopt_limited limitlevel (default,env,empty_state)
          val state = mergeStates(state, default_leftover_state)

	  val (result_type, state, levels4) = rcon(result_type, env, state)

	  val levels = mergeLevels(mergeLevels(levels1, levels2),
                                   mergeLevels(levels3, levels4))

	  val effs = con2eff result_type
	  val valuable = false
      in
	  (Intsw_e {arg=arg, size=size, arms=arms, default=default,
		    result_type = result_type},
	   state, levels, effs, valuable)
      end

    | rswitch (Sumsw_e {arg,sumtype,bound,arms,default,result_type},
	       env, state) = 
      let

	  val (arg, state, levels1, _, _) = rexp(arg, env, state)

          val limitlevel = lastFnLevel env

	  val (inner_env, state, armlevel) = bumpCurrentlevel (env, state)
	  val inner_env = bindLevel(inner_env, bound, armlevel)
          val inner_env = bindEff(inner_env, bound, UNKNOWN_EFF)

	  val (tags, nts, exps) = Listops.unzip3 arms

	  val (exps, arms_leftover_state, levels2, _, _) = 
		  rexps_limited limitlevel (exps, inner_env, empty_state)
	  val arms = Listops.zip3 tags nts exps
          val state = mergeStates(state, arms_leftover_state)

	  val (default, default_leftover_state, levels3, _, _) = 
		  rexpopt_limited limitlevel (default, env, empty_state)
          val state = mergeStates(state, default_leftover_state)

	  val (result_type, state, levels4) = rcon(result_type, env, state)

	  val levels = mergeLevels(mergeLevels(levels1, levels2),
                                   mergeLevels(levels3, levels4))
	      
	  val effs = con2eff result_type
	  val valuable = false
      in
	  (Sumsw_e {arg = arg,
		    sumtype = sumtype,
		    bound = bound,
		    arms = arms,
		    default = default,
		    result_type = result_type},
	   state, levels, effs, valuable)
      end

    | rswitch (Exncase_e {arg,bound,arms,default,result_type},
	       env, state) = 
      let
	  val (arg, state, levels1, _, _) = rexp(arg, env, state)

	  val (tags, nts, exps) = Listops.unzip3 arms

          (* CS: Not all tags are variables.  It's not guaranteed
                 that hoisting from the tags is a good idea.  Maybe
                 they also should be required to be hoisted out
                 of the enclosing function? *)
	  val (tags, state, levels2, _, _) = rexps(tags, env, state)

	  val (inner_env, state, armlevel) = bumpCurrentlevel (env, state)
	  val inner_env = bindLevel(inner_env, bound, armlevel)
          val inner_env = bindEff(inner_env, bound, UNKNOWN_EFF)

	  val limitlevel = lastFnLevel inner_env
	  val (exps, arms_leftover_state, levels3, _, _) = 
		  rexps_limited limitlevel (exps, inner_env, empty_state)
          val state = mergeStates(state, arms_leftover_state)

	  val arms = Listops.zip3 tags nts exps

	  val (default, default_leftover_state, levels4, _, _) = 
		  rexpopt_limited limitlevel (default, env, empty_state)
          val state = mergeStates(state, default_leftover_state)

	  val (result_type, state, levels5) = rcon(result_type, env, state)

	  val levels = mergeLevels(mergeLevels(mergeLevels(levels1, levels2),
					      levels3),
 				   mergeLevels(levels4,levels5))
	      
	  val effs = con2eff result_type
	  val valuable = false
      in
	  (Exncase_e {arg         = arg,
		      bound       = bound,
		      arms        = arms,
		      default     = default,
		      result_type = result_type},
	   state, levels, effs, valuable)
    end

    | rswitch (Typecase_e _, _, _) = 
       (error "rswitch: Typecase_e not implemented yet")

  and rexpopt' (_, NONE, env, state) = (NONE, state, emptyLevels, 
					UNKNOWN_EFF, true)
    | rexpopt' (limitopt, SOME e, env, state) = 
      let 
	  val (e, state, levels, effs, valuable) = rexp(e, env, state)
	  val (e, state, levels, valuable) = 
	      (case limitopt of
		   NONE => (e, state, levels, true)
		 | SOME limit => limitExp(limit, e, valuable, 
					  env, state, levels))
      in 
	  (SOME e, state, levels, effs, valuable)
      end
 
  and rexpopt (expopt, env, state) = rexpopt' (NONE, expopt, env, state)

  and rexpopt_limited limit (expopt, env, state) = 
      rexpopt'(SOME limit, expopt, env, state)

  and rfun (fnvar, 
	    Function{effect,recursive,isDependent, tFormals, eFormals,
		     fFormals, body, body_type},
	    env, state) = 
      let

	  (* rfun is only called to process a part of a FixOpen_b.
	     Therefore, the current level has already been bumped. *)
	  val arglevel = currentLevel env

          val (tFormals, env, state, levels1) = 
                  rtFormals(tFormals, env, state, arglevel)

          val (eFormals, env, state, levels2) = 
                  reFormals(eFormals, env, state, arglevel)

	  val env = bindsLevel(env, fFormals, arglevel)

	  val (body, state, levels3, body_eff, body_valuable) = 
                  rexp_limited arglevel (body, env, state)

	  val (body_type, state, levels4) = 
                  rcon_limited arglevel (body_type, env, state)

	  val levels = mergeLevels(mergeLevels(levels1,levels2),
 				   mergeLevels(levels3,levels4))

	  (* The effect annotation on the function may have been
	     overly conservative, saying Partial where the function
             is really Total.  The effect is always sound, so if it
	     sead Total it's still going to be Total. (Hoisting ought
	     not change valuability).  However, our estimation of
	     valuability is also sound, so if it says the body is
	     valuable then this is also correct regardless of the
	     original annotation. *)
	  val effect = (case effect of
			    Total => Total
			  | Partial => if body_valuable then 
				          (if (!debug)
					       then (print "Making function ";
						     Ppnil.pp_var fnvar;
						     print " Total\n")
					   else ();
					   Total)
				       else Partial)
(*
	  val _ = (print "Function ";
		   Ppnil.pp_var fnvar;
		   print " claims to have body levels ";
		   app (print o Int.toString) levels)		   
*)		   
      in
	  (Function{effect = effect, recursive = recursive,
		    isDependent = isDependent, tFormals = tFormals,
		    eFormals = eFormals, fFormals = fFormals,
		    body = body, body_type = body_type},
	   ARROW_EFF(effect, body_eff),
	   state, levels)
      end

  and rtFormals (tFormals, env, state, arglevel) = 
      let
	  fun loop ([], rev_accum, env, state, levels) =
	      (rev rev_accum, env, state, levels)
            | loop ((v,k)::rest, rev_accum, env, state, levels) = 
	      let
		  val (k, state, new_levels) =
                         rkind_limited arglevel (k, env, state)
		  val env = bindLevel(env, v, arglevel)
		  val levels = mergeLevels(levels, new_levels)
	      in
		  loop(rest, (v,k)::rev_accum, env, state, levels)
	      end
      in
	  loop(tFormals, [], env, state, emptyLevels)
      end

  and reFormals (eFormals, env, state, arglevel) = 
      let
	  fun loop ([], rev_accum, env, state, levels) =
	      (rev rev_accum, env, state, levels)
            | loop ((v,nt,c_orig)::rest, rev_accum, env, state, levels) = 
	      let
		  val (c, state, new_levels) = 
                        rcon_limited arglevel (c_orig, env, state)
		  val env = bindLevel(env, v, arglevel)

		  (* The unhoisted type is likely to contain more
                     local information about partial/total arrows *)
		  val env = bindEff(env, v, con2eff c_orig)

		  val levels = mergeLevels(levels, new_levels)
	      in
		  loop(rest, (v,nt,c)::rev_accum, env, state, levels)
	      end
      in
	  loop(eFormals, [], env, state, emptyLevels)
      end

  and reFormals_arrow (eFormals, env, state, arglevel) = 
      let
	  fun loop ([], rev_accum, env, state, levels) =
	      (rev rev_accum, env, state, levels)
            | loop ((vopt,c_orig)::rest, rev_accum, env, state, levels) = 
	      let
		  val (c, state, new_levels) = 
                        rcon_limited arglevel (c_orig, env, state)
		  val env = (case vopt of
				 NONE => env
			       | SOME v => bindLevel
				            (bindEff(env, v, con2eff c_orig),
					     v, arglevel))
		  val levels = mergeLevels(levels, new_levels)
	      in
		  loop(rest, (vopt,c)::rev_accum, env, state, levels)
	      end
      in
	  loop(eFormals, [], env, state, emptyLevels)
      end


  and rkind_limited _ (Type_k, env : env, state : state) = 
         (Type_k, state, emptyLevels)
    | rkind_limited limitlevel (Single_k c, env, state) = 
      let
	  val (c, state, levels) = rcon_limited limitlevel (c, env, state)
      in
	  (Single_k c, state, levels)
      end
    | rkind_limited limitlevel (SingleType_k c, env, state) = 
      let
	  val (c, state, levels) = rcon_limited limitlevel (c, env, state)
      in
	  (SingleType_k c, state, levels)
      end
    | rkind_limited limitlevel (Arrow_k(openness, tFormals, kind),env,state) = 
      let
          (* Don't bump the level because there's no
             place to put bindings here *)
	  val (tFormals, env, state, levels1) = 
	         rtFormals(tFormals, env, state, limitlevel)

	  val (kind, state, levels2) = 
                 rkind_limited limitlevel (kind, env, state)

	  val levels = mergeLevels(levels1, levels2)
      in
	  (Arrow_k(openness, tFormals, kind), state, levels)
      end

    | rkind_limited limitlevel (Record_k lvk_seq, env, state) = 
      let
	  val (lvlist, kinds) = Listops.unzip (Sequence.toList lvk_seq)
	  val (labels, vars) = Listops.unzip lvlist
	  val tFormals = Listops.zip vars kinds

	  val (tFormals, _, state, levels) =
	      rtFormals(tFormals, env, state, limitlevel)

	  val kinds = map (#2) tFormals
	  val lvk_seq = Sequence.fromList (ListPair.zip (lvlist, kinds))
      in
	  (Record_k lvk_seq, state, levels)
      end

  fun optimize (MODULE {bnds, imports, exports}) = 
      let
	  (* mark imports as top-level variables;
             estimate totality of term-level imports *)
	  fun split ([], env) = env
	    | split (ImportValue(l,v,_,c)::rest, env) =
	      let
		  val env = bindLevel(env, v, toplevel)
		  val env = bindEff(env, v, con2eff c)
	      in
		  split(rest, env)
	      end
	    | split (ImportType(l,v,_)::rest, env) = 
	      let
		  val env = bindLevel(env, v, toplevel)
	      in
		  split(rest, env)
	      end

	  val initial_env = split (imports, empty_env)
	  val initial_state = empty_state

          val _ = print "Imports Processed\n"

	  val (_, final_state, _) = 
	      rbnds(bnds, initial_env, initial_state)
		    
	  val (bnds',_,_,_) = extractBnds(final_state, toplevel)
      in
	  MODULE {bnds=bnds',imports=imports,exports=exports}  
      end

end
