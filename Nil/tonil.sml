(*$import Prelude TopLevel Name Listops Util Sequence List Prim Tyvar Int Word32 Array TilWord64 TilWord32 Il Nil Ppil IlUtil IlContext IlStatic NilUtil NilError NilContext Ppnil NilSubst Normalize Stats LibBase TONIL Option NilPrimUtil NilDefs *)

(* We box all floats and translate floating point operations accordingly.
   Also note that all term-level (but not type-level) 
        record fields must be sorted by their labels. *)

structure Tonil :> TONIL =
struct

   (**********************)
   (* Flags and Counters *)
   (**********************)

   val typeof_count             = Stats.counter "PS_Typeofs"

   val xmod_count = ref 0   (* Used for printing debugging info *)
   val xsig_count = ref 0
   val xcon_count = ref 0
   val xexp_count = ref 0
   val xsdecs_count = ref 0
   val xsbnds_count = ref 0

   val diag       = Stats.tt("TonilDiag")
   val debug      = Stats.ff("TonilDebug")
   val full_debug = Stats.ff("TonilFullDebug") 

   (* killDeadImport  :  should the import list be GC'ed to include
                         only variables used by the code being split?

      do_preproject   :
      
      do_memoize      : 

      do_polyrec      :  should we transform mutually-recursive polymorphic
                         functions into polymorphic recursion?

      keep_hil_numbers:  when mapping variables to var_c and var_r,
                         should the resulting names mention the HIL
                         number of the original variable, or only the
                         name (string) part?  Off by default because
                         it makes variable names much more readable,
                         but can be turned on to help see the
                         correspondence between HIL and MIL code.  
   *)
   val killDeadImport           = Stats.tt("killDeadImport")
   val do_preproject            = Stats.tt("do_preproject")
   val do_memoize               = Stats.tt("do_memoize")
   val do_polyrec               = Stats.tt("do_polyrec")
   val keep_hil_numbers         = Stats.ff("keep_hil_numbers")

   (* The elaborator_specific_optimizations ref controls whether
      the phase-splitter should do some simple optimizations
      that rely upon knowing exactly how the elaborator
      generates code.
       (1) Transforms all structures with a single component
           named "it" to the value of that component,
           rather than to a single-element record
           with that component.  Also, does not
           create a binding of a _c variable when
           splitting such structures, since we know it
           will never be used; there are no type components,
           and such a structure will never be used as a
           source-level structure (e.g., passed to a functor).
    
           Correspondingly, ignores all module projections of 
           a component named "it".

       (2) Strips out structures whose label is recognized as a 
           datatype label (satisfying Name.is_dt).  Such structures
           are generated by the elaborator (their signatures
           are probably used in the context to determine whether
           identifiers are datatype constructors or not) but
           the code for the constructors is always inlined,
           so the resulting code never actually uses these
           "inner" datatype modules.

       (3) Transforms polymorphic recursive-functions into 
           polymorphic recursion, if the do_polyrec flag
           is also turned on.  (Also doesn't define a _c part
           for these functors, which is ok because of #4.)

       (4) Avoids generating a constructor application when
           phase-splitting a functor application that's really
           polymorphic instantiation.

       Unless the elaborator changes significantly, this
       flag should always be kept "true" (which is why
       it doesn't live in the Stats module).  It probably
       shouldn't be in the signature of this structure either.
    *)
   val elaborator_specific_optimizations = ref true


   (***************************)
   (* Opens and other imports *)
   (***************************)

   open Nil Listops


   structure N = Name
   structure NU = NilUtil
   structure NS = NilSubst
   structure VarSet = Name.VarSet

   val perr_c = NilError.perr_c
   val perr_e = NilError.perr_e
   val perr_k = NilError.perr_k
   val perr_c_k = NilError.perr_c_k
   val eq_label = N.eq_label


   (*******************)
   (* Error Reporting *)
   (*******************)

   fun error msg = Util.error "tonil.sml" msg
   fun msg str = if (!diag) then print str else ()


   (*****************************)
   (* Various utility functions *)
   (*****************************)

   (* Given n, collect the labels and bound variables of the next n
      structure bindings or signature declarations respectively,
      and then return these along with any leftover bindings/declarations
    *)

   fun getSbndNames (n : int) (sbnds : Il.sbnd list) : 
                       Il.sbnd list * N.label list * N.var list =
       let 
	   fun loop 0 (rest, labs, vars) = (rest, rev labs, rev vars)
	     | loop n (Il.SBND(lab,bnd)::rest, labs, vars) = 
	       let val var = (case bnd of
				  Il.BND_MOD (v,_,_) => v
				| Il.BND_EXP (v,_) => v
				| Il.BND_CON (v,_) => v)
	       in  loop (n-1) (rest, lab::labs, var::vars)
	       end
	     | loop _ _ = error "getSbndName: ran out of bnds"
       in   loop n (sbnds,[],[])
       end

   fun getSdecNames (n : int) (sdecs : Il.sdec list) =
       let 
	   fun loop 0 (rest, labs, vars) = (rest, rev labs, rev vars)
	     | loop n (Il.SDEC(lab,bnd)::rest, labs, vars) = 
	       let val var = (case bnd of
				  Il.DEC_MOD (v,_,_) => v
				| Il.DEC_EXP (v,_,_,_) => v
				| Il.DEC_CON (v,_,_,_) => v)
	       in  loop (n-1) (rest, lab::labs, var::vars)
	       end
	     | loop _ _ = error "getSdecName: ran out of bnds"
       in   loop n (sdecs,[],[])
       end

   fun makeInternalLabels n = Listops.map0count (fn n => N.fresh_internal_label "bnd") n

   (*This will work as long as you don't do any composing of substitutions*)
   (* XXX ? *)
   val addToConSubst = NilSubst.C.sim_add

   (* extractProjLabels.  Splits a module "mod.lbls" into
        the "mod" and a list of labels.
    *)
   fun extractProjLabels module =
       let
	   fun loop (Il.MOD_PROJECT(module, lbl), accum) =
	              loop (module, lbl :: accum)
             | loop (module, accum) = (module, accum)
       in
	   loop (module, nil)
       end

   (* derefOneshot, derefTyvar, derefOvar.
        Partial functions to extract the values from "oneshot"-like
        objects.
    *)
   fun derefOneshot oneshot = 
       (case (Util.oneshot_deref oneshot) of
	     NONE   => error "(derefOneshot)  oneshot unset"
	  |  SOME x => x)

   fun derefTyvar tyvar =
       (case (Tyvar.tyvar_deref tyvar) of
	    NONE => error "(derefTyvar)  tyvar unset"
          | SOME x => x)

   fun derefOvar ovar = derefTyvar (Tyvar.ocon_deref ovar)


   (**********************************)
   (* The Variable-Splitting Mapping *)
   (**********************************)

   (* For the phase-splitting, we need a way of turning each module
      variable var into a new constructor variable var_c and a new
      term variable var_r.  We could play tricks like multiplying
      each HIL variable number by 3 and then adding 1 or 2  
      to denote _c and _r, but this is unpleasant.  Thus, we instead
      maintain a mapping from var to the pair (var_c, var_r),
      which is simply a pair of fresh variables.
   *)

   type vmap = (N.var * N.var) N.VarMap.map


   val empty_vmap : vmap = N.VarMap.empty

   (* Note that many of these functions are redefined below to take a
      full phase-splitting context as the first argument, rather than
      just a vmap *)

   fun lookupVmap (var : N.var, vmap : vmap) : (N.var * N.var) option =
     N.VarMap.find (vmap, var)
     
   (* Determines the corresponding _c and _r variables for a
      new bound module variable.
    *)
   fun splitNewVar (var : N.var, vmap : vmap) : N.var * N.var * vmap = 
     let
       (* Sometimes the elaborator generates shadowing for module
          variables --- or (possibly?) the phase splitter may flatten
          some bindings resulting in previously-disjoint scopes
          overlapping, again resulting in shadowing.  In any case, we
          generate fresh _c and _r variables corresponding to the
          inner (shadowing) variable.  (We can't re-use the previous
          _c and _r variables ; see the comments for the renaming map
          below.)
       *)

       (*
	  The only reason to generate warnings about this is if we expect
	  the elaborator to never generate shadowed module variables, in
	  which case we can detect here that this invariant fails.
       val _ = (case (lookupVmap (var,vmap) of
		  NONE => ()
		| SOME _ => (print "Warning: splitNewVar called \
		                    \on already existing variable ";
			     Ppnil.pp_var var; print "\n"))
       *)

       val var_name = 
	 if (!keep_hil_numbers) then
	   N.var2string var
	 else
	   N.var2name var
       val var_c = N.fresh_named_var (var_name ^ "_c")
       val var_r = N.fresh_named_var (var_name ^ "_r")
     in
       (var_c, var_r, N.VarMap.insert (vmap, var, (var_c, var_r)))
     end
       
   (* Determines the corresponding _c and _r variables for a
      use of a module variable that should already have been bound.

      XXX  Why is this returning the vmap?  Consistency with splitNewVar?
    *)
   fun splitVar (var : N.var, vmap : vmap) : N.var * N.var * vmap = 
     (case (lookupVmap (var,vmap)) of
	NONE => error ("splitVar called on non-existent variable " ^ 
		       (N.var2string var))
      | SOME (var_c, var_r) => (var_c, var_r, vmap))
	
   (* Prints a vmap.  Used only for tracing/debugging *)
   fun printVmap (vmap : vmap) : unit = 
     N.VarMap.appi (fn (k,(v1,v2)) => (Ppnil.pp_var k;
					  print "=(";
					  Ppnil.pp_var v1;
					  print ",";
					  Ppnil.pp_var v2;
					  print ") ")) vmap

   (*********************************)
   (* The Variable-Renaming Mapping *)
   (*********************************)

   (* Every variable other than module variables are renamed.
      This ensures that every bound variable in the resulting program
      is distinct --- not currently guaranteed by the elaborator ---
      and, as a consequence, that there is not shadowing of 
      constructor variables (which makes the Nil typechecker very
      unhappy, since this doesn't go well with dependent kinds.)
   *)

   type rmap = N.var N.VarMap.map

   fun do_rename_var (v : N.var) : N.var =
       let
	   val var_name = if (!keep_hil_numbers) then
	              N.var2string v
		   else
		      N.var2name v
	   val v' = N.fresh_named_var var_name
       in
	   v'
       end

   fun insert_rename_var (v : N.var, rmap : rmap) = 
       let
	   val v' = do_rename_var v
       in
	   (v', N.VarMap.insert (rmap, v, v'))
       end

   fun insert_rename_vars (vs : N.var list, rmap : rmap) = 
       Listops.foldl_acc insert_rename_var rmap vs

   fun insert_given_vars (oldvars : N.var list, 
			  newvars : N.var list,
			  rmap : rmap) = 
     (case (oldvars,newvars) of
	([],[]) => rmap
      | ((v::vs),(v'::vs')) =>
	  insert_given_vars (vs, vs', N.VarMap.insert(rmap, v, v'))
      | _ => error "insert_given_vars passed lists of unequal length")

   fun rename_var (v, rmap) = 
       (case N.VarMap.find(rmap, v) of 
	    SOME v' => v'
	  | NONE => (print "Couldn't find IL variable ";
		     Ppnil.pp_var v;
		     print " in rmap\n";
		     error "can't rename_var"))
   fun rename_vars(vs, rmap) = map (fn v => rename_var(v,rmap)) vs



   (***************************)
   (* Phase-Splitting Context *)
   (***************************)

   local
     (* The splitting context contains all the information maintained
        as the phase-splitting process goes along.  This includes
          HILctx : The IL context, containing the types of the IL 
                   bound variables visible at this point in the
                   translation's input.

          NILctx : The Nil context, containing the kinds of the NIL
                   bound *type* variables visible at this point in the
                   translation's output.  This is used to return and
                   report the kinds of the type exports, as well as
                   other minor things like finding the bool type and
                   head-normalizing/unrolling mu types.

                   Bound term variables are not put into the context,
                   because they're never needed.

          sigmap : 

          used   : The set of all (NIL) variables used in the generated
                   NIL code; this is used to figure out which (translations
                   of) imports must be kept and which can be thrown away.

                   The used set is kept as a ref, because it's really
                   more like a state that needs to be threaded through
                   the entire program.  Unlike other compiler phases
                   such as hoisting, we don't bother to maintain a
                   separate phase-splitting context and phase-splitting 
                   state.

          vmap   : The module-variable splitting map, as described above

          rmap   : The renaming map, as described above

          alias  : A mapping from variables to paths; remembers for each
                   IL variable bound to a path what that path was.  Such
                   variables are expanded into their paths before lookup
                   in the memoized_mpath table.

          memoized_mpath : A mapping from (nontrivial) module paths to
                           a term/type pair.  Once the path has been
                           phase-split, we remember the results and
                           any later request to phase-split the same
                           path can just re-use the previous results.

          polyfuns : The set of _r variables corresponding to IL
                     variables bound to functors that are really
                     the translation of SML polymorphic functions.
                     (Applications of such functors can omit the
                     application of the _c parts, so we want to
                     detect such cases.)
     *)
     datatype splitting_context = 
       CONTEXT of {NILctx : NilContext.context,
		   HILctx : Il.context,
		   sigmap : Il.signat N.VarMap.map,
		   used   : N.VarSet.set ref,
		   vmap   : (var * var) N.VarMap.map,
		   rmap   : var N.VarMap.map,
		   alias  : (var * label list) N.VarMap.map,
		   memoized_mpath : (con * exp (* * kind*)) N.PathMap.map,
                   polyfuns : N.VarSet.set}
       
   in (* local *)

     type splitting_context = splitting_context

     fun make_initial_splitting_context HILctx = 
       CONTEXT{NILctx = NilContext.empty(),
	       HILctx = HILctx,
	       sigmap = N.VarMap.empty,
	       used = ref N.VarSet.empty,
	       vmap = N.VarMap.empty,
	       rmap = N.VarMap.empty,
	       alias = N.VarMap.empty,
	       memoized_mpath = N.PathMap.empty,
	       polyfuns = N.VarSet.empty}
       
     fun print_splitting_context (CONTEXT{NILctx,vmap,rmap,...}) =
       (N.VarMap.appi 
	(fn (v,(vc,vr)) => (Ppnil.pp_var v; print "  -->  "; 
			    Ppnil.pp_var vc; print ", ";
			    Ppnil.pp_var vr; print "\n")) vmap;
	
	print "\n";
	N.VarMap.appi
	(fn (v,v') => (Ppnil.pp_var v; print "  -->  "; 
		       Ppnil.pp_var v'; print "\n")) rmap;
	print "\n";
	NilContext.print_context NILctx;
	print "\n")
       
     (* Getters for Splitting Context *)
     (*********************************)

     fun get_nilctxt (CONTEXT{NILctx,...}) = NILctx

     fun get_hilctxt (CONTEXT{HILctx,...}) = HILctx

     fun get_used (CONTEXT{used,...}) = !used
       
     fun find_sig(CONTEXT{sigmap,...},v) = N.VarMap.find(sigmap,v)

     fun var_is_polyfun (CONTEXT{polyfuns,...}, v) = 
       N.VarSet.member(polyfuns,v)

     fun lookup_module_alias(CONTEXT{alias,memoized_mpath,...},m) = 
       case (extractProjLabels m) of
	 (Il.MOD_VAR v,labs) => 
	   let fun follow_alias(v,labs) = 
	     (case (N.VarMap.find(alias,v)) of
		NONE => (v,labs)
	      | SOME (v',labs') => follow_alias(v',labs' @ labs))
	       val p = follow_alias(v,labs)
	   in  N.PathMap.find(memoized_mpath,p)
	   end
       | _ =>  error "lookup_module_alias given non-path module"
		

     (* Setters for Splitting Context *)
     (*********************************)

     fun mark_var_used(CONTEXT{used,...},v) = 
       if (N.VarSet.member(!used,v))
	 then ()
       else used := N.VarSet.add(!used,v)

       (* It's amazing how handy ocaml-style functional record update
          would be in the following functions! *)

     fun replace_NILctx(CONTEXT{NILctx,HILctx,sigmap,vmap,rmap, 
				used,memoized_mpath,alias,polyfuns},
			NILctx') = 
       let 
       in  CONTEXT{NILctx=NILctx', HILctx=HILctx,
		   sigmap=sigmap, vmap=vmap, rmap=rmap, used = used, 
		   memoized_mpath=memoized_mpath, alias=alias,
		   polyfuns=polyfuns}
       end

     fun update_NILctx_insert_kind(CONTEXT{NILctx,HILctx,sigmap,vmap,rmap, 
					   used,memoized_mpath,alias,polyfuns},
				   v, k) = 
       let 
	 val NILctx' = NilContext.insert_kind(NILctx,v,k)
       in  CONTEXT{NILctx=NILctx', HILctx=HILctx,
		   sigmap=sigmap, vmap=vmap, rmap=rmap, used = used, 
		   memoized_mpath=memoized_mpath, alias=alias,
		   polyfuns=polyfuns}
       end

     fun update_NILctx_insert_kind_equation(CONTEXT{NILctx,HILctx,sigmap,vmap,
						    rmap, used, memoized_mpath,
						    alias, polyfuns},
					    v, c) = 
       let val k = Single_k c
	 val NILctx' = NilContext.insert_kind(NILctx,v,k)
       in  CONTEXT{NILctx=NILctx', HILctx=HILctx,
		   sigmap=sigmap, vmap=vmap, rmap=rmap, used = used, 
		   memoized_mpath=memoized_mpath, alias=alias,
		   polyfuns=polyfuns}
       end

     fun update_NILctx_insert_kind_list(ctxt,vklist) = 
       foldl (fn ((v,k),ctxt) => update_NILctx_insert_kind (ctxt,v,k)) 
             ctxt vklist

     fun update_NILctx_insert_label(CONTEXT{NILctx,HILctx,sigmap,vmap,rmap,
					    used,memoized_mpath,alias,
					    polyfuns},
				    l, v) =
       let val NILctx' = NilContext.insert_label(NILctx,l,v)
       in  CONTEXT{NILctx=NILctx', HILctx=HILctx,
		   sigmap=sigmap, vmap=vmap, rmap=rmap, used = used, 
		   memoized_mpath=memoized_mpath, alias=alias,
		   polyfuns=polyfuns}
       end
     
     fun add_modvar_alias(CONTEXT{NILctx,HILctx,sigmap,vmap,rmap,used,
				 memoized_mpath,alias,polyfuns},var,path) =
       let val alias' = N.VarMap.insert(alias,var,path)
       in  CONTEXT{NILctx=NILctx, HILctx=HILctx, sigmap=sigmap, vmap=vmap, rmap=rmap,  
		   used=used,alias=alias',  memoized_mpath=memoized_mpath,
		   polyfuns=polyfuns}
       end
     
     fun add_module_alias(CONTEXT{NILctx,HILctx,sigmap,vmap,rmap,used,alias,
				  memoized_mpath,polyfuns},
			  m, name_c, name_r (*,k1*) ) = 
       (case (extractProjLabels m) of
	  (Il.MOD_VAR v, labs) => 
	    let val p = (v,labs)
	      val memoized_mpath' = 
		N.PathMap.insert(memoized_mpath, p, (name_c,name_r (*,k1*) ))
	    in  CONTEXT{NILctx=NILctx, HILctx=HILctx,
			sigmap=sigmap, vmap=vmap, rmap=rmap,
			used=used,alias=alias,  
			memoized_mpath=memoized_mpath',
			polyfuns = polyfuns}
	    end
	| _ => error "add_module_alias given non-path module")

       (* The following have to be "val" rather than "fun" because we're
          using the same name for the wrapped functions as for the
          originals *)

     val insert_rename_var = fn (v, CONTEXT{NILctx,HILctx,sigmap,used,vmap,
					    rmap,alias,memoized_mpath,
					    polyfuns}) =>
       let
	 val (v',rmap') = insert_rename_var(v,rmap)
       in
	 (v', CONTEXT{NILctx=NILctx, HILctx=HILctx,
		      sigmap=sigmap,
		      used=used, vmap=vmap, rmap=rmap',
		      memoized_mpath=memoized_mpath,
		      alias=alias,polyfuns=polyfuns})
       end
     
     val insert_rename_vars = 
       fn (vs, CONTEXT{NILctx,HILctx,sigmap,
		       used,vmap,rmap,alias,memoized_mpath,polyfuns}) =>
       let
	 val (vs',rmap') = insert_rename_vars(vs,rmap)
       in
	 (vs', CONTEXT{NILctx=NILctx, HILctx=HILctx,
		       sigmap=sigmap,
		       used=used, vmap=vmap, rmap=rmap',
		       memoized_mpath=memoized_mpath,
		       alias=alias,polyfuns=polyfuns})
       end
     
     val insert_given_vars =
       fn (vs, vs', CONTEXT{NILctx,HILctx,sigmap,
			    used,vmap,rmap,alias,memoized_mpath,polyfuns}) =>
       let
	 val rmap' = insert_given_vars(vs,vs',rmap)
       in
	 CONTEXT{NILctx=NILctx, HILctx=HILctx, sigmap=sigmap,
		 used=used, vmap=vmap, rmap=rmap',
		 memoized_mpath=memoized_mpath,alias=alias,polyfuns=polyfuns}
       end


     fun update_insert_sig (CONTEXT{NILctx,HILctx,sigmap,used,vmap,rmap,
				     alias,memoized_mpath,polyfuns}, 
			     v, hilsig) = 
       CONTEXT{NILctx=NILctx, HILctx=HILctx,
	       sigmap=N.VarMap.insert(sigmap,v,hilsig),
	       used=used, vmap=vmap, rmap=rmap,
	       memoized_mpath=memoized_mpath,alias=alias,polyfuns=polyfuns}
       
     fun update_polyfuns (CONTEXT{NILctx,HILctx,sigmap,used,vmap,rmap,
				  alias,memoized_mpath,polyfuns}, 
			  v) = 
       CONTEXT{NILctx=NILctx, HILctx=HILctx, sigmap=sigmap,
	       used=used, vmap=vmap, rmap=rmap,
	       memoized_mpath=memoized_mpath,alias=alias,
	       polyfuns=N.VarSet.add(polyfuns,v)}
       
     fun update_polyfuns_list(CONTEXT{NILctx,HILctx,sigmap,used,rmap,vmap,
				      alias,memoized_mpath,polyfuns}, 
			      vs) = 
       CONTEXT{NILctx=NILctx, HILctx=HILctx, sigmap=sigmap,
	       used=used, vmap=vmap, rmap=rmap,
	       memoized_mpath=memoized_mpath,alias=alias,
	       polyfuns=N.VarSet.addList(polyfuns,vs)}

       
     (* Wrappers for other functions, so that they can be passed a
        full splitting context rather than just a NilContext.context *)
     (****************************************************************)


     fun NilContext_print(CONTEXT{NILctx,...}) = 
       NilContext.print_context NILctx

     fun NilContext_kind_of(CONTEXT{NILctx,...},c) = 
       NilContext.kind_of(NILctx, c)

       (* The following have to be "val" rather than "fun" because we're
          using the same name for the wrapped functions as for the
          originals *)

     val lookupVmap = fn (v,CONTEXT{vmap,...}) => lookupVmap (v,vmap)

     val splitVar = fn (var, CONTEXT{NILctx,HILctx,sigmap,used,vmap,rmap,
				     alias,memoized_mpath,polyfuns}) =>
                  let val (var_c,var_r,vmap') = splitVar (var, vmap)
		  in  ((var_c,var_r),
		       CONTEXT{NILctx=NILctx, HILctx=HILctx, sigmap=sigmap,
			       used=used, vmap=vmap', rmap=rmap,
			       memoized_mpath=memoized_mpath,
			       alias=alias, polyfuns=polyfuns})
		  end

     val splitNewVar = fn (var, CONTEXT{NILctx,HILctx,sigmap,used,vmap,rmap,
					alias,memoized_mpath,polyfuns}) =>
       let val (var_c,var_r,vmap') = splitNewVar (var, vmap)
       in  ((var_c,var_r),
	    CONTEXT{NILctx=NILctx, HILctx=HILctx, sigmap=sigmap, 
		    used=used, vmap=vmap', rmap=rmap,
		    memoized_mpath=memoized_mpath,
		    alias=alias,polyfuns=polyfuns})
       end

     
     val rename_var = fn (v, CONTEXT{rmap,...}) => rename_var(v,rmap)

     val rename_vars = fn (vs, CONTEXT{rmap,...}) => rename_vars(vs, rmap)

   end (* local defining splitting context *)



   (***************)
   (* Memoization *)
   (***************)

   (* The phase-splitter memoizes the translations of those
      IL constructors that are module projections.  

      There used to be code for memoizing the translations of module
      terms as well, but as of August 2002 it wasn't being used and so
      was removed.  
    *)

   local
       (* Memopad for translation of constructor paths
	  Indexed first by the module's variable, and then by the
          full projection path.
 
          The double indirection is probably so that one can quickly 
          clear any past information about all paths starting with
          a particular variable, when this variable is rebound.
        *)
       val con_memo = ref (N.VarMap.empty : con N.PathMap.map N.VarMap.map)
   in
       fun reset_memo() = (con_memo := N.VarMap.empty)

       (* Currently, every time we come across a binding of an IL module var
          we must clear the memo pad of all paths beginning with this
          variable.  This is a global table, so if we find a variable
          in a signature, say, then paths involving this variable
          remain in the memo pad even after we're done with the signature.
          This could get confusing if we come across the same variable 
          being used in a disjoint scope, such as the corresponding structure.
          (Especially since the phase-splitter wants to rename the variable
          differently in the separate occurrences.)
        *)
       fun clear_memo v = (con_memo := (#1(N.VarMap.remove(!con_memo,v))
					handle LibBase.NotFound => !con_memo))

       fun lookup_con_memo (path as (v,lbls)) thunk =
	 (case N.VarMap.find(!con_memo,v) of
	    NONE => (* Module variable hasn't been seen before.  
                       Insert it with an empty pathmap and recurse (taking
                       the SOME case instead, which will eventually add
		       the current constructor path to this new pathmap)
		     *)
	            (con_memo := N.VarMap.insert(!con_memo,v,N.PathMap.empty);
		     lookup_con_memo path thunk)
	  | SOME pathmap =>
	      (case N.PathMap.find(pathmap,path) of
		 SOME result => (* Found the answer.  We could have recomputed
				   it by calling thunk(), but this is now
				   avoided
				 *)
		                result
	       | NONE => (* We haven't seen this path before, so we have
			    to do the actual translation, which is 
			    performed by the thunk.
			  *)
			 let val result = thunk()
			 in  
			   con_memo := 
			      N.VarMap.insert(!con_memo, v,
					      N.PathMap.insert(pathmap, path, 
							       result));
			   result
			 end))
   end (*local *)


   (**************************)
   (* IL-to-NIL translations *)
   (**************************)

   (* One last helper function (which must be defined after the wrapped
      splitNewVar function).  

      Given optional desired variables names and a splitting context,
      return either that name or else completely fresh ones 
    *)
   fun chooseName (NONE, ctxt) = let val v = N.fresh_var()
				     val ((vc,vr),ctxt) = splitNewVar (v,ctxt)
				 in  (v,vc,vr,ctxt)
				 end
     | chooseName (SOME (var,var_c,var_r), ctxt) = (var, var_c, var_r, ctxt)


 
   (* xeffect.  
         Translates the total/partial distinction from HIL to MIL.
    *)
   fun xeffect (Il.TOTAL) = Total
     | xeffect (Il.PARTIAL) = Partial

   (* xilprim.  Translates the so-called "IL primitives" (primitives
       which are only segregated in the IL for typing reasons) into
       the corresponding common primitives, which have the same
       run-time behavior at the level of bits.
    *)
   fun xilprim (Prim.eq_uint intsize)     = Prim.eq_int intsize
     | xilprim (Prim.neq_uint intsize)    = Prim.neq_int intsize
     | xilprim (Prim.not_uint intsize)    = Prim.not_int intsize
     | xilprim (Prim.and_uint intsize)    = Prim.and_int intsize
     | xilprim (Prim.or_uint intsize)     = Prim.or_int intsize
     | xilprim (Prim.xor_uint intsize)     = Prim.xor_int intsize
     | xilprim (Prim.lshift_uint intsize) = Prim.lshift_int intsize
     | xilprim _ = error "other ilprims should not get here"


   (* xmod.  Translation of an IL module.
             Arguments are a splitting context, the module to be
             translated, an optionally a specification of names
             to which the two parts of the module must be bound.
	     If so, these names must be "fresh" (not in the context).
      
      Suppose 
         xmod in_context (il_mod, required_names)
      returns 
         {name_c, name_r, cbnd_cat, ebnd_cat, context} =

      Let cbnds = flatten_catlist cbnd_cat
      and ebnds = flatten_catlist ebnd_cat

      Then

        (1) the compile-time part of mod is LET_C cbnds IN name_c END
        (2) the run-time part of mod is LET_E cbnds, ebnds IN name_r END
        (3) ctx |- il_signat == il_signat' : Sig
	(4) The domains of cbnds and ebnds are disjoint from the
            domain of in_context
        (5) get_nilctxt(context) = get_nilctxt(in_context) ++
	    the (singleton) kinds of the variables bound in cbnds

      If required_names = SOME(var, var_r, var_c) then additionally we have

        (4) name_c = Var_c var_c
        (5) name_r = Var_e var_r
    *)

   type xmod_result = {cbnd_cat : conbnd catlist,
		       ebnd_cat : bnd catlist,
		       name_c : con,
		       name_r : exp,
		       (* knd_c : kind,*)
		       context : splitting_context}

   fun xmod (context : splitting_context)
            (args as (il_mod : Il.mod, 
		      required_names : (N.var * N.var * N.var) option)) 
	    : xmod_result =
       let
	   val this_call = ! xmod_count  (* remember so that we can
                                            display the same number in
                                            the tracing message on return *)
	   val _ = 
	       if (!debug) then
		   (xmod_count := this_call + 1;
		    print "\nCall ";
		    print (Int.toString this_call);
		    print " to xmod\n";
		    if (!full_debug) then Ppil.pp_mod il_mod else ();
		    print"\n")
	       else ()

           (* Look for the case of a nontrivial IL path (i.e., a
              structure variable with at least one projection).  If it
              already has been translated and its two parts given
              names, we just reuse these names. If the required name
              is specified, we'll define the two new variables with
              required names to be equal to the two variables bound
              previously (in which case the context must be extended).

              If the module is not a nontrivial path, then we pass
              everything to the main worker function xmod'.  
           *)

	   fun check_proj (m : Il.mod) : xmod_result =
	     (case (extractProjLabels m) of
		(Il.MOD_VAR v, _::_) => 
		 (* Nontrivial path *)
		 (case (lookup_module_alias(context,il_mod)) of
		    NONE => (if (!debug) then
			       (print "---lookup_module_alias failed to find ";
				Ppil.pp_mod il_mod; 
				print "\n")
			     else ();
			     xmod' context args)
		  | SOME (name_c, name_r (*,knd_c*) ) =>
			let val (name_c,name_r,cbnd_cat,ebnd_cat,context) = 
			  (case required_names of 
			     NONE => (name_c,name_r,LIST[],LIST[],context)
			   | SOME(_, req_c, req_r) => 
			       let val context' = 
				 update_NILctx_insert_kind_equation(context, 
								    req_c,
								    name_c)
			       in  (Var_c req_c, Var_e req_r, 
				    LIST[Con_cb(req_c,name_c)], 
				    LIST[Exp_b(req_r, TraceUnknown, name_r)],
				    context')
			       end)
			in {cbnd_cat=cbnd_cat, ebnd_cat=ebnd_cat, 
			    name_c=name_c, name_r=name_r,
			    context = context (*, knd_c=knd_c*) }

			end)              
	      | _ => xmod' context args)

	   (* Compute the result, optionally checking the memoized_mpath
              memopad *)
	   val result = (if (!do_memoize) then
	                   check_proj il_mod
			 else
			   xmod' context args)
	     handle e => (if (!debug) then 
			    (print ("Exception detected in call " ^ 
				    (Int.toString this_call) ^ " to xmod\n");
			     print "\nwith mod = \n";
			     Ppil.pp_mod il_mod;
			     (*
			      print "\nwith context = \n";
			      print_splitting_context context;
			      *)
			     print "\n")
			  else ();
			  raise e)
	in
	    if (!debug) then 
	      (print "Return ";
	       print (Int.toString this_call);
	       print " from xmod\n") 
	    else ();
	    result
        end

   (* preproject.  Eagerly create, name, and translate all module-projections 
         from a module.  The results will be stored in the memoized_mpath
	 so that any future module projection will be fast; furthermore,
         because the projections will be named, the translation of any
         path will be simply be a variable (or rather, two variables, one
         for each part).

	 The preproject function should be called as soon as a new module
	 is created, so that the named projections are in scope wherever
	 the original module was in scope.

         I'm not sure, but I suspect it may not be re-using the result
	 of phase-splitting M.a to phase-split M.a.b --- or vice
	 versa.  
    *)
   and preproject (var_arg : N.var (* The IL (unsplit) name of module
				      being projected from *),
		   il_signat, context) = 
	let 
	    (* Given a module, an accumulator list, and a signature for
	       that module, find all the valid projections from this module
               that return structures.
             *)
	    fun find_structure_paths (m : Il.mod) (acc : Il.mod list)
		(Il.SIGNAT_STRUCTURE( (Il.SDEC(l,Il.DEC_MOD(_,false,s))) ::
				      rest)) = 
 		   if ((!elaborator_specific_optimizations) andalso 
		       (N.is_dt l)) then
		       (* Ignore all modules marked as (inner) datatypes;
			  they're never accessed. *)
		       find_structure_paths m acc (Il.SIGNAT_STRUCTURE(rest))
		   else	
                       (* Found a structure *)
		       let val acc = (Il.MOD_PROJECT(m,l))::acc
			   (* Recurse to get all the substructures *)
			   val acc = find_structure_paths (Il.MOD_PROJECT(m,l))
			                                  acc s
		       in  
			 find_structure_paths m acc (Il.SIGNAT_STRUCTURE(rest))
		       end
	      | find_structure_paths m acc (Il.SIGNAT_STRUCTURE(_::rest)) =
		   find_structure_paths m acc (Il.SIGNAT_STRUCTURE(rest))
	      | find_structure_paths m acc _ = acc
		   
	    val rev_paths : Il.mod list = 
	      find_structure_paths (Il.MOD_VAR var_arg) [] il_signat

	    val _ =  if (!debug)
		     then (print "preproject: there are "; 
			   print (Int.toString (length rev_paths)); 
			   print " paths\n")
		     else ()

            (* OK, now loop over all these paths and translate them. 
             *)
	    fun folder (mpath : Il.mod, (cbnds,ebnds,context)) = 
		let 
		  (* Create a name for a fresh IL variable that reflects
		     the IL path to which it is being bound *)
		  fun loop (Il.MOD_VAR v) acc = (N.var2name v) ^ acc
		    | loop (Il.MOD_PROJECT (m,l)) acc = 
		           loop m ("_" ^ (N.label2name l) ^ acc)
                    | loop _ _ = error "preproject/folder: non-path module"

		  val var = N.fresh_named_var(loop mpath "")

		  val ((var_c, var_r), context) = splitNewVar (var, context)

		  (* Actually phase-split the path *)
		  val {cbnd_cat, ebnd_cat, name_c, name_r, (*knd_c,*) context}=
		       xmod context (mpath,SOME(var,var_c,var_r))

                  (* Add the new bindings to the accumulator arguments *)
		  val cbnds = cbnd_cat :: cbnds
		  val ebnds = ebnd_cat :: ebnds

                  (* Remember the results of splitting this path *)
		  val context = add_module_alias(context, mpath, 
						 name_c, name_r(*,knd_c*))
		in  (cbnds,ebnds,context)
		end

	    val (rev_cbnds,rev_ebnds,context) = 
	      foldr folder ([],[],context) rev_paths

	in  
	    {cbnd_cat = APPEND (rev rev_cbnds), 
	     ebnd_cat = APPEND (rev rev_ebnds), 
	     context = context}
	end

   (* xmod'. The worker function for translating modules, called by xmod.
         Has the same inputs/outputs/preconditions/postconditions as
         xmod.

         Note that all recursive calls should go back to the xmod wrapper,
         instead of directly calling xmod' again.
    *)
   and xmod' context 
             (il_mod as (Il.MOD_VAR var_mod), required_names) : xmod_result = 
       let
           (* The splitting for this module variable should have already
              been determined at its binding site.
            *)
	   val ((var_mod_c, var_mod_r), context) = splitVar (var_mod,context)
	   val _ = mark_var_used(context,var_mod_r)
	   val _ = mark_var_used(context,var_mod_c)

           val _ = if (!full_debug)
		       then (print "About to look up :\n";
			     Ppnil.pp_exp (Var_e var_mod_r);
			     print " and ";
			     Ppnil.pp_con (Var_c var_mod_c);
			     print "\n")
		   else ()

           (* If there was no specification as to what variables the
              compile-time parts and run-time parts should be bound to,
              we don't have to create any new bindings and can just return
              the previously determined variables.  Otherwise, we need
              to bind these two variables to new variables with the
              specified names.
            *)
	   val (name_c, name_r) = 
	       (case required_names of
		    NONE => (Var_c var_mod_c, Var_e var_mod_r)
		  | SOME (_, name_c, name_r) => (Var_c name_c, Var_e name_r))

	   val (cbnd_cat, ebnd_cat, context) =
	       (case required_names of
		    NONE => (LIST [], LIST [], context)
		  | SOME (_, name_c, name_r) => 
			(LIST [Con_cb(name_c, Var_c var_mod_c)],
			 LIST [Exp_b (name_r, TraceUnknown, Var_e var_mod_r)],
			 update_NILctx_insert_kind_equation
			  (context, name_c, Var_c var_mod_c)))

       in
	   {cbnd_cat = cbnd_cat,
	    ebnd_cat = ebnd_cat,
            name_c   = name_c,
            name_r   = name_r,
	    context  = context}
       end

     | xmod' context (Il.MOD_APP(ilmod_fun, ilmod_arg), required_names) =
       let

	   (* Split the argument and the result 
            *)
	   val {cbnd_cat = cbnd_cat_fun,
		ebnd_cat = ebnd_cat_fun,
		name_c = name_fun_c,
                name_r = name_fun_r,
		context = context
		} = xmod context (ilmod_fun, NONE)

	   val {cbnd_cat = cbnd_cat_arg,
		ebnd_cat = ebnd_cat_arg,
		name_c = name_arg_c,
		name_r = name_arg_r,
		context = context
		} = xmod context (ilmod_arg, NONE)
	     
	   (* Figure out the names to which the two parts of the 
	      application will be bound ... either fresh or as
              specified
            *)
	   val (var, var_c, var_r, context) = 
	     chooseName (required_names, context)
	   val name_c = Var_c var_c
	   val name_r = Var_e var_r

           (* Create the type part of the application *)
           val con_new = App_c(name_fun_c,[name_arg_c])
	   val cbnd_cat_app = LIST[Con_cb(var_c, con_new)]
	   val cbnd_cat = APPEND[cbnd_cat_fun, cbnd_cat_arg, cbnd_cat_app]

	   (* Update the context *)
	   val context = 
	     update_NILctx_insert_kind_equation(context, var_c, con_new)
       
	   (* Create the term part of the application *)
	   val ebnd_cat_mod = LIST[Exp_b(var_r, TraceUnknown,
					 NU.makeAppE
					    name_fun_r
					    [name_arg_c]
					    [name_arg_r]
					    [])]
	   val ebnd_cat = APPEND[ebnd_cat_fun, 
				 ebnd_cat_arg,
				 ebnd_cat_mod]

       in
	   {cbnd_cat  = cbnd_cat,
	    ebnd_cat  = ebnd_cat,
	    name_c    = name_c,
	    name_r    = name_r,
	    context  = context}
       end

     | xmod' context (Il.MOD_SEAL(il_mod,_), required_names) = 
       (* The phase-splitting breaks abstraction since
          the code has already typechecked; just ignore any IL sealing.
        *)
       xmod context (il_mod, required_names)
    
     | xmod' context (Il.MOD_PROJECT (il_module,lbl), required_names) =
       let
	   (* If we got to this point then il_module.lbl is not a
	      path that can be found in the alias/mpath_memoize memopad
           *)
	   val _ = if ((!elaborator_specific_optimizations) andalso
		       (N.is_dt lbl)) then
		      error "use of datatype labels detected"
		   else ()
	   
	   val {cbnd_cat = cbnd_mod_cat, 
		ebnd_cat = ebnd_mod_cat,
		name_c   = name_mod_c, 
		name_r   = name_mod_r,
		context  = context,
		...} = xmod context (il_module, NONE)

	   val (var_proj, var_proj_c, var_proj_r, context) = 
	       chooseName (required_names, context)
	   val name_c = Var_c var_proj_c
	   val name_r = Var_e var_proj_r

	   (* Type part *)
	   val con_proj_c = Proj_c(name_mod_c,lbl)
	   val cbnd_cat_proj = LIST [Con_cb(var_proj_c, con_proj_c)]
           val cbnd_cat = APPEND[cbnd_mod_cat,cbnd_cat_proj]

           (* Extend context *)
	   val context = 
	     update_NILctx_insert_kind_equation(context,var_proj_c,con_proj_c)

	   (* Term part *)
	   val ebnd_cat_proj = LIST [Exp_b(var_proj_r, TraceUnknown,
					   NU.makeSelect name_mod_r [lbl])]
	   val ebnd_cat = APPEND[ebnd_mod_cat, ebnd_cat_proj]

      in
	   {cbnd_cat = cbnd_cat,
	    ebnd_cat = ebnd_cat,
            name_c   = name_c,
	    name_r   = name_r,
	    context  = context}
       end

     | xmod' context (Il.MOD_FUNCTOR(arrow, var_arg, 
				     il_arg_signat, ilmod_body, ilmod_signat), 
		      required_names) =
       let
	   (* Pick the name of the result *)
	   val (var_fun, var_fun_c, var_fun_r, context) = 
	       chooseName (required_names, context)
           val name_fun_c = Var_c var_fun_c
	   val name_fun_r = Var_e var_fun_r

	   (* Split the argument parameter *)
	   val ((var_arg_c, var_arg_r), context') = 
	     splitNewVar (var_arg,context)

	   val _ = clear_memo var_arg

           (* Split the argument signature *)
	   val (knd_arg, con_arg) = 
	         xsig context' (Var_c var_arg_c, il_arg_signat)

	   (* Temporarily extend the context with the type part of the
	      argument variable
            *)
	   val context' = 
	     update_NILctx_insert_kind(context', var_arg_c, knd_arg)

	   (* Split the result signature (in the extended context).
              The App_c argument to xsig is really a dummy value.
              It plays no role in computing the type of the term part
              of the functor's result, which is used as the return type
              of the function that is the term part of the entire functor. 
            *)
	   val (_,con_res) = 
	     xsig context' (App_c(name_fun_c, [Var_c var_arg_c]), 
			    ilmod_signat)

	   (* If we're doing preprojections, start the translation
              of the functor body by projecting out all the module
	      paths from the argument structure.
            *)
           val (cbnd_preproject_cat, ebnd_preproject_cat, context') = 
	       if (!do_preproject)
		   then let val {cbnd_cat = cbnd_preproject_cat,
				 ebnd_cat = ebnd_preproject_cat,
				 context = context'} = 
		             preproject(var_arg,il_arg_signat,context')
			in (cbnd_preproject_cat, ebnd_preproject_cat, context')
			end
	       else (LIST[], LIST[], context')

           (* Split the functor body *)
	   val {cbnd_cat = cbnd_body_cat, 
		ebnd_cat = ebnd_body_cat, 
		name_c = name_body_c,
		name_r = name_body_r,
		context = _
		} = xmod context' (ilmod_body, NONE)

           (* Prepend all the preprojections that the translation
              of the body is depending on.
            *)
	   val cbnd_body_cat = APPEND[cbnd_preproject_cat, cbnd_body_cat]
	   val ebnd_body_cat = APPEND[ebnd_preproject_cat, ebnd_body_cat]

           (* Translate the effect *)
	   val effect = xeffect arrow

           (* Turn the body definitions into lists *)
           val cbnds_body = flattenCatlist cbnd_body_cat
           val ebnds_body = flattenCatlist ebnd_body_cat

           (* Determine the result type of the body *)
	   val con_res' = NU.makeLetC cbnds_body con_res

           (* Create a binding for the type part of the functor *)
           val con_body = NU.makeLetC cbnds_body name_body_c
           val cbnd_fun_cat = 
	       LIST[Open_cb(var_fun_c, [(var_arg_c, knd_arg)],
			    con_body)]

	   (* Add this binding to the context *)
	   val context = 
	     update_NILctx_insert_kind(context, var_fun_c, 
				       Arrow_k(Open, [(var_arg_c, knd_arg)], 
					       Single_k(con_body)))

           (* Create a binding for the term part of the functor *)
	   val ebnd_fun_cat =  
	     LIST[Fixopen_b (Sequence.fromList
			     [(var_fun_r,
			       Function{recursive = Leaf,
					effect = effect,
					isDependent =  true,
					tFormals = [(var_arg_c, knd_arg)],
					eFormals = [(var_arg_r, TraceUnknown, 
						     con_arg)],
					fFormals = [],
					body = (NU.makeLetE Sequential
						((map NU.makeConb cbnds_body) 
						 @ ebnds_body)
						name_body_r),
					body_type = con_res'})])]

       in
	   {cbnd_cat = cbnd_fun_cat,
            ebnd_cat = ebnd_fun_cat,
	    name_c = name_fun_c,
	    name_r = name_fun_r,
	    context = context}
       end
   
     | xmod' context (Il.MOD_STRUCTURE sbnds, required_names) =
       let

           (* We need to throw away most of the context returned by
              keep the context resulting from xsbnds. The mpath
              memoization contains variables now out of scope, but we
              want to keep the nilCTX part because it contains
              declarations for the cbnd_cat bindings.  
            *)

	   val {final_context, 
		cbnd_cat = cbnd_cat_bnds, 
		ebnd_cat = ebnd_cat_bnds, 
		record_c_con_items, 
		record_c_knd_items, 
		record_r_exp_items} = 
		(xsbnds context sbnds)
	   val context = replace_NILctx(context, get_nilctxt final_context)

           (* Get the name for the translated structure *)
	   val (var_str, var_str_c, var_str_r, context) = 
	       chooseName (required_names, context)
           val name_str_c = Var_c var_str_c
	   val name_str_r = Var_e var_str_r

           (* Type part *)
	   val con_str_c = Crecord_c record_c_con_items
	   val cbnd_cat_str = LIST [Con_cb(var_str_c, con_str_c)]
           val cbnd_cat = APPEND[cbnd_cat_bnds,cbnd_cat_str]

           (* Term part *)
           val specialize =
	       (case (!elaborator_specific_optimizations, sbnds) of
		    (true, [Il.SBND(lab, Il.BND_EXP _)]) => 
		                    N.eq_label (lab, IlUtil.it_lab)
		  | _ => false)

	   val ebnd_cat_str = 
	       if specialize then
		   (* This module has one element with the label "it".
	              Must be a result of translating ML polymorphism,
	              in which case we can return the element directly
		      rather than wrapped as a singleton record.
                    *)
		   LIST[Exp_b (var_str_r, TraceUnknown, 
			       #2(hd record_r_exp_items))]
	       else     
		 let 
		   val (labels,exps) = unzip record_r_exp_items

		   val tvar = N.fresh_named_var "struct_gctag"

		   val r = Prim_e (NilPrimOp (record labels), [], [], 
				   (Var_e tvar)::exps)

		   (* Note that exps will always be of the form (Var_e v)

                      XXX: Use of Typeof_c to get the types of the term
                           parts of the record. 
                    *)
		   val rtype = Prim_c(Record_c(labels, NONE),
				      map Typeof_c exps)

		   val trs = map (fn _ => TraceUnknown) labels
		 in
		   LIST[Exp_b (tvar, TraceUnknown,
			       Prim_e(NilPrimOp mk_record_gctag, 
				      trs, [rtype],[])),
			Exp_b (var_str_r, TraceUnknown,r)]
		 end

	   val ebnd_cat = APPEND[ebnd_cat_bnds,ebnd_cat_str]

	   (* Extend context *)
	   val context = 
	     update_NILctx_insert_kind_equation(context, var_str_c, con_str_c)


       in
	   {cbnd_cat = cbnd_cat,
	    ebnd_cat = ebnd_cat,
            name_c = name_str_c,
	    name_r = name_str_r,
	    context = context}
       end

    | xmod' context (Il.MOD_LET (var_loc, il_loc_mod, il_body_mod),
		     required_names) =
       let

(*	   val _ = clear_memo var_loc *)

	   val ((var_loc_c, var_loc_r), context) = 
	     (* var_loc might be locally shadowing a previous variable
	        of the same name, but we still want new _c and _r
	        variable names 
              *)
	     splitNewVar (var_loc, context)

           val _ = clear_memo var_loc

           (* Split the local part *)
	   val {cbnd_cat = cbnd_loc_cat,
		ebnd_cat = ebnd_loc_cat,
		context = context,
		...} = xmod context (il_loc_mod, 
				     SOME (var_loc, var_loc_c, var_loc_r))

	   (* Split the body *)
	   val {cbnd_cat = cbnd_body_cat,
		ebnd_cat = ebnd_body_cat,
		name_c = name_let_c,
		name_r = name_let_r,
		context = context} =  
	       xmod context (il_body_mod, required_names)

           (* Lets get flattened out, which is safe since everything
              is being named with fresh names so this scope extrusion
              can't cause accidental shadowing.  Everything thus remains
              in scope and all the extensions of the context are
              still useable.
            *)
           val cbnd_let_cat = APPEND[cbnd_loc_cat, cbnd_body_cat]
           val ebnd_let_cat = APPEND[ebnd_loc_cat, ebnd_body_cat]

       in
	   {cbnd_cat = cbnd_let_cat,
	    ebnd_cat = ebnd_let_cat,
            name_c = name_let_c,
	    name_r = name_let_r,
	    context = context}
       end
       (* End of xmod' *)

   (* xmod.  Translation of a sequence of IL structure bindings.
    *)
   and xsbnds context il_sbnds =
       let
	   (* Tracing messages on entry *)
	   val this_call = ! xsbnds_count
	   val _ = 
	       if (!debug) then
		   (xsbnds_count := this_call + 1;
		    print "Call ";
		    print (Int.toString this_call);
		    print " to xsbnds\n";
		    if (!full_debug) then 
		      (Ppil.pp_sbnds il_sbnds;
		       print ("\n")) 
		    else ())
	       else ()

           (* Actually do the translation by calling xsbnds_rewrite_1
            *)
	   val result = (xsbnds_rewrite_1 context il_sbnds)
	       handle e => (if (!debug) then (print ("Exception detected in call " ^ 
						    (Int.toString this_call) ^ " to xsbnds\n");
(*
					      print "\nwith context = \n";
					      print_splitting_context context;
*)
					      print "\n")
			    else ();
			    raise e)

	in
	    (* Tracing messages on return *)
	    if (!debug) then 
               (print "Return ";
		print (Int.toString this_call);
		print " from xsbnds\n")
	    else ();
	    result
        end

   (* xsbnds_rewrite_1.  Phase 1 of rewriting for structure bindings.

      (The rewriting phases detect particular patterns of bindings
      generated by the elaborator, and may treat a binding or sequence
      of bindings specially, or even throw them away.  Thus, we cannot
      implement translation of the sbnds by mapping a function over
      each sbnd individually.)        

      If the bindings start with an inner-datatype structure and the
      optimization flag is on, discard this binding and start over
      (from the xsbnds wrapper!) with the remaining bindings.
      Otherwise pass the bindings on the phase 2.  
    *)
   and xsbnds_rewrite_1 (context : splitting_context) ([] : Il.sbnd list) =
       {final_context = context,
	cbnd_cat = LIST nil,
	ebnd_cat = LIST nil,
	record_c_con_items = nil,
	record_c_knd_items = nil,
	record_r_exp_items = nil}

     | xsbnds_rewrite_1 context 
                       (il_sbnds as (Il.SBND(lab, Il.BND_MOD _)) :: 
                                     rest_il_sbnds) =
        if ((!elaborator_specific_optimizations)
	    andalso (N.is_dt lab)) then
	    xsbnds context rest_il_sbnds
        else
	    xsbnds_rewrite_2 context il_sbnds


     | xsbnds_rewrite_1 context il_sbnds = 
	    xsbnds_rewrite_2 context il_sbnds

   (* xsbnds_rewrite_2.  Phase 2 of rewriting for structure binidngs.

      The HIL has no primitive notion of bindings for mutually-recursive
      functions.  The elaborator must thus generate a "cluster" (essentially
      the functions as a tuple) immediately followed by a series of
      bindings giving names to all the projections from that cluster.

      If the optimization flag is on, turn these into
      mutually-recursive bindings at the NIL level.  The do_polyrec
      flag must also be on in order to perform this transformation on
      polymorphic mutually-recursive functions

    *)
   and xsbnds_rewrite_2 context 
                        (il_sbnds as
			 Il.SBND(lbl, 
				 Il.BND_EXP(top_var, 
					    il_exp as Il.FIX(_, _, fbnds)))
			 ::rest_il_sbnds) =
       (if ((!elaborator_specific_optimizations) 
	    andalso (N.is_cluster lbl)) then
	   (* Definition of monomorphic recursive functions *)
	   let
               (* From the cluster we can tell how many projections from
                  this cluster follow its definition. *)
	       val num_functions = length fbnds

	       (* external_labels = Exported labels for these functions.
                  external_vars = Variables to which the functions are being
		                  bound in (skipped) IL bindings 
                  rest_il_sbnds' = remaining il_sbnds after this 
                                   cluster of functions and the projections
                *)
	       val (rest_il_sbnds', external_labels, external_vars) = 
		   getSbndNames num_functions rest_il_sbnds

	       (* internal_renamed_vars = 
                      Variables to which the functions are bound
	              in the literal translation of the cluster, and by
                      which their translations refer to each other, and
                      which will be used as the names in the
                      recursive bindings being returned.  (They're
                      fresh variables, as well.)

		  nil_functions = functions in the literal translation
                                  of the clusteris cluster
                *)
	       val nil_fn_seq = 
		   let
		     val Let_e (_,(Fixopen_b nil_fn_set)::_,_) = 
		       xexp context il_exp
		   in
		     nil_fn_set
		   end

               val (internal_renamed_vars, nil_functions) = 
		 Listops.unzip (Sequence.toList nil_fn_seq)

               (* Remember for the purposes of translating later
                  sbnds that references to these functions (via
                  variables in external_vars) should use the names
                  appearing in the returned NIL bindings.
                *)
	       val context' = insert_given_vars(external_vars, 
						internal_renamed_vars, 
						context)

               (* Currently unused, but will be needed if we start
                  returning contexts with types, to avoid requiring
                  Typeof_c's *)
               (* val ebnd_types = map (NU.function_type Open) nil_functions *)

               (* The translation of the initial cluster binding and all
                  the following projections is this single binding 
                *)
	       val ebnd = Fixopen_b nil_fn_seq

               (* Continue on with the remaining bindings, but with the
                  xsbnds wrapper function.
                *)
	       val {final_context, cbnd_cat, ebnd_cat, record_c_con_items,
		    record_c_knd_items,
		    record_r_exp_items} = 
		 xsbnds context' rest_il_sbnds'

	   in
	       {final_context = final_context,
		cbnd_cat = cbnd_cat,
		ebnd_cat = CONS(ebnd, ebnd_cat),
		record_c_con_items = record_c_con_items,
		record_c_knd_items = record_c_knd_items,
		record_r_exp_items = (* If this is in a module, then
                                        all of the functions within
                                        the nest become components of
                                        the corresponding record 
                                      *)
		                     (Listops.zip external_labels 
				         (map Var_e internal_renamed_vars)) 
		                     @ record_r_exp_items}
	   end
	else
	  (* The first binding is a FIX, but either it's not a cluster
             or we've turned off this optimization.  Translate it directly
             by going to phase 3. 
           *)
	  xsbnds_rewrite_3 context il_sbnds)

     | xsbnds_rewrite_2 context
                        (il_sbnds as
			 Il.SBND(lbl, 
				Il.BND_MOD
				(top_var, true, m as 
				 Il.MOD_FUNCTOR
				 (Il.TOTAL,poly_var, il_arg_signat, 
				  Il.MOD_STRUCTURE
				  [Il.SBND(them_lbl,
					   Il.BND_EXP
					   (_, il_exp as Il.FIX(is_recur, _, 
								fbnds)))],
				  il_body_signat)))
			 :: rest_il_sbnds) =

       if ((!do_polyrec)
           andalso (!elaborator_specific_optimizations) 
	   andalso (N.is_label_internal lbl) 
           andalso (not (N.eq_label (lbl, IlUtil.expose_lab)))
	   andalso (N.eq_label (them_lbl, IlUtil.them_lab))
	   andalso (not (N.is_eq lbl))
           ) then

	   (* Same as the previous case, but now we're doing polymorphic
	      function clusters.
           *)
	   let

               val _ = clear_memo top_var
               val _ = clear_memo poly_var

	       (* external_labels = Exported labels for these functions.
                  external_vars = Variables to which the functions should be bound
                                  in the returned NIL bindings 
                  rest_il_sbnds' = remaining il_sbnds after this group of functions 
                *)
	       val num_functions = length fbnds
	       val (rest_il_sbnds', external_labels, external_vars) = 
		   getSbndNames num_functions rest_il_sbnds

	       (* internal_vars = Variables to which the functions are bound
	                          in the direct translation of the HIL cluster.
		  functions = Bodies of the functions in this 
		                 mutually-recursive group *)

	       val ((poly_var_c, poly_var_r), context') = splitNewVar (poly_var, context)

	       val (knd_arg, con_arg) = 
		      xsig context' (Var_c poly_var_c, il_arg_signat)

	       val context' = update_NILctx_insert_kind(context', poly_var_c, 
							knd_arg)

	       val Let_e (_, (Fixopen_b set)::_, _) = xexp context' il_exp

               val (internal_vars, functions) = Listops.unzip (Sequence.toList set)

               val inner_vars = map 
		   (fn v => N.fresh_named_var((N.var2name v) ^ "_inner")) external_vars


               val (external_var_rs, context) =
		   let
		       fun folder (v,context) = 
			   let
			       val ((_,v_r),context) = splitNewVar (v,context)
			   in
			       (v_r, context)
			   end
		   in
		       Listops.foldl_acc folder context external_vars
		   end

	       fun wrap(current_internal_var, inner_var,e) = 
		   let 
		       fun mapper(internal_var,external_var_r) = 
			   if (N.eq_var(internal_var,current_internal_var))
			       then Exp_b(internal_var, TraceUnknown, Var_e inner_var)
			   else Exp_b(internal_var, TraceUnknown, NU.makeAppE 
				      (Var_e external_var_r)
				      [Var_c poly_var_c]
				      [Var_e poly_var_r]
				      [])
		       val bnds = Listops.map2 mapper (internal_vars, external_var_rs)
		   in  NU.makeLetE Sequential bnds e
		   end

               fun reviseFunction (internal_var,
				   external_var_r, inner_var,
				   Function{effect,recursive,isDependent,
					    tFormals = [],
					    eFormals = [(arg_var, arg_tr, arg_con)],
					    fFormals = [],
					    body,
					    body_type = inner_body_type}) =
		   let val body' = wrap(internal_var, inner_var, body)
		       val outer_body_type = AllArrow_c{openness = Open, effect = effect, 
							isDependent = false,
							tFormals = [], 
							eFormals = [(NONE,arg_con)], 
							fFormals = 0w0, 
							body_type = inner_body_type}
		   in  (external_var_r,
		       Function{effect = Total,
				recursive = Leaf, 
				isDependent = false,
				tFormals = [(poly_var_c, knd_arg)],
				eFormals = [(poly_var_r, TraceUnknown, con_arg)],
				fFormals = [],
				body = Let_e (Sequential,
				       [Fixopen_b
					(Sequence.fromList 
					 [(inner_var, Function{effect=effect,recursive=recursive,isDependent=false,
							       tFormals = [],
							       eFormals = [(arg_var,arg_tr,arg_con)],
							       fFormals = [],
							       body = body',
							       body_type = inner_body_type})])],
				       Var_e inner_var),
				body_type = outer_body_type})
		   end

               val ebnd_entries = (Listops.map4 reviseFunction 
				   (internal_vars, external_var_rs, inner_vars, functions))
               val ebnd_types = map (NU.function_type Open) functions


	       val ebnds = [Fixopen_b (Sequence.fromList ebnd_entries)]

               val context = update_polyfuns_list(context, external_var_rs)

	       val {final_context, cbnd_cat, ebnd_cat, record_c_con_items,
		    record_c_knd_items, 
		    record_r_exp_items} = xsbnds context rest_il_sbnds'
		    
	   in
	       {final_context = final_context,
		cbnd_cat = cbnd_cat,
		ebnd_cat = APPEND [LIST ebnds, ebnd_cat],
		record_c_con_items = record_c_con_items,
  	        record_c_knd_items =  record_c_knd_items,
		record_r_exp_items = (Listops.zip external_labels (map Var_e external_var_rs))
		                     @ record_r_exp_items}
	   end
       else
	   xsbnds_rewrite_3 context il_sbnds

     | xsbnds_rewrite_2 context il_sbnds = xsbnds_rewrite_3 context il_sbnds

   (* xsbnds_rewrite_3.  Phase 3 of translation for structure bindings.
    
      None of the special cases matched, so translate the first binding
      and recursively (via the xsbnds wrapper) translate the rest.
    *)

   and xsbnds_rewrite_3 context 
                        (Il.SBND(lbl, Il.BND_EXP(var, il_exp)) :: 
			 rest_il_sbnds) =
       (* Translation of a binding for an expression. *)
       let
	   val exp = xexp context il_exp

	   val (var', context') = insert_rename_var (var, context)

	   val {final_context, cbnd_cat, ebnd_cat, record_c_con_items,
		record_c_knd_items, 
		record_r_exp_items} = xsbnds context' rest_il_sbnds
       in
	   {final_context = final_context,
	    cbnd_cat = cbnd_cat,
	    ebnd_cat = CONS(Exp_b(var',TraceUnknown, exp), ebnd_cat),
	    record_c_con_items = record_c_con_items,
	    record_c_knd_items = record_c_knd_items,
	    record_r_exp_items = (lbl, Var_e var') :: record_r_exp_items}
       end

     | xsbnds_rewrite_3 context 
                        (Il.SBND(lbl, Il.BND_CON(var, il_con)) :: 
			 rest_il_sbnds) =
       (* Translation of a binding for a type *)
       let

	   val con = xcon context il_con
	     
	   val (var',context') = insert_rename_var (var, context)

           val context'' = update_NILctx_insert_kind_equation(context', 
							      var', con) 

	   val {final_context, cbnd_cat, ebnd_cat, record_c_con_items,
		record_c_knd_items,
		record_r_exp_items} = xsbnds context'' rest_il_sbnds
       in
	   {final_context = final_context,
	    cbnd_cat = CONS (Con_cb(var', con), cbnd_cat),
	    ebnd_cat = ebnd_cat,
	    record_c_con_items = (lbl, Var_c var') :: record_c_con_items,
	    record_c_knd_items = ((lbl, var), Single_k con) :: record_c_knd_items, 
	    record_r_exp_items = record_r_exp_items}
       end

     | xsbnds_rewrite_3 context 
                       (Il.SBND(lbl, Il.BND_MOD(var, false, il_module))
			::rest_il_sbnds) =
       (* Translation of a binding that is not a functor resulting
          in the translation of a polymorphic function. *)
       let
           val _ = clear_memo var

           (* The elaborator is not supposed to duplicate variables,
              but occasionally this happens (and the phase-splitter's
              scope extrusion may put variables that used to
              have disjoint scopes into overlapping scopes).

              Thus, apparently because we're keeping the *unsplit*
              variable name associated with path definitions in the
              alias part of the splitting context, and we don't want
              unrelated paths to be associated with the same variable
              name, we rename the variable in the IL code before
              processing the binding.
            *)
	   val (var,rest_il_sbnds) = 
	       (case lookupVmap (var,context) of
		    NONE => (var,rest_il_sbnds)
		  | SOME _ => 
			let val _ = (print ("WARNING (xsbnds/BND_MOD):  " ^
					"Compensating for duplicate variable");
				     Ppnil.pp_var var;
				     print "\n")
			    val v = N.derived_var var
			    val subst = IlUtil.subst_add_modvar(IlUtil.empty_subst, var, Il.MOD_VAR v)
			    val Il.MOD_STRUCTURE rest' = 
				IlUtil.mod_subst(Il.MOD_STRUCTURE rest_il_sbnds,subst)
			in (v,rest')
			end)

	   val ((var_c, var_r), context) = splitNewVar (var,context)
	       
           (* Split the right-hand side of the binding *)
	   val {cbnd_cat = cbnd_mod_cat, 
		ebnd_cat = ebnd_mod_cat,
		context = context,
		name_c, name_r,
		...} = xmod context (il_module, SOME(var, var_c, var_r))

	   (* If the module being bound is a path, then remember that 
	      the IL variable and IL path were defined to be aliases.
	    *)
	   val context = 
	     (case (extractProjLabels il_module) of
		(Il.MOD_VAR tovar,labs) => 
		    add_modvar_alias(context,var,(tovar,labs))
	      | _ => context)

	   (* Do the rest of the bindings *)
	   val {final_context, cbnd_cat, ebnd_cat, record_c_con_items,
		record_c_knd_items, 
		record_r_exp_items} = xsbnds context rest_il_sbnds

       in
	   {final_context = final_context,
	    cbnd_cat = APPEND[cbnd_mod_cat, cbnd_cat],
	    ebnd_cat = APPEND[ebnd_mod_cat, ebnd_cat],
	    record_c_con_items = (lbl, name_c) :: record_c_con_items,
	    record_c_knd_items = ((lbl, var_c), Single_k(name_c)) :: 
	                         record_c_knd_items, 
	    record_r_exp_items = (lbl, name_r) :: record_r_exp_items}
       end

     | xsbnds_rewrite_3 context (Il.SBND(lbl,Il.BND_MOD(var, true, il_polymod))
				 :: rest_il_sbnds) =
       (* Translation of functor resulting from the translation of a 
          polymorphic function.  This is not redundent, because code like
                 val f = SOME
          creates a polymorphic definition that isn't a cluster caught
          in xsbnds_rewrite_2.
        *)
       let
           val ((_, var_r), context) = splitNewVar (var,context)

           val bnd = xpolymod context (var_r, il_polymod)

           val context = update_polyfuns (context, var_r)
           
	   val {final_context, cbnd_cat, ebnd_cat, record_c_con_items,
		record_c_knd_items, 
		record_r_exp_items} = xsbnds context rest_il_sbnds
       in
	   {final_context = final_context,
	    cbnd_cat = cbnd_cat,
	    ebnd_cat = APPEND[LIST [bnd], ebnd_cat],
	    record_c_con_items = record_c_con_items,
	    record_c_knd_items = record_c_knd_items,
	    record_r_exp_items = (lbl, Var_e var_r) :: record_r_exp_items}
       end

   (* Translate functors used in encoding polymorphism other than
      those which return clusters of functions
    *)
   and xpolymod context 
                (v_r,  Il.MOD_FUNCTOR(arrow, poly_var, il_arg_signat, il_body,
				      il_result_sig as Il.SIGNAT_STRUCTURE _))=
         let
             (* This case catches code that elaboration has essentially been
                wrapped with type abstraction/application, e.g., where
                   datatype ('a, 'b) foo = FOO
                   val 'a x : ('a,'a) foo = FOO
                becomes
                   x : = /\a. FOO[a,a]
                represented as a functor.
 
                Essentially it's just like a translation of a normal
                functor except that we know the result has no compile-time
                part that we ever care about.
              *)

	     val _ = clear_memo poly_var

(*	     val _ = (print "xpolymod binding for "; Ppil.pp_var v_r; print "\n") *)
	     val ((poly_var_c, poly_var_r), context') = 
	       splitNewVar (poly_var, context)

	     val (knd_arg, arg_type) = 
		 xsig context' (Var_c poly_var_c, il_arg_signat)

             val effect = xeffect arrow

	     val context' = 
	           update_NILctx_insert_kind(context', poly_var_c, knd_arg) 

             val il_body_structure =
		 (case il_body of
		      Il.MOD_STRUCTURE _ => il_body
		    | _ => (* e.g., if the body of the SML source function
                                    was a polymorphic instantiation *)
                           Il.MOD_STRUCTURE
			     [Il.SBND(IlUtil.it_lab, 
				      Il.BND_EXP(N.fresh_var(), 
						 Il.MODULE_PROJECT
						   (il_body, IlUtil.it_lab)))])

	     val {ebnd_cat = ebnd_cat, name_r = name_r,...} = 
		 xmod context' (il_body_structure, NONE)

             val exp = NU.makeLetE Sequential (flattenCatlist ebnd_cat) name_r

             val (_,con) = xsig context' (Var_c (N.fresh_var()),il_result_sig)

	 in
	     Fixopen_b (Sequence.fromList
			[(v_r,
			  Function{effect=effect, recursive=Leaf, isDependent = false,
				   tFormals = [(poly_var_c, knd_arg)],
				   eFormals = [(poly_var_r, TraceUnknown, arg_type)],
				   fFormals = [],
				   body = exp,
				   body_type = con})])
	 end

     | xpolymod context (v_r, il_mod) =
	 (* Catches the case in which there is no wrapping, just one
             module variable representing a polymorphic function is
             being defined by another variable or path representing
             a polymorphic function, e.g., in source code like
	       val x = SOME
          *)
         (case extractProjLabels il_mod of
	      (Il.MOD_VAR v', lbls) => 
		  let
		      val ((_,v'_r),_) = splitVar (v',context)
		      val _ = mark_var_used(context,v'_r)
		  in 
		      Exp_b(v_r, TraceUnknown, NU.makeSelect (Var_e v'_r) lbls)
		  end
            | _ => (print "xpolymod: bad module argument\n";
                    Ppil.pp_mod il_mod;
                    error "xpolymod: bad module argument"))


   (* xflexinfo.  Translator for CON_FLEXRECORD 
    *)
   and xflexinfo context (ref (Il.INDIRECT_FLEXINFO f)) = 
          xflexinfo context f
     | xflexinfo context (ref (Il.FLEXINFO(_,true, recs))) = 
          let
	    val (lbls, cons) = xrdecs context recs
	    val con = Prim_c(Record_c(lbls,NONE), cons) (* already sorted *)
	  in
	    con
	  end
     | xflexinfo _ _ = error "xflexinfo found FLEXINFO that wasn't finalized"

   (* xrdecs.   Translation of a series of label/type pairs as
                would be found within a record type.

                Returns its result as a list of labels and a list
                of (translated) types.        
    *)
   and xrdecs context [] = ([], [])
     | xrdecs context ((lab, il_con) :: rest) = 
       let
	   val (labs, cons) = xrdecs context rest
	   val con = xcon context il_con
       in
	   (lab :: labs, con :: cons)
       end

   (* xcon.  Wrapper function for the translation of IL types *)
   and xcon context il_con : con  =
       let
	   (* Tracing messages on entry 
            *)
	   val this_call = ! xcon_count
	   val _ = 
	       if (!debug) then
		   (xcon_count := this_call + 1;
		    print ("Call " ^ (Int.toString this_call) ^ " to xcon\n");
		    if (!full_debug) then (Ppil.pp_con il_con; print"\n") else ())
	       else ()

           (* Try to use the memoizing of IL constructor paths.
	      If not a path, or if do_memoize is off, then pass
              the type to the work function xcon'.
            *)
	   fun check_proj(Il.MOD_VAR v,ls) = 
	       let
		   val ((v_c,_),_) = splitVar (v,context)
	       in
		   mark_var_used(context, v_c);
		   lookup_con_memo (v,ls) (fn()=> xcon' context il_con)
	       end
	     | check_proj(Il.MOD_PROJECT(m,l),ls) = check_proj(m,l::ls)
	     | check_proj _ = xcon' context il_con

	   val result = (case (!do_memoize,il_con) of
			     (true, Il.CON_MODULE_PROJECT(m,l)) =>
			       check_proj(m,[l])
			   | _ => xcon' context il_con)
	       handle e => (if (!debug) then 
			      (print ("Exception detected in call " ^ 
				      (Int.toString this_call) ^ " to xcon: ");
			       Ppil.pp_con il_con; 
			       print "\n") 
			    else ();
			    raise e)

	in
	   (* Tracing messages on return *)
	    if (!debug) then 
	      print ("Return " ^ (Int.toString this_call) ^ 
		     " from xcon\n") 
	    else ();
	    result
        end

   (* xcon'.  The worker function for actually translating IL types *)
   and xcon' context (il_con as (Il.CON_VAR var)) : con = 
       let
	   (* The IL variable var had a renaming chosen whereever it
              was bound; apply this renaming *)
	   val var' = rename_var(var, context)

           val _    = mark_var_used (context, var')
	   val con = Var_c var'
       in
	   con
       end

     | xcon' context (Il.CON_TYVAR tv) = xcon context (derefTyvar tv)

     | xcon' context (Il.CON_OVAR ov) = xcon context (derefOvar ov)

     | xcon' context (Il.CON_FLEXRECORD fr) = xflexinfo context fr

     | xcon' context (Il.CON_INT Prim.W64) =
       error "64-bit integers not handled during/after phase-split"

     | xcon' context (Il.CON_UINT Prim.W64) =
       error "64-bit integers not handled during/after phase-split"

     | xcon' context (Il.CON_INT intsize) =
       let
           val con = Prim_c (Int_c intsize, [])
       in
	   con
       end

       (* There is no type distinction between signed/unsigned ints 
          from NIL onwards.
       *)
     | xcon' context (Il.CON_UINT intsize) = xcon' context (Il.CON_INT intsize)

     | xcon' context (Il.CON_FLOAT floatsize) = 
       let
	   val con = Prim_c (BoxFloat_c floatsize, [])
       in
	   con
       end

     | xcon' context (Il.CON_ARRAY il_con) = 
       let
	   val con' = xcon context il_con 
	   val con = Prim_c (Array_c, [con'])
       in  con
       end

     | xcon' context (Il.CON_VECTOR il_con) = 
       let
	   val con' = xcon context il_con 
	   val con = Prim_c (Vector_c, [con'])
       in  con
       end

     | xcon' context (Il.CON_ANY) = 
       let
	   val con = Prim_c(Exn_c, [])
       in
	   con
       end

     | xcon' context (Il.CON_REF il_con) = 
       let
	   val con' = xcon context il_con
	   val con = Prim_c (Array_c, [con'])
       in
	   con
       end

     | xcon' context (Il.CON_TAG il_con) = 
       let
	   val con' = xcon context il_con
	   val con = Prim_c (Exntag_c, [con'])
       in  con
       end

     | xcon' context (Il.CON_ARROW (il_cons1, il_con2, closed, arr)) =
       let
           fun translate il_con = 
	     (case (closed,il_con) of
                (* Normally xcon translates F64 to BoxedFloat, but
                   we don't want to do this when describing the types
		   of external functions.
                 *)
		(true,Il.CON_FLOAT Prim.F64) => Prim_c (Float_c Prim.F64, [])
	      | _ => xcon context il_con)

	   val cons1 = map translate il_cons1

           val con2 = translate il_con2

	   val eff = xeffect (derefOneshot arr)

	   val con = if closed then
	               ExternArrow_c(cons1, con2)
		     else 
		       AllArrow_c{openness = Open, effect = eff, 
				  isDependent = false,
				  tFormals = [], 
				  eFormals = map (fn c => (NONE,c)) cons1,
				  fFormals = 0w0, body_type = con2}
       in 
	 con
       end

     | xcon' context (il_con as Il.CON_APP (il_con1, il_cons2)) = 
       let
	   val con1 = xcon context il_con1
           val cons2 = map (xcon context) il_cons2
	   val con = App_c(con1, cons2)
       in  con
       end

     | xcon' context (Il.CON_MU(Il.CON_FUN(vars, 
					   Il.CON_TUPLE_INJECT cons))) =
       let
	   val (vars',context') = insert_rename_vars(vars, context)

	   val context'' = 
	     update_NILctx_insert_kind_list(context',
					    map (fn v => (v,Type_k)) vars')
	       
	   val cons'= map (xcon context'') cons
	   val freevars = foldl N.VarSet.union N.VarSet.empty
	                  (map IlUtil.con_free cons)
	   val is_recur = Listops.orfold (fn v => N.VarSet.member(freevars,v))
	                                 vars
	   val con = Mu_c (is_recur,
			   Sequence.fromList (Listops.zip vars' cons'))

       in
	   con
       end

     | xcon' context (Il.CON_MU(Il.CON_FUN([var], con))) =
       let
	   val (var',context') = insert_rename_var(var, context)
	   val context''= update_NILctx_insert_kind(context', var', Type_k)
	       
	   val con' = xcon context'' con
	   val freevars = IlUtil.con_free con
	   val is_recur = N.VarSet.member(freevars,var)
	   val con = Mu_c (is_recur,Sequence.fromList [(var', con')])
       in
	   con
       end

     | xcon' context (Il.CON_RECORD rdecs) = 
       let
	   val (lbls, cons) = xrdecs context rdecs
	   val con = Prim_c (Record_c(lbls,NONE), cons)
       in
	   con
       end

     | xcon' context (Il.CON_FUN (vars, il_con1)) = 
       let
	   val (vars', context') = insert_rename_vars(vars, context)
           val args = map (fn v => (v,Type_k)) vars'

	   val context'' = update_NILctx_insert_kind_list(context',args)

	   val con1 = xcon context'' il_con1

	   val fun_name = N.fresh_var ()
	   val con = NU.makeLetC [Open_cb(fun_name, args, con1)]
			       (Var_c fun_name)	
       in  con
       end

     | xcon' context (Il.CON_SUM {names, carrier, noncarriers, special}) =
       let
	   val known = (case special of
			       NONE => NONE
			     | SOME i => SOME (Word32.fromInt i))
	   val carrier_con = xcon' context carrier
	   val num_carriers = (case NilContext_kind_of(context, carrier_con) of
				   (Record_k seq) => length(Sequence.toList seq)
				 | Type_k => 1
                                 | SingleType_k _ => 1
				 | _ => error "CON_SUM: cannot have \
                                              \non-record and non-word kind")
	   val con = Prim_c (Sum_c {tagcount = Word32.fromInt noncarriers,
				    totalcount = Word32.fromInt(noncarriers + 
								num_carriers),
				    known = known}, 
			     [carrier_con])
       in
	   con
       end

     | xcon' context (Il.CON_COERCION (vars,il_from_con,il_to_con)) =
(******************** Replacing this with a Nil coercion type
       let
	 val (vars', context) = insert_rename_vars(vars, context)
	 val tformals = map (fn v => (v,Type_k)) vars'
	 val context = update_NILctx_insert_kind_list(context,tformals)
	 val from_con = xcon context il_from_con
	 val to_con = xcon context il_to_con
	 val arrow = AllArrow_c {openness    = Open,
				 effect      = Total,
				 isDependent = false,
				 tFormals    = tformals,
				 eFormals    = [(NONE,from_con)],
				 fFormals    = 0w0,
				 body_type   = to_con}
       in arrow
       end
**************************************************************)
       let
	 val (vars', context) = insert_rename_vars(vars, context)
	 val tformals = map (fn v => (v,Type_k)) vars'
	 val context = update_NILctx_insert_kind_list(context,tformals)
	 val from_con = xcon context il_from_con
	 val to_con = xcon context il_to_con
       in Coercion_c {vars=vars',from=from_con,to=to_con}
       end	 

     | xcon' context (il_con as (Il.CON_TUPLE_INJECT il_cons)) = 
       let
	 val cons = map (xcon context) il_cons
       in
	 NilDefs.con_tuple cons
       end

     | xcon' context (il_con as (Il.CON_TUPLE_PROJECT (i, il_con1))) = 
       let
	   val con1 = xcon context il_con1
	   val lbl = IlUtil.generate_tuple_label(i+1)
	   val con = Proj_c(con1, lbl)
       in con
       end

     | xcon' context (il_con as (Il.CON_MODULE_PROJECT (modv, lbl))) = 
       (* If we get here then either modv is a structure value, which
          is formally possible but probably never occurs in elaborator
          output, or else il_con is a path that hasn't been memoized
          yet.
        *)
       let
	   val {cbnd_cat,name_c,(*knd_c,*)context,...} = 
	       xmod context (modv, NONE)
           val cbnd_list = flattenCatlist cbnd_cat

	   val proj_con = Proj_c (name_c, lbl)
	   val con = NU.makeLetC cbnd_list proj_con
       in
	   con
       end

   (* toFunction.  Helper function for translating exception handlers.

      We know from the way the elaborator works that the exception
      handler is represented as an Il.FIX defining one function.
      We know from the way Il.FIX is translated below that the
      translation of this will be Let_e with a single binding,
      containing just the definition of the (non-dependent) handler function,
      and that the body of the let will just return that function.

      The toFunction function translates the fix, pulls it apart, and
      returns the handler's parameter, argument type (hopefully exn)
      and the handler body.
    *)
   and toFunction context (exp as Il.FIX _) : N.var * con * exp =
       let
	   val Let_e (_, [Fixopen_b fns], Var_e var) = xexp context exp
       in
	   case	(Sequence.lookup (N.eq_var) fns var) of
	       SOME (Function{tFormals=[], isDependent=false,
			      eFormals=[(v,_,c)], fFormals=[],body,...}) => 
	               (v,c,body)
	     | NONE => error "(toFunction): impossible"
       end
     | toFunction _ e = 
       (Ppil.pp_exp e;
	error "(toFunction): not a FIX expression")

   (* xvalue.  Translation function for term values
    *)
   and xvalue context (Prim.int (intsize, w): Il.value) : Nil.exp = 
         Const_e (Prim.int (intsize, w))

     | xvalue context (Prim.uint (intsize, w)) = 
	 Const_e (Prim.uint (intsize, w))

     | xvalue context (Prim.float (floatsize, f)) = 
         (* All floating-point values are boxed by the phase-splitter.
            Possibly a later optimization can unbox them.
          *)
         Prim_e (NilPrimOp (box_float floatsize), [],
		 [], [Const_e (Prim.float (floatsize, f))])

     | xvalue context (Prim.array (il_con, a)) = 
	 error "xvalue:  Can't translate array constants \
                \because sharing is lost"
(*       let
	   val il_exps = Array.foldr (op ::) nil a
           val con = xcon context il_con
           val exps = map (xexp context) il_exps
       in  Const_e (Prim.array (con, Array.fromList exps))
       end
*)

     | xvalue context (Prim.vector (il_con, v)) = 
       let
	   val il_exps = Array.foldr (op ::) nil v
           val con = xcon context il_con
	   val exps = map (xexp context) il_exps
       in
	   Const_e (Prim.vector (con, Array.fromList exps))
       end

     | xvalue context (Prim.refcell (ref il_exp)) = 
         error "xvalue:  Can't translate ref cell constants \
                \because sharing is lost"
(*       let
	   val exp = xexp context il_exp
       in
	   Const_e (Prim.refcell (ref exp))
       end
*)

     | xvalue context (Prim.tag(tag, il_con))  =
       let
	   val con = xcon context il_con
       in
	   Const_e (Prim.tag (tag, con))
       end

   and xexp context il_exp =
       let
	   val this_call = ! xexp_count
	   val _ = 
	       if (!debug) then
		   (xexp_count := this_call + 1;
		    print ("Call " ^ (Int.toString this_call) ^ " to xexp\n");
		    if (!full_debug) then (Ppil.pp_exp il_exp; print"\n") else ())
	       else ()

	   val result = (xexp' context il_exp)
	       handle e => (if (!debug) then (print ("Exception detected in call " ^ 
						    (Int.toString this_call) ^ " to xexp\n");
					      print "\nwith exp = \n";
					      Ppil.pp_exp il_exp;
(*
					      print "\nwith context = \n";
					      print_splitting_context context;
*)
					      print "\n")
			    else ();
			    raise e)

	in
	    if (!debug) then print ("Return " ^ (Int.toString this_call) ^ " from xexp\n") else ();
	    result
        end


   and xexp' context (Il.OVEREXP(_, _, exp_oneshot)) = 
       xexp context (derefOneshot exp_oneshot)

     | xexp' context (Il.SCON il_scon) = xvalue context il_scon

     | xexp' context (Il.ETAPRIM (prim, il_cons)) = 
       xexp context (IlUtil.prim_etaexpand(get_hilctxt context,prim,il_cons))

     | xexp' context (Il.ETAILPRIM (ilprim, il_cons)) = 
       xexp context (IlUtil.ilprim_etaexpand(get_hilctxt context,ilprim,il_cons))

     | xexp' context (il_exp as (Il.PRIM (prim, il_cons, il_args))) = 
       let
	   open Prim
	   val cons = map (xcon context) il_cons
	   val args = map (xexp context) il_args
           val (effect,con) = 
	     (* get_type' uses the NIL context just to find "bool" *)
	     case NU.strip_arrow (NilPrimUtil.get_type' (get_nilctxt context)  prim cons) of
		 SOME {effect,body_type,...} => (effect,body_type)
		| _ => (perr_c (NilPrimUtil.get_type' (get_nilctxt context) prim cons);
			error "Expected arrow constructor")

	   val con : con = (case con of
				Prim_c(Float_c fs,[]) => Prim_c(BoxFloat_c fs,[])
			      | _ => con)
	   fun id (e : exp) = e
	   fun box fs e = Prim_e(NilPrimOp(box_float fs),[], [], [e])
	   fun unbox fs e = Prim_e(NilPrimOp(unbox_float fs), [],[], [e])
	   fun float_float fs = (map (unbox fs) args, box fs)
	   fun float_int fs = (map (unbox fs) args, id)
	   fun int_float fs = (args, box fs)
	   val (args,wrap) = 
	       (case prim of
		     neg_float fs  => float_float fs
		   | (abs_float fs)  => float_float fs
		   | (plus_float fs)  => float_float fs
		   | (minus_float fs)  => float_float fs
		   | (mul_float fs)  => float_float fs
		   | (div_float fs) => float_float fs
		   | (less_float fs)   => float_int fs
		   | (greater_float fs)  => float_int fs
		   | (lesseq_float fs) => float_int fs
		   | (greatereq_float fs)  => float_int fs
		   | (eq_float fs)  => float_int fs
		   | (neq_float fs) => float_int fs
		   | float2int => float_int F64
		   | int2float => int_float F64
		   | _ => (args,id))
       in  wrap(Prim_e (PrimOp prim, [],cons, args))
	   
       end
     | xexp' context (il_exp as (Il.ILPRIM (ilprim, il_cons, il_args))) = 
       let
	   val cons = map (xcon context) il_cons
	   val args = map (xexp context) il_args
	   val zero = Const_e (Prim.int (Prim.W32, TilWord64.fromInt 0))
	   val one = Const_e (Prim.int (Prim.W32, TilWord64.fromInt 1))
	   val t = (Prim.OtherArray false)
       in  case ilprim of
	     Prim.mk_ref => Prim_e(PrimOp(Prim.create_table t),[],
				   cons, one::args)
	   | Prim.deref => Prim_e(PrimOp(Prim.sub t),[],
				  cons, args @ [zero])
	   | Prim.setref => Prim_e(PrimOp(Prim.update t),[],
				  cons, case args of
				          [a,b] => [a,zero,b]
					| _ => error "bad set_ref")
	   | Prim.eq_ref => Prim_e(PrimOp(Prim.equal_table t),[],
				   cons, args)
	   | _ => Prim_e (PrimOp (xilprim ilprim), [],cons, args)
       end

     | xexp' context (Il.VAR var) = 
       let
	   val var' = rename_var(var, context)
       in
	   mark_var_used(context,var');
	   Var_e var'
       end

     | xexp' context (il_exp as (Il.EXTERN_APP (il_con1,il_exp1, il_exps2))) =
       let
	   val exp1 = xexp context il_exp1
	   val exps2 = map (xexp context) il_exps2
	   val Il.CON_ARROW(cons2,res_con,_,_) = il_con1
	   fun mapper(e,Il.CON_FLOAT _) = Prim_e (NilPrimOp (unbox_float Prim.F64),[],[],[e])
	     | mapper(e,_) = e
	   val exps2 = Listops.map2 mapper (exps2,cons2)
	   val app = ExternApp_e (exp1, exps2)
       in  (case res_con of
	     Il.CON_FLOAT _ => Prim_e (NilPrimOp (box_float Prim.F64),[],[],[app])
	   | _ => app)
       end

           
     | xexp' context (il_exp as (Il.APP (il_exp1, il_exp2))) = 
         (case IlUtil.exp_reduce (get_hilctxt context,il_exp) of
	      NONE => 
		  let
		      val exp1 = xexp context il_exp1
		      val exp2 = xexp context il_exp2
		  in  App_e (Open, exp1, [], [exp2], [])
		  end	   
	    | SOME il_exp => xexp' context il_exp)

     | xexp' context (Il.FIX (is_recur, il_arrow, fbnds)) = 
       let
	   val fbnds'= xfbnds context (is_recur, il_arrow, fbnds)
           val set = Sequence.fromList fbnds'
           val names = map (fn (var,_) => Var_e var) fbnds'
           val num_names = List.length names
           val labels = IlUtil.generate_tuple_labels num_names
       in
	   if (num_names = 1) then
               NU.makeLetE Sequential [Fixopen_b set] (hd names)
           else
	     let
	       val types = map ((NU.function_type Open) o #2) fbnds'
	       val rtype = Prim_c(Record_c (labels,NONE),types)
	       val cvar = N.fresh_named_var "gctag_arg"
	       val cbnd = NU.makeConb (Con_cb(cvar,rtype))
	       val evar = N.fresh_named_var "gctag"
	       val trs = map (fn _ => TraceUnknown) labels
	       val tag = Prim_e(NilPrimOp mk_record_gctag,trs,[Var_c cvar],[])
	       val ebnd = Exp_b (evar,TraceUnknown,tag)
	       val fields = (Var_e evar)::names
	     in
	       (* Note: xsbnds_rewrite_2 relies on the Fixopen_b binding
		* being first.  It drops everything else to eliminate the
		* nest.
		*)
	       NU.makeLetE Sequential [Fixopen_b set,
					    cbnd,
					    ebnd]
		         (Prim_e(NilPrimOp (record labels), [],[], fields))
	     end
       end

     (*Empty record does not take gctag, so treat special
      *)
     | xexp' context (Il.RECORD [])    = (Prim_e (NilPrimOp (record []), [],[], []))

     | xexp' context (Il.RECORD rbnds) = 
       let
	   val (labels,il_exps) = Listops.unzip rbnds
	   val exps = map (xexp context) il_exps

	   fun mapper e = let val v = N.fresh_named_var "record_temp" 
			  in (Exp_b (v,TraceUnknown,e),
			      Typeof_c (Var_e v),
			      TraceUnknown,
			      Var_e v)
			  end
	   val (bnds,types,trs,exps) = Listops.unzip4 (map mapper exps)

	   val rtype = Prim_c(Record_c (labels,NONE),types)

	   val evar = N.fresh_named_var "gctag"
	   val tag = Prim_e(NilPrimOp mk_record_gctag, trs,[rtype],[])
	   val tbnd = Exp_b (evar,TraceUnknown,tag)

	   val fields = (Var_e evar)::exps
       in  
	 NU.makeLetE Sequential (bnds @ [tbnd])
	 (Prim_e (NilPrimOp (record labels), [],[], fields))
       end

     | xexp' context (Il.RECORD_PROJECT (il_exp, label, il_record_con)) =
       let
	   val exp_record = xexp context il_exp
       in
	   Prim_e (NilPrimOp (select label), [],[], [exp_record])
       end

     | xexp' context (Il.SUM_TAIL (i,il_con, il_exp)) =
       let
	   val exp = xexp context il_exp
	   val sumcon = xcon context il_con
       in  Prim_e (NilPrimOp (project (TilWord32.fromInt i)), [],[sumcon], [exp])
       end
(*
	       handle e => (print "SUM_TAIL error\n";
			    print "tagcount = "; print (w32tos tagcount); print "\n";
			    print "i = "; print (w32tos i); print "\n";
			    print "which = "; print (Int.toString which); print "\n";
			    print "length cons = "; print (Int.toString(length cons)); 
			    print "\ncon = "; Ppnil.pp_con con; print "\n";
			    raise e)
*)

     | xexp' context (Il.HANDLE (il_con, il_exp1, il_exp2)) = 
       let
	   val body = xexp context il_exp1
	   val result_type = xcon context il_con
	   val (bound, _, handler) = toFunction context il_exp2
       in
	   Handle_e {body = body, bound = bound,
		     handler = handler, result_type = result_type}
       end

     | xexp' context (Il.RAISE (il_con, il_exp)) = 
       let
	   val exp = xexp context il_exp
	   val con = xcon context il_con
       in  Raise_e (exp, con)
       end

     | xexp' context (Il.LET (bnds, il_exp)) = 
       let
	   val {cbnd_cat, ebnd_cat, final_context=context'} = xbnds context bnds
           val cbnds = flattenCatlist cbnd_cat
           val ebnds = (map NU.makeConb cbnds) @ (flattenCatlist ebnd_cat)
	   val exp = xexp context' il_exp
       in  NU.makeLetE Sequential ebnds exp
       end

     | xexp' context (Il.NEW_STAMP il_con) = 
       let val con = xcon context il_con
       in  Prim_e(NilPrimOp make_exntag, [],[con], [])
       end

     | xexp' context (Il.EXN_INJECT (s, il_tag, il_exp)) =
       let
	   val tag = xexp context il_tag
	   val exp = xexp context il_exp
       in
           Prim_e (NilPrimOp (inj_exn s), [],[], [tag, exp])
       end

     | xexp' context (Il.COERCE(il_coercion,il_cons,il_exp)) = 
       let
	 val coercion = xexp context il_coercion
	 val cons = map (xcon context) il_cons
	 val exp = xexp context il_exp
(*********** Replacing this with a Nil coercion application
       in App_e(Open,coercion,cons,[exp],[])
       end
***********************************************************)
       in Coerce_e(coercion,cons,exp)
       end

     | xexp' context (Il.FOLD (vars, il_expanded_con, il_mu_con)) = 
(*********** Replacing this with a Nil coercion value ******
       let

	   val (vars',context) = insert_rename_vars(vars, context)

	   val tformals = map (fn v => (v,Type_k)) vars'

	   val context = update_NILctx_insert_kind_list(context,tformals)

	   val expanded_con = xcon context il_expanded_con
	   val mu_con = xcon context il_mu_con

	   val fun_name = N.fresh_named_var "fold"
	   val arg_name = N.fresh_named_var "fold_arg"
	   val body = Prim_e(NilPrimOp roll, [mu_con], [Var_e arg_name])
	   val lambda = Function {effect = Total,
				  recursive = Leaf,
				  isDependent = false,
				  tFormals = tformals,
				  eFormals = [(arg_name,TraceUnknown,expanded_con)],
				  fFormals = [],
				  body = body,
				  body_type = mu_con}
	   val exp = Let_e (Sequential,[Fixopen_b (Sequence.fromList [(fun_name,lambda)])],Var_e fun_name)
       in exp
       end
***********************************************************)
       let 
	 val (vars',context) = insert_rename_vars(vars, context)
	 val tformals = map (fn v => (v,Type_k)) vars'
	 val context = update_NILctx_insert_kind_list(context,tformals)
	 val expanded_con = xcon context il_expanded_con
	 val mu_con = xcon context il_mu_con
	 val exp = Fold_e(vars',expanded_con,mu_con)
       in exp
       end
	 
  | xexp' context (Il.UNFOLD (vars, il_mu_con, il_expanded_con)) = 
(*********** Replacing this with a Nil coercion value ******
       let

	   val (vars',context) = insert_rename_vars(vars, context)

	   val tformals = map (fn v => (v,Type_k)) vars'

	   val context = update_NILctx_insert_kind_list(context,tformals)

	   val expanded_con = xcon context il_expanded_con
	   val mu_con = xcon context il_mu_con

	   val fun_name = N.fresh_named_var "unfold"
	   val arg_name = N.fresh_named_var "unfold_arg"
	   val body = Prim_e(NilPrimOp unroll, [mu_con], [Var_e arg_name])
	   val lambda = Function {effect = Total,
				  recursive = Leaf,
				  isDependent = false,
				  tFormals = tformals,
				  eFormals = [(arg_name,TraceUnknown,mu_con)],
				  fFormals = [],
				  body = body,
				  body_type = expanded_con}
	   val exp = Let_e (Sequential,[Fixopen_b (Sequence.fromList [(fun_name,lambda)])],Var_e fun_name)
       in exp
       end
***********************************************************)
       let 
	 val (vars',context) = insert_rename_vars(vars, context)
	 val tformals = map (fn v => (v,Type_k)) vars'
	 val context = update_NILctx_insert_kind_list(context,tformals)
	 val expanded_con = xcon context il_expanded_con
	 val mu_con = xcon context il_mu_con
	 val exp = Unfold_e(vars',mu_con,expanded_con)
       in exp
       end

     | xexp' context (Il.ROLL (il_con, il_exp)) = 
(*********** Replacing this with a Nil coercion application
       let
	   val con = xcon context il_con
	   val exp = xexp context il_exp
       in
	   Prim_e(NilPrimOp roll, [con], [exp])
       end
***********************************************************)
       let
	   val to_con = xcon context il_con
	   val nilctx = get_nilctxt context
	   val from_con = Normalize.expandMuType (nilctx,xcon context il_con)
	   val exp = xexp context il_exp
       in Coerce_e(Fold_e([],from_con,to_con),[],exp)
       end
	   

     | xexp' context (il_exp as (Il.UNROLL (il_mu_con, il_expanded_con, il_exp1))) = 
(*********** Replacing this with a Nil coercion application
       let
	   val mu_con = xcon context il_mu_con
	   val exp = xexp context il_exp1
       in  Prim_e(NilPrimOp unroll, [mu_con], [exp])
       end
***********************************************************)
       let
	 val from_con = xcon context il_mu_con
	 val to_con = xcon context il_expanded_con
	 val exp = xexp context il_exp1
       in Coerce_e(Unfold_e([],from_con,to_con),[],exp)
       end

     | xexp' context (Il.INJ {sumtype, field, inject = eopt}) =
       let
	   val sumcon = xcon context sumtype
	   val field =  TilWord32.fromInt field
	   val elist = (case eopt of
			    NONE => []
			  | SOME il_exp => [xexp context il_exp])
       in
	   Prim_e(NilPrimOp (inject field),[],[sumcon],elist)
       end


     | xexp' context (Il.CASE {sumtype, arg=il_arg, arms=il_arms, bound,
			       tipe,default=il_default}) =
       let
	   (* We want to use the result type given to avoid type blowup *)
	   val result_type = xcon context tipe
	   val sumcon = xcon context sumtype
	   val exp = xexp context il_arg
	   val (bound', context') = insert_rename_var(bound, context)
	   fun xarm (n, NONE ) = NONE
	     | xarm (n, SOME ilexp) = SOME(Word32.fromInt n, TraceUnknown, xexp context' ilexp)
	   val arms = List.mapPartial (fn x => x) (mapcount xarm il_arms)
	   val default = Util.mapopt (xexp context') il_default
       
	in Switch_e(Sumsw_e {sumtype = sumcon,
			     bound = bound',
			     arg  = exp, arms = arms, 
			     default = default,
			     result_type = result_type})
       end

     | xexp' context (e as Il.EXN_CASE {arg = il_exp, arms = il_arms, default = il_default, tipe}) =
       let
	   val exp = xexp context il_exp
	   val result_type = xcon context tipe
	   val (bounds, tags, bodies) = 
		Listops.unzip3
		  (map (fn (tag,_,Il.FIX(false,_,[Il.FBND(_,var,_,_,e)])) => (var,tag,e)
			| (_,_,il_arm) => (print "EXN_CASE MATCHn"; Ppil.pp_exp il_arm; raise Match)) il_arms)
	   val (bound :: rest) = bounds
	   val _ = if (List.all (fn v => N.eq_var(v,bound)) rest)
		       then () else error "exn_case did not get same var in all arms"

	   val (bound', context') = insert_rename_var (bound, context)

	   val arms' = 
	       Listops.map2 (fn (tag,body) => (xexp context' tag, TraceUnknown,
					       xexp context' body))
                  (tags, bodies)

	   val default = Util.mapopt (xexp context) il_default
       in
	   Switch_e(Exncase_e {	bound = bound',
				arg = exp, arms = arms',
				default = default,
				result_type = result_type})
       end

     | xexp' context (Il.MODULE_PROJECT (il_module, label)) =
       let

           val is_it_proj = N.eq_label(label, IlUtil.it_lab)

	   val mod_opt = 
	       (case il_module of
		    Il.MOD_APP(il_mod_fun, mod_arg) =>
			(case (extractProjLabels il_mod_fun) of
			     (Il.MOD_VAR v, lbls) => 
				 let
				     val ((_,v_r),_) = splitVar (v,context)
				 in
				     if ((!elaborator_specific_optimizations) andalso
					 ((var_is_polyfun(context, v_r)) orelse is_it_proj)) then
					 let
					     val {ebnd_cat, cbnd_cat, name_c, name_r, ...} = 
						 xmod context (mod_arg, NONE)
					     val _ = mark_var_used (context, v_r)
					 in 
					     SOME (NU.makeLetE Sequential
						   ((map NU.makeConb (flattenCatlist cbnd_cat)) @
						    (flattenCatlist ebnd_cat))
						   (NU.makeAppE 
						    (NU.makeSelect (Var_e v_r) lbls) [name_c] [name_r] []))
					 end
				     else
					 NONE
				 end
			   | _ => NONE)
		  | _ => NONE)

	   val module = 
	       (case mod_opt of 
		    SOME module => module
		  | NONE => 
			let
			    val {ebnd_cat, cbnd_cat, name_r, ...} = xmod context (il_module, NONE)
			    val cbnds = flattenCatlist cbnd_cat
			    val bnds = (map NU.makeConb cbnds) @ (flattenCatlist ebnd_cat)
			in
			    NU.makeLetE Sequential bnds name_r
			end)

       in
	   if ((!elaborator_specific_optimizations) andalso is_it_proj) then
	       module
	   else
               Prim_e (NilPrimOp (select label), [],[], [module])
       end

     | xexp' context (Il.SEAL (exp,_)) = xexp context exp


   and xfbnds context (is_recur, il_arrow, fbnds) = 
       let
	   val recursive = if is_recur then Arbitrary else NonRecursive
	   val totality = xeffect il_arrow
	   val fun_names = map (fn Il.FBND(v,_,_,_,_) => v) fbnds
	   val (fun_names', context') = insert_rename_vars (fun_names, context)
	   fun mapper (Il.FBND(var1, var2, il_con1, il_con2, body)) = 
	       let
		   val var1' = rename_var(var1, context')
		   val (var2',context'') = insert_rename_var (var2, context')
		   val con1 = xcon context'' il_con1
		   val con2 = xcon context'' il_con2
		   val body' = xexp context'' body
	       in  (var1', Function{recursive = recursive, effect = totality, isDependent = false,
				    tFormals = [], eFormals = [(var2', TraceUnknown, con1)], 
				    fFormals=[], body = body', body_type = con2})
	       end
       in  map mapper fbnds
       end

   handle e => (print "uncaught exception in xfbnds\n";
		raise e)


   and xbnds context bnds =
       let
	   val temporary_labels = makeInternalLabels (length bnds)
	   val sbnds = map Il.SBND (Listops.zip temporary_labels bnds)

	   val {final_context, cbnd_cat, ebnd_cat, record_c_con_items,
		record_c_knd_items, 
		record_r_exp_items} = 
		xsbnds context sbnds

       in
	   {cbnd_cat = cbnd_cat,
	    ebnd_cat = ebnd_cat,
	    final_context = final_context}
       end

   and xsig' context (con0,Il.SIGNAT_VAR v) = 
          xsig' context (con0,case find_sig(context,v) of
			        NONE => error "unbound signature variable"
			      | SOME s => s)

     |  xsig' context (con0,Il.SIGNAT_OF il_path) = 
          let val {cbnd_cat = cbnd_mod_cat, 
		   ebnd_cat = ebnd_mod_cat,
		   name_c   = name_mod_c, 
		   name_r   = name_mod_r,
		   context  = context,
(*		   knd_c = knd, *)
		   ...} = xmod context (IlUtil.path2mod il_path, NONE)

	      val cbnds = flattenCatlist cbnd_mod_cat
	      val cbnds' = map NU.makeConb cbnds
	      val ebnds = flattenCatlist ebnd_mod_cat
	      val con_mod = NU.makeLetC cbnds name_mod_c
	      val e = NU.makeLetE Sequential
		      (cbnds' @ ebnds)
		      name_mod_r
	      val _ = typeof_count()
	  in  (Single_k(con_mod), Typeof_c e)
	  end

     | xsig' context (con0,Il.SIGNAT_FUNCTOR (var, sig_dom, sig_rng, arrow))=
       let

	   val _ = clear_memo var

	   val is_polyfun_sig = 
	       (case sig_rng of
		    Il.SIGNAT_STRUCTURE([Il.SDEC(it_lbl,Il.DEC_EXP _)]) => N.eq_label(it_lbl,IlUtil.it_lab)
		  | _ => false)

	   val ((var_c, var_r), context) = splitNewVar (var, context)
	   val (knd, con) = xsig context (Var_c var_c, sig_dom)
	   val context = update_NILctx_insert_kind(context, var_c, knd)
	       
	   val (knd', con') = xsig context (App_c(con0, [Var_c var_c]), sig_rng)

           val effect = xeffect arrow
	       
       in
	   (Arrow_k (Open, [(var_c, knd)], knd'),
	    AllArrow_c {openness = Open, effect = effect, isDependent = true,
			tFormals = [(var_c, knd)],
			eFormals = [(SOME var_r, con)], 
			fFormals = 0w0, 
			body_type = con'})
       end

     | xsig' context (con0, Il.SIGNAT_STRUCTURE sdecs) = xsig_struct context (con0,sdecs)
     | xsig' context (con0, Il.SIGNAT_SELF(_, SOME unselfSig, _)) = xsig' context (con0, unselfSig)
     (* the self signature has no self-references; but rather has no internal variable uses *)
     | xsig' context (con0, Il.SIGNAT_SELF(_, NONE, selfSig)) = xsig' context (con0, selfSig)


   and xsig_struct context (con0,sdecs) = 
       let
	   val {crdecs, erdecs} =
	       xsdecs context (con0, NilSubst.C.empty(), sdecs)
	   val kind = Record_k (Sequence.fromList crdecs)
	   val (erlabs, ervars, ercons) = Listops.unzip3 erdecs
	   val type_r = Prim_c(Record_c (erlabs,SOME ervars), ercons)
	   val type_r = (case (!elaborator_specific_optimizations,sdecs,erdecs) of
			     (true,[Il.SDEC(it_lbl,_)],[(_,_,ercon)]) =>
				 (if (N.eq_label(it_lbl,IlUtil.it_lab))
				      then ercon
				  else type_r)
			   | _ => type_r)
       in  (kind, type_r)
       end

   and xsig context (con, il_sig) =
       let
	   val this_call = ! xsig_count
	   val _ = 
	       if (!debug) then
		   (xsig_count := this_call + 1;
		    print ("\nCall " ^ (Int.toString this_call) ^ " to xsig\n");
		    if (!full_debug) then (Ppil.pp_signat il_sig; print "\n") else ())
	       else ()
	   val result = xsig' context (con, il_sig)
	       handle e => (if (!debug) 
				then (print ("Exception detected in call " ^ 
					    (Int.toString this_call) ^ " to xsig:\n");
				      Ppil.pp_signat il_sig;
				      print "\n")
			    else ();
				raise e)
       in  if (!debug) then print ("Return " ^ (Int.toString this_call) ^ " from xsig\n") else ();
	    result
       end
		    
 (* Returns erdecs: term decs
            crdecs: type decs*)
   and xsdecs context (con,subst,sdecs) =
       let
	   val this_call = ! xsdecs_count
	   val _ = if (! debug) then
	            (xsdecs_count := this_call + 1;
		     print ("Call " ^ (Int.toString this_call) ^ " to xsdecs\n");
		     if (!full_debug) then (Ppil.pp_sdecs sdecs; print "\n";
(*
					    print "\nwith context = \n";
					    NilContext_print context;
*)
					    print "\n\n") else ())
                   else ()

	   val sdecs = rewrite_sdecs sdecs

	   val result = xsdecs' context (con,subst,sdecs)
	       handle e => (if (!debug) then (print ("Exception detected in call " ^ 
						    (Int.toString this_call) ^ " to xsdecs\n");
(*
					      print "\nwith context = \n";
					      print_splitting_context context;
*)
					      print "\n")
			    else ();
				raise e)
		   
       in
	   if (!debug) then print ("Return " ^ (Int.toString this_call) ^ " from xsdecs\n") else ();
	   result
       end

  and rewrite_sdecs sdecs =
       let 
	   fun filter (Il.SDEC(lab,Il.DEC_MOD(var,_,_))) = not (N.is_dt lab)
             | filter _ = true

	   fun loop [] = []
	     | loop ((sdec as 
		     Il.SDEC(lab,Il.DEC_EXP(top_var,il_con, _, _))) :: rest) = 
	        if (N.is_cluster lab) then
		   let
(*		       val _ = print "entered mono optimization case\n" *)
		       val clist = (case il_con of
					Il.CON_RECORD lclist => map #2 lclist
				      | Il.CON_ARROW _ => [il_con]
				      | _ => error "can't optimize mono fun")
		       val numFunctions = length clist
		       val (rest, external_labels, external_vars) = 
			   getSdecNames numFunctions rest
		       fun make_sdec (lbl,c) = Il.SDEC(lbl,Il.DEC_EXP(N.fresh_var(),c,NONE,false))
		       val sdecs' = Listops.map2 make_sdec (external_labels,clist)
		   in  sdecs' @ (loop rest)
		   end
	       else
		   sdec::loop rest
	     | loop ((sdec as 
		     Il.SDEC(lbl,
			     Il.DEC_MOD
			     (top_var, true, s as
			      Il.SIGNAT_FUNCTOR(poly_var, il_arg_signat,
						Il.SIGNAT_STRUCTURE([Il.SDEC(them_lbl,
									    Il.DEC_EXP(_,il_con,_,_))]),
						arrow))))
		     :: rest) = 
	       if ((!do_polyrec)
		   andalso (!elaborator_specific_optimizations) 
	           andalso (N.eq_label (them_lbl, IlUtil.them_lab))) then
                   (* if a polymorphic function has a "them" label rather than 
                      an "it" label, then it is a polymorphic function nest whose
                      code (i.e., this entire component) will be eliminated by the
                      phase-splitter.  Therefore, the corresponding specification
                      also is ignored. 

                      Note that the phase-splitter does some complicated transformations
                      to the projections from such a nest, in order to turn polymorphic
                      recursively-defined-functions into polymorphic recursion; however,
                      the types of the projections, which we know immediately follow,
                      are unchanged so we just continue here without doing anything special.
                   *)
		   loop rest
	       else
		   sdec :: (loop rest)
	     | loop (sdec::rest) = sdec::(loop rest)

	   val sdecs = if !elaborator_specific_optimizations
			   then List.filter filter sdecs
		       else sdecs
       in  loop sdecs
       end
   
   and xsdecs' context (con0, _, []) = {crdecs = nil, erdecs = nil}

     | xsdecs' context (con0, subst,  
		    Il.SDEC(lbl, d as Il.DEC_MOD(var,is_poly,signat)) :: rest) =
       let
	   val _ = clear_memo var
	   val ((var_c, var_r), context') = splitNewVar (var, context)
	   val (knd, con) = xsig context' (Proj_c(con0, lbl), signat)
	       
	   val context' = update_NILctx_insert_kind(context', var_c, knd)

	   val {crdecs, erdecs} =
	       xsdecs' context' (con0, addToConSubst subst (var_c, Proj_c(con0, lbl)), rest)

	   val kill_con = is_poly andalso (! elaborator_specific_optimizations)

       in  {crdecs = if kill_con then
                          crdecs
                     else
                          ((lbl, var_c), knd) :: crdecs,
	    erdecs = (lbl,var_r, NS.substConInCon subst con) :: erdecs}
       end

     | xsdecs' context (con0, subst, Il.SDEC(lbl, d as Il.DEC_EXP(var,il_con, _, _)) :: rest) =
       let
	   val con = xcon context il_con
	   val (var', context') = insert_rename_var(var, context)
	   val {crdecs, erdecs} = xsdecs' context' (con0, subst, rest)
       in
	   {crdecs = crdecs,
	    erdecs = (lbl,var',NS.substConInCon subst con) :: erdecs}
       end

     | xsdecs' context (con0, subst, sdecs as Il.SDEC(lbl, d as Il.DEC_CON(var, il_knd, 
									maybecon,_))::rest)=
       let
	   val knd = 
	       (case maybecon of
		    NONE => xkind context il_knd
		  | SOME il_con => Single_k(xcon context il_con))

	   val (var', context') = insert_rename_var(var, context)
	   val context'' = update_NILctx_insert_kind(context', var', knd)
	   val {crdecs, erdecs} = 
	       xsdecs' context'' (con0, addToConSubst subst (var', Proj_c(con0, lbl)),rest)

      in   {crdecs = ((lbl, var'), knd) :: crdecs,
	    erdecs = erdecs}
       end

   and xkind context (Il.KIND) = Type_k
     | xkind context (Il.KIND_TUPLE n) = 
       let val k = NilDefs.kind_type_tuple n
       in k
       end
     | xkind context (Il.KIND_ARROW (n,il_kres)) =
       let val args = map0count (fn _ => (N.fresh_var(), Type_k)) n
	   val kres = xkind context il_kres
           val k = Arrow_k (Open, args, kres)
       in  k
       end


   fun xHILctx HILctx =
       let open Il
	   fun dopc(v,l,pc,(imports,context)) = 
	       (case pc of
		    Il.PHRASE_CLASS_EXP (_,il_type, _, _) => 
			let val nil_type = xcon context il_type
			    val (v',context') = insert_rename_var(v,context)
			in  (ImportValue(l,v',TraceUnknown,nil_type)::imports, context')
			end
		  | Il.PHRASE_CLASS_CON (il_con, il_kind, il_conopt, _) => 
			let
			    val kind = xkind context il_kind
			    val nil_con = 
				(case il_conopt of
				     NONE => NONE
				   | SOME il_con => SOME (xcon context il_con))
			    val (v',context') = insert_rename_var(v,context)
			    val it = ImportType(l,v',(case nil_con of
						 NONE => kind
					       | SOME c => Single_k c))
			    val context'' = 
				(case nil_con of 
				     NONE => update_NILctx_insert_kind(context', v', kind)
				   | SOME c => update_NILctx_insert_kind_equation(context', v', c))
			    val context''' = update_NILctx_insert_label(context'',l,v')
			in  (it::imports, context''')
			end
		  | Il.PHRASE_CLASS_MOD (_,is_polyfun,il_sig) => 
			let
			    val (l_c,l_r) = N.make_cr_labels l
			    val ((v_c, v_r),context) = splitNewVar (v,context)
			    val il_sig = IlContext.UnselfifySig IlContext.empty_context (PATH(v,[]), il_sig)
			    val (knd, type_r) = xsig context (Var_c v_c, il_sig)
				
			    val context = update_NILctx_insert_kind(context, v_c, knd)
			    val context = update_NILctx_insert_label(context, l_c, v_c)
				
			    val iv = ImportValue(l_r,v_r,TraceUnknown,type_r)
			    val it = ImportType(l_c,v_c,knd)
			in
			    if is_polyfun then
				(iv::imports, update_polyfuns(context, v_r))
			    else
				(iv::it::imports, context)
			end
		  | Il.PHRASE_CLASS_SIG(v,il_sig) => 
			(imports,update_insert_sig(context,v,il_sig)))
	   fun folder (p,acc) =
	       let val SOME(l,pc) = IlContext.Context_Lookup_Path(HILctx,p)
	       in  (case ((!elaborator_specific_optimizations) andalso (N.is_dt l), 
			  N.is_nonexport l, p) of
			(false, false, PATH(v,[])) => dopc(v,l,pc,acc)
		      | _ => acc)
	       end
	   val (rev_imports,context) = foldl folder ([],make_initial_splitting_context HILctx)
	                                  (IlContext.Context_Ordering HILctx)
       in  (rev rev_imports, context)
       end


    fun phasesplit (HILctx : Il.context, 
		    sbnd_entries : (Il.sbnd option * Il.context_entry) list) : Nil.module = 
	let
	    val _ = reset_memo()

            (* we move all the externs into the context first:
	       this does not always work if the externs depend on
	       things in the sbnd_entries list *)

	    fun folder((SOME sbnd,Il.CONTEXT_SDEC sdec),(ctxt,sbnds)) = 
		(ctxt, (sbnd,sdec)::sbnds)
	      | folder((NONE, ce),(ctxt,sbnds)) = 
		(IlContext.add_context_entries(ctxt,
		      [case ce of
			   Il.CONTEXT_SDEC(Il.SDEC(l,dec)) => 
			       Il.CONTEXT_SDEC(Il.SDEC(l,IlContext.SelfifyDec ctxt dec))
			 | _ => ce]),
		 sbnds)
	    val (HILctx,rev_sbnd_sdecs) = foldl folder (HILctx,[]) sbnd_entries
	    val sbnds_sdecs = rev rev_sbnd_sdecs
	    val sbnds = map #1 sbnds_sdecs
	    val sdecs = map #2 sbnds_sdecs



            (* Compute the initial context and imports *)
	    val _ = 
		if (!full_debug) then
		    (print "\nInitial HIL context varlist:\n";
		     app (fn p => (print "  "; Ppil.pp_path p; print "\n")) 
		     (IlContext.Context_Ordering HILctx);
		     print "\n";
		     print "\nInitial HIL context:\n";
		     Ppil.pp_context HILctx;
		     print "\n")
		else
		    ()
		    
	    val (imports,initial_splitting_context) = 
		Stats.subtimer("Phase-split-ctxt",xHILctx)
		HILctx
		
	    val _ = 
		if (!full_debug) then
		    (print "\nInitial NIL context:\n";
		     NilContext_print initial_splitting_context;
		     print "\n")
		else
		    ()
	    val _ = msg "  Initial context is phase-split\n"

	    (* Phase-split the bindings *)
	    val {cbnd_cat, ebnd_cat, final_context, ...} =
		xsbnds initial_splitting_context sbnds
	    val cbnds = map NU.makeConb (flattenCatlist cbnd_cat)
	    val ebnds = flattenCatlist ebnd_cat
	    val bnds = cbnds @ ebnds
	    val nil_initial_context = get_nilctxt initial_splitting_context
	    val nil_final_context = get_nilctxt final_context
            (* Since "used" is maintained as a ref in the context, we
               could access it via either the nil_initial_context or
               nil_final_context
             *)
            val used = get_used initial_splitting_context 
	    val _ = msg "  Bindings are phase-split\n" 

	    fun filtering l = if !debug
				  then print ("filtering import " ^ N.label2string l ^ "\n")
			      else ()
		
	     (* Filter out the unused imports *)
	    fun filter_imports [] = ([], used)
              | filter_imports ((iv as ImportValue(l,v,_,c)) :: rest) =
		   let
		       val result as (imports, used) = filter_imports rest
		   in
		       if (VarSet.member(used, v) orelse N.keep_import l) then
			   (iv :: imports, 
			    let val (fvTerm,fvType) = NU.freeExpConVarInCon(true,0,c)
			    in  VarSet.union(used, VarSet.union(fvTerm, fvType))
			    end)
		       else
			   (filtering l; result)
		   end
              | filter_imports ((it as ImportType(l,v,k)) :: rest) =
		   let
		       val result as (imports, used) = filter_imports rest
		   in
		       if (VarSet.member(used, v) orelse N.keep_import l) then
			   (it :: imports, 
			    VarSet.union(used, NU.freeVarInKind (0,k)))
		       else
			   (filtering l; result)
		   end
	    val imports = if (!killDeadImport) then #1 (filter_imports imports) else imports

	    val _ = msg "  Imports are computed\n" 


	    (* create the exports *)
	    fun folder ((Il.SDEC(l,dec)),exports) = 
		    (case (not (N.is_nonexport l) andalso
			   not ((N.is_dt l) andalso
                                (!elaborator_specific_optimizations)), dec) of
			 (false,_) => exports
		       | (true,Il.DEC_EXP (v,_,_,_)) => 
			     let val v' = rename_var (v, final_context)
			     in  (ExportValue(l,v')::exports)
			     end
		       | (true,Il.DEC_CON (v,_,_,_)) =>
			     let 
				 val v' = rename_var (v, final_context)
				 val k = NilContext.find_kind(nil_final_context, v')
				     handle e => (print "exception while doing DEC_CON\n";
						  raise e)
			     in  (ExportType(l,v')::exports)
			     end
		       | (true,Il.DEC_MOD (v,is_polyfun,s)) => 
			     let val (lc,lr) = N.make_cr_labels l
				 (* Already bound *)
				 val ((vc,vr),_) = splitVar (v,final_context)
				 val exports = 
				     if is_polyfun then
					 (ExportValue(lr,vr)::exports)
				     else 
					 (ExportValue(lr,vr)::
					  ExportType(lc,vc)::
					  exports)
			     in  exports
			     end)
	    val exports : export_entry list = rev(foldr folder [] sdecs)
	    val _ = msg "  Exports are phase-split\n" 

	    val nilmod = MODULE{bnds = bnds, 
				imports = imports,
				exports = exports}

	    val _ = reset_memo()
	in  nilmod
	end



end

