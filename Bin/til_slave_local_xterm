#!/bin/sh

# usage: til_slave n count host commdir
#
# Create count slaves on host.  n is used to set window geometry.  We
# create the slaves in a remote emacs displaying on a local xterm.
# Advantage: less communication overhead.
#
# As a hack, the host "localhost" is treated specially.
#
# commdir is a directory, visible to both master and slave, used for
# communication during the parallel make.
#
# This version works at CMU.  You should check it over before
# trying to use it at your site.
#

PATH=/usr/local/bin:/usr/bin:/bin:/usr/ccs/bin:/usr/X11/bin:$PATH
export PATH

case $# in
4)	;;
*)
	echo 1>&2 usage: $0 n count host commdir
	exit 1
	;;
esac

argn="$1"
argcount="$2"
arghost="$3"
argdir="$4"

# At CMU, scp will print diagnostics on some systems unless -q is
# specified.  On other systems, scp -q causes a usage error.

case `sys` in
i386_linux3)
	scp="scp -q"
	;;
*)
	scp="scp"
	;;
esac

# Hack for now: We do CM.make() in $mldir, which is based on $argdir.
# When this is released, we'll put @SMLload'able heaps in some known place.

mldir=`cd "$argdir/.."; pwd`

# The userid for kinit.  At CMU, this will already be set, so we don't
# care that `whoami` isn't the right thing for all systypes.

: ${USER:=`whoami`}

# The X11 title.

title="TIL $mldir @ $arghost"

# Default SML/NJ version to use (matters at CMU, harmless elsewhere)
: ${SML_VERSION:=110}

# The X11 geometry specification for window n.

yoffset=`echo "$argn % 5 * 160" | bc`
xoffset=`echo "$argn / 5 * 300" | bc`
nrows=`echo "11 * $argcount" | bc`
geometry="120x$nrows+$xoffset+$yoffset"

# The bourne shell script to run remotely.

cmdfile=/tmp/til_slave.$$

cmd='	PATH="'"$PATH"'"
	export PATH

	# We assume that unlinking $cmdfile (in /tmp) wont break
	# anything.
	rm -f '$cmdfile'

	# Required for access to AFS at CMU

	if [ "'"$arghost"'" = localhost ]
	then
		:
	else
		if kinit '$USER'
		then
			:
		else
			exit 1
		fi
	fi

	# Required by TIL

	SYS=`sys`
	export SYS

	HOST=`hostname`
	export HOST

	# Required by SML/NJ at CMU, harmless elsewhere

	SML_VERSION='$SML_VERSION'
	export SML_VERSION

	# Run a slave inside NJ inside emacs.

	# Hack for now.  We should be using a custom
	# heap.

	cd "'"$mldir"'"

	cat << "END_EMACS" > /tmp/elisp'$$'
(setq load-path (cons "/usr/local/lib/sml/sml-mode" load-path))
(require '\''sml-mode)
(require '\''comint)
(require '\''sml-proc)
(defun til-slave-startup ()
  (interactive)
  (set-default-font "6x10")
  (menu-bar-mode -1)
  (delete-file "/tmp/elisp'$$'")
  (til-slaves '$argcount' nil))
(defun til-launch-slave ()
  (sml-run "/usr/local/bin/sml" "")
  (sml-skip-errors)
  (comint-send-string (sml-proc)
		      (concat "SMLofNJ.Internals.GC.messages false;"
			      "CM.verbose (SOME false);"
			      "CM.make();"
			      "Manager.slave();\n")))
(defun til-slave ()
  (interactive)
  (til-launch-slave)
  (switch-to-buffer sml-buffer))
(defun til-slaves (n split)
  (if (= n 0)
      (balance-windows)
    (progn
      (if split (split-window-vertically))
      (til-slave)
      (rename-buffer "*til slave*" t)
      (til-slaves (- n 1) t))))
END_EMACS
	exec emacs -nw --no-init-file -bg black -fg yellow \
	     -geometry '$geometry' -l /tmp/elisp'$$' -f til-slave-startup
'

# We put the command into a file because ssh doesn't send the
# command exactly to the remote sh.  Rather than using $argdir
# to hold the file (which may be on AFS -- causing
# synchronization problems we don't want to deal with), we
# send it to /tmp on the remote machine.  Ug.

if [ "$arghost" = localhost ]
then
	echo "$cmd" > $cmdfile
else	
	echo "$cmd" > $cmdfile.local
	$scp $cmdfile.local "$arghost:$cmdfile"
	rm -f $cmdfile.local
fi

if [ "$arghost" = localhost ]
then
	xterm -fn 6x10 -geometry "$geometry" -title "$title" \
		-n "$title" -e /bin/sh $cmdfile &
else
	# Launch script remotely
	xterm -fn 6x10 -geometry "$geometry" -title "$title" \
		-n "$title" -e ssh -t -o 'ForwardX11 no' \
		"$arghost" exec /bin/sh $cmdfile &
fi
