#!/bin/sh

# usage: til_slave n count host commdir
#
# Create count slaves on host.  n is used to set window geometry.
# We create the slaves in a remote emacs whose X interface
# displays locally.  Advantage: X interface.
#
# As a hack, the host "localhost" is treated specially.
#
# commdir is a directory, visible to both master and slave, used for
# communication during the parallel make.
#
# This version works at CMU.  You should check it over before
# trying to use it at your site.
#

PATH=/usr/local/bin:/usr/bin:/bin:/usr/ccs/bin:/usr/X11/bin:$PATH
export PATH

case $# in
4)	;;
*)
	echo 1>&2 usage: $0 n count host commdir
	exit 1
	;;
esac

argn="$1"
argcount="$2"
arghost="$3"
argdir="$4"

# At CMU, scp will print diagnostics on some systems unless -q is
# specified.  On other systems, scp -q causes a usage error.

case `sys` in
i386_linux3)
	scp="scp -q"
	;;
*)
	scp="scp"
	;;
esac

# Hack for now: We do CM.make() in $mldir, which is based on $argdir.
# When this is released, we'll put @SMLload'able heaps in some known place.

mldir=`cd "$argdir/.."; pwd`

# The userid for kinit.  At CMU, this will already be set, so we don't
# care that `whoami` isn't the right thing for all systypes.

: ${USER:=`whoami`}

# The X11 geometry specification for window n.

yoffset=`echo "$argn % 5 * 160" | bc`
xoffset=`echo "$argn / 5 * 300" | bc`
nrows=`echo "11 * $argcount" | bc`
geometry="120x$nrows+$xoffset+$yoffset"

# The X11 geometry specification for kerberos window n.

kgeometry="70x5-0+$yoffset"

# The X11 title for kerberos window n.

ktitle="kinit @ $arghost"

# Default SML/NJ version to use (matters at CMU, harmless elsewhere)
: ${SML_VERSION:=110}

# The bourne shell script to run remotely.

cmdfile=/tmp/til_slave.$$

cmd='	PATH="'"$PATH"'"
	export PATH
	
	# We assume that unlinking $cmdfile (in /tmp) wont break
	# anything.
	rm -f '$cmdfile'

	# Required for access to AFS at CMU

	if [ "'"$arghost"'" = localhost ]
	then
		:
	else
        	# /tmp/kinit'$$' is used to communicate whether or not kinit
		# succeeds

		rm -f /tmp/kinit'$$' >/dev/null
		xterm -title "'$ktitle'" -n "'$ktitle'" \
			-geometry '$kgeometry' -e sh -c \
			"if kinit '$USER'; then touch /tmp/kinit'$$'; fi"

		if test -f /tmp/kinit'$$'
		then
			rm -f /tmp/kinit'$$'
		else
			exit 1
		fi
	fi
	
	# Required by TIL

	SYS=`sys`
	export SYS

	HOST=`hostname`
	export HOST

	# Required by SML/NJ at CMU, harmless elsewhere

	SML_VERSION='$SML_VERSION'
	export SML_VERSION

	# Run a slave inside NJ inside emacs.
	
	# Hack for now.  We should be using a custom
	# heap.

	cd "'"$mldir"'"

	cat << "END_EMACS" > /tmp/elisp'$$'
(setq load-path (cons "/usr/local/lib/sml/sml-mode" load-path))
(require '\''sml-mode)
(require '\''comint)
(require '\''sml-proc)
(defun til-slave-startup ()
  (interactive)
; (set-default-font "6x10")  Window resize due to font change here does not work with Exceed for wide (>100) windows
  (menu-bar-mode -1)
  (delete-file "/tmp/elisp'$$'")
  (til-slaves '$argcount' nil))
(defun til-launch-slave ()
  (sml-run "/usr/local/bin/sml" "")
  (sml-skip-errors)
  (comint-send-string (sml-proc)
		      (concat "SMLofNJ.Internals.GC.messages false;"
			      "CM.verbose (SOME false);"
			      "CM.make();"
			      "Manager.slave();\n")))
(defun til-slave ()
  (interactive)
  (til-launch-slave)
  (switch-to-buffer sml-buffer))
(defun til-slaves (n split)
  (if (= n 0)
      (balance-windows)
    (progn
      (balance-windows)
      (if split (split-window-vertically))
      (balance-windows)
      (til-slave)
      (rename-buffer (concat "*til slave*" (int-to-string n)) t)
      (til-slaves (- n 1) t))))
END_EMACS
	exec emacs --no-init-file -bg black -fg yellow -fn 6x10 -geometry '$geometry' \
	     -l /tmp/elisp'$$' -f til-slave-startup
'

# We put the command into a file because ssh doesn't send the command
# exactly to the remote sh.  Rather than using $argdir to hold the file
# (which may be on AFS -- causing synchronization problems we don't want
# to deal with), we send it to /tmp on the remote machine.  Ug.

echo "$cmd" > $cmdfile.local
if [ "$arghost" = localhost ]
then
	mv $cmdfile.local $cmdfile
else	
	$scp $cmdfile.local "$arghost:$cmdfile"
	rm -f $cmdfile.local
fi

if [ "$arghost" = localhost ]
then
	exec /bin/sh $cmdfile
else
	# Launch script remotely
	exec ssh -n -o 'ForwardX11 yes' "$arghost" exec /bin/sh $cmdfile
fi
