(* ml.grm
 *
 * Copyright 1989,1992 by AT&T Bell Laboratories
 *)
(* See ml.grm's CVS revision 1.14 for PvalDec and PletExp. *)
(* Based on grammar in SML/NJ 110.0.7 *)

open Ast ErrorMsg Symbol FastSymbol AstUtil Fixity

type raw_symbol = FastSymbol.raw_symbol

fun markexp (e as MarkExp _, _, _) = e
  | markexp(e,a,b) = MarkExp(e,(a,b))

fun markdec(d as MarkDec _, _,_) = d
  | markdec(d,a,b) = MarkDec(d,(a,b))

fun marktop(t as MarkTop _, _,_) = t
  | marktop(t,a,b) = MarkTop(t,(a,b))

val asteriskHash = StrgHash.hashString "*"
val asteriskString = "*"
val equalHash = StrgHash.hashString "="
val equalString = "="
val bogusHash = StrgHash.hashString "BOGUS"
val bogusString = "BOGUS"
val quotedBogusHash = StrgHash.hashString "'BOGUS"
val quotedBogusString = "'BOGUS"
val quotedBogusHash = StrgHash.hashString "'BOGUS"
val quotedBogusString = "'BOGUS"

  %%
  %term
      EOF | SEMICOLON
    | ID of FastSymbol.raw_symbol | TYVAR of FastSymbol.raw_symbol
    | INT of TilWord64.word | INT0 of TilWord64.word | DIGIT of int
    | WORD of TilWord64.word
    | REAL of string
    | STRING of string
    | CHAR of string
    | ABSTYPE | AND
    | ARROW | ARROWG | AS | BAR | CASE | DATATYPE | DOTDOTDOT | ELSE | END | EQUALOP
    | EQTYPE | EXCEPTION | DO | DOT | DARROW | FN | FUN | FUNCTOR | HANDLE
    | HASH | IF | IN | INCLUDE | INFIX | INFIXR | LET | LOCAL | NONFIX | OF
    | OP | OPEN | OVERLOAD | RAISE | REC | SHARING | SIG | SIGNATURE | STRUCT
    | STRUCTURE | THEN | TYPE | VAL | WHERE | WHILE | WILD | WITH | WITHTYPE
    | ASTERISK | COLON | STRONGSEAL | WEAKSEAL | COMMA | LBRACE | LBRACKET | LPAREN | RBRACE
    | RBRACKET | RPAREN | ORELSE | ANDALSO
    | EXTERN | CCALL | IMPL | INTER

%nonterm ident of FastSymbol.raw_symbol
       | id of FastSymbol.raw_symbol
       | int of TilWord64.word
       | op_op of unit
       | qid of (FastSymbol.raw_symbol ->symbol) -> symbol list
       | selector of symbol
       | tycon of typath
       | modpath of typath
       | tlabel of (symbol * ty)
       | tlabels  of (symbol * ty) list
       | ty' of ty
       | tuple_ty of ty list
       | ty of ty
       | ty0_pc of ty list
       | match of  rule list
       | rule of  rule
       | elabel of  (symbol * exp)
       | elabels of  (symbol * exp) list
       | exp_ps of  exp list
       | exp of  exp
       | app_exp of  exp fixitem list
       | aexp of  exp
       | exp_list of  exp list
       | exp_2c  of  exp list
       | pat of pat
       | apat of pat fixitem
       | apat' of  pat
       | plabel of  (symbol * pat)
       | plabels of  ((symbol * pat) list * bool)
       | pat_2c of  pat list
       | pat_list of  pat list
       | vbpe of  vb
       | vb of  vb list * vb list
       | constraint of ty option
       | vbm of  vb
       | rvb of  vb list
       | fb' of  clause list
       | fb of  fb list
       | apats of pat fixitem list
       | clause of  clause
       | tb of tb list
       | tyvars of tyvar list
       | tyvarseq of tyvar list
       | tyvar_pc of tyvar list
       | db of  db list
       | dbrhs of dbrhs
       | constrs of (symbol * ty option) list
       | constr of  symbol * ty option
       | eb of  eb list
       | qid_p of Symbol.symbol list list
       | ops of symbol list
       | fixity of {fixity:fixity, ops:symbol list}
       | ldec of dec
       | exp_pa of   exp list
       | ldecs of  dec
       | spec_s of  spec list
       | spec of  spec list
       | topspec_s of  topspec
       | topspec of  topspec
       | idents of spec list
       | strspec of  (symbol * sigexp * path option) list
       | fctspec of  (symbol * sigexp) list
       | tyspec of  (symbol * tyvar list * ty option) list
       | etyspec of  (symbol * tyvar list * ty option) list
       | valspec of (symbol * ty) list
       | exnspec of (symbol * ty option) list
       | sharespec of spec list
       | patheqn of (FastSymbol.raw_symbol ->symbol) -> symbol list list
       | whspec of wherespec list
       | sign of  sigexp
       | sigconstraint_op of  sigexp sigConst
       | sigb of  sigb list
       | fsig of sigexp
       | str of  strexp
       | arg_fcts of (strexp * bool) list
       | arg_fct of strexp * bool 
       | strdec of  dec
       | strdecs of  dec
       | sdec of  dec
       | sdecs of  dec
       | strb of  strb list
       | fparam of  symbol option * sigexp
       | fparamList of  (symbol option * sigexp) list
       | fctb of  strb list
       | top of top
       | functorarrow of functorarrow
       
%verbose

%pos int
%arg (error) : pos * pos -> ErrorMsg.complainer
%start top
%eop EOF SEMICOLON
%noshift EOF

%nonassoc WITHTYPE
%right AND
%right ARROW
%right ARROWG
%right DARROW
%left DO
%left ELSE
%left RAISE
%right HANDLE
%left ORELSE
%left ANDALSO
%right AS
%left COLON


%name ML

%keyword ABSTYPE AND AS CASE DATATYPE DOTDOTDOT ELSE END
  EQTYPE EXCEPTION  DO  DARROW  FN  FUN  FUNCTOR  HANDLE
  IF IN INCLUDE  INFIX  INFIXR  LET  LOCAL  NONFIX  OF  OP
  OPEN OVERLOAD  RAISE  REC  SHARING  SIG  SIGNATURE  STRUCT
  STRUCTURE THEN TYPE VAL WHILE WHERE WITH WITHTYPE
  ORELSE ANDALSO
  CCALL EXTERN

%change -> VAL | -> THEN | -> ELSE | -> LPAREN | -> SEMICOLON |
        DARROW -> EQUALOP | EQUALOP -> DARROW | AND -> ANDALSO | COLON -> OF |
        SEMICOLON -> COMMA | COMMA -> SEMICOLON |
        -> IN ID END | -> ELSE ID

%value ID (rawSymbol(bogusHash,bogusString))
%value TYVAR (rawSymbol(quotedBogusHash,quotedBogusString))
%value INT (TilWord64.fromInt 1)
%value INT0 (TilWord64.fromInt 0)
%value DIGIT (0)
%value WORD (TilWord64.fromInt 0)
%value REAL ("0.0")
%value STRING ("")
%value CHAR ("a")

%%

int	: INT		(INT)
	| INT0		(INT0)
	| DIGIT		(TilWord64.fromInt DIGIT)

id	: ID		(ID)
	| ASTERISK	(rawSymbol (asteriskHash,asteriskString))

ident	: ID 		(ID)
	| ASTERISK	(rawSymbol (asteriskHash,asteriskString))
	| EQUALOP	(rawSymbol (equalHash,equalString))

op_op	: OP		(error (OPleft,OPright) WARN "unnecessary `op'"
			       nullErrorBody)
	| 		()

qid	: ID DOT qid	(fn kind => strSymbol ID :: qid kind)
	| ident		(fn kind => [kind ident])

selector: id		(labSymbol id)
	| INT		(Symbol.labSymbol (TilWord64.toDecimalString INT))
	| DIGIT		(Symbol.labSymbol (Int.toString DIGIT))

modpath : ID                    (TypathHead(strSymbol ID))
        | modpath DOT ID        (TypathProj(modpath, strSymbol ID))
        | modpath LPAREN modpath RPAREN
                                (TypathApp(modpath1,modpath2))        

tycon   : ID                    (TypathHead(tycSymbol ID))
        | modpath DOT ID        (TypathProj(modpath, tycSymbol ID))

tlabel	: selector COLON ty	(selector,ty)

tlabels : tlabel COMMA tlabels	(tlabel :: tlabels)
	| tlabel		([tlabel])

ty'	: TYVAR		(MarkTy (VarTy(Tyv(tyvSymbol TYVAR)),
				 (TYVARleft,TYVARright)))
	| LBRACE tlabels
		 RBRACE (MarkTy(RecordTy tlabels,(LBRACEleft,RBRACEright)))
	| LBRACE RBRACE	(RecordTy [])
	| LPAREN ty0_pc RPAREN tycon
			(MarkTy(ConTy(tycon,ty0_pc),(tyconleft,tyconright)))
	| LPAREN ty RPAREN	(ty)
	| ty' tycon	(MarkTy(ConTy(tycon,[ty']),(tyconleft,tyconright)))
	| tycon		(MarkTy(ConTy(tycon,[]),(tyconleft,tyconright)))

tuple_ty : ty' ASTERISK tuple_ty 	(ty' :: tuple_ty)
	 | ty' ASTERISK ty'	 	([ty'1,ty'2])

ty	: tuple_ty	(TupleTy(tuple_ty))
	| ty ARROW ty	(ConTy(TypathHead(arrowTycon), [ty1,ty2]))
	| ty' 		(ty')

ty0_pc	: ty COMMA ty		([ty1,ty2])
	| ty COMMA ty0_pc 	(ty :: ty0_pc)

match	: rule			([rule])
	| rule BAR match	(rule :: match)

rule	: pat DARROW exp        (Rule{pat=pat,
				      exp=markexp(exp,expleft,expright)})

		(* 	EXPRESSIONS	*)

elabel	: selector EQUALOP exp	(selector,exp)

elabels : elabel COMMA elabels	(elabel :: elabels)
	| elabel	        ([elabel])

exp_ps	: exp		        ([exp])
	| exp SEMICOLON exp_ps	(exp :: exp_ps)

exp	: exp HANDLE match	(HandleExp{expr=exp,rules=match})

        | exp ORELSE exp        (OrelseExp(markexp(exp1,exp1left,exp1right),
					   markexp(exp2,exp2left,exp2right)))
	 | exp ANDALSO exp      (AndalsoExp(markexp(exp1,exp1left,exp1right),
					    markexp(exp2,exp2left,exp2right)))
	 | exp COLON ty	        (ConstraintExp{expr=exp,constraint=ty})
	 | app_exp	        (FlatAppExp(app_exp))
	 | FN match	        (markexp(FnExp match, FNleft,matchright))
	 | CASE exp OF match	(markexp(CaseExp{expr=exp, rules=match},
					 CASEleft,matchright))
	 | WHILE exp DO exp	(WhileExp
                                   {test=markexp(exp1, exp1left, exp1right),
				    expr=markexp(exp2, exp2left, exp2right)})
	 | IF exp THEN exp ELSE exp (IfExp{test=exp1,
				   thenCase=markexp(exp2,exp2left,exp2right),
				   elseCase=markexp(exp3,exp3left,exp3right)})
	 | RAISE exp	     (markexp(markexp(RaiseExp exp, expleft,expright),
				      RAISEleft,expright))
	 | CCALL LPAREN exp_list RPAREN 		(CcallExp (hd exp_list, tl exp_list))

app_exp	: aexp	        ([{item=markexp(aexp,aexpleft,aexpright),
			   region=(aexpleft,aexpright), fixity=NONE}])
	| ident		([let val (v,f) = var'n'fix ident
			    in {item=markexp(VarExp [v],identleft,identright),
				region=(identleft,identright),
				fixity=SOME f}
			    end])
	| aexp app_exp	({item=markexp(aexp,aexpleft,aexpright),
			  region=(aexpleft,aexpright), fixity=NONE}
                            :: app_exp)
	| ident app_exp (let val (v,f) = var'n'fix ident
			  in {item=markexp(VarExp [v],identleft,identright),
			      region=(identleft,identright),
				fixity=SOME f} :: app_exp
			 end)

 aexp	: OP ident		(VarExp [varSymbol ident])
	| ID DOT qid		(VarExp (strSymbol ID :: qid varSymbol))
	| int			(IntExp int)
	| WORD			(WordExp WORD)
	| REAL			(RealExp REAL)
	| STRING		(StringExp STRING)
	| CHAR 		        (CharExp CHAR)
	| HASH selector		(markexp(SelectorExp selector,
						   HASHleft, selectorright))
	| LBRACE elabels RBRACE	(markexp(RecordExp elabels,
					 LBRACEleft,RBRACEright))
	| LBRACE RBRACE		(RecordExp nil)
	| LPAREN RPAREN		(unitExp)
	| LPAREN exp_ps RPAREN	(SeqExp exp_ps)
	| LPAREN exp_2c RPAREN	(TupleExp exp_2c)
	| LBRACKET exp_list RBRACKET     (ListExp exp_list)
	| LBRACKET RBRACKET	(ListExp nil)
	| LET ldecs IN exp_ps END
				(markexp (LetExp{dec=markdec(ldecs,ldecsleft,
							     ldecsright),
						 expr=SeqExp exp_ps},
					  LETleft,ENDright))

exp_2c	: exp COMMA exp_2c	(exp :: exp_2c)
	| exp COMMA exp		([exp1, exp2])

exp_list : exp			([exp])
	 | exp COMMA exp_list	(exp :: exp_list)

pat	: pat AS pat		(layered(pat1, pat2,
					 error(pat1left,pat2right)))
	| pat COLON ty		(ConstraintPat{pattern=pat, constraint=ty})
	| apats			(FlatAppPat apats)

apat	: apat'		({item=apat', region=(apat'left,apat'right),
			  fixity=NONE})
	| LPAREN pat RPAREN	({item=pat,
				  region=(LPARENleft,RPARENright),
				  fixity=NONE})
	| id			(let val (v,f) = var'n'fix id
				 in {item=VarPat [v],
				     region=(idleft,idright),
				     fixity=SOME f} end)
	| LPAREN RPAREN		({item=unitPat,fixity=NONE,
				  region=(LPARENleft,RPARENright)})
	| LPAREN pat COMMA  pat_list RPAREN
  				({item=TuplePat(pat :: pat_list),
				  region=(LPARENleft,RPARENright),
				  fixity=NONE})

apat'	: OP ident		(VarPat [varSymbol ident])
	| ID DOT qid		(VarPat (strSymbol ID :: qid varSymbol))
	| int			(IntPat int)
	| WORD			(WordPat WORD)
	| STRING		(StringPat STRING)
        | CHAR 			(CharPat CHAR)
	| WILD			(WildPat)
	| LBRACKET RBRACKET	(ListPat nil)
	| LBRACKET pat_list
		RBRACKET	(ListPat pat_list)
	| LBRACE RBRACE		(unitPat)
	| LBRACE plabels RBRACE
		            (let val (d,f) = plabels
			     in MarkPat(RecordPat{def=d,flexibility=f},
					(LBRACEleft,RBRACEright)) end)

plabel	: selector EQUALOP pat	((selector,pat))
	| ID			(labSymbol ID, VarPat [varSymbol ID])
	| ID AS pat		(labSymbol ID,
				 LayeredPat{varPat=VarPat [varSymbol ID],
					    expPat=pat})
	| ID COLON ty		(labSymbol ID,
				 ConstraintPat{pattern=VarPat [varSymbol ID],
					       constraint=ty})
	| ID COLON ty AS pat	(labSymbol ID,
				 LayeredPat
				 {varPat=ConstraintPat{pattern=VarPat [varSymbol ID],
						       constraint=ty},
				  expPat=pat})

plabels : plabel COMMA plabels	(let val (a,(b,fx))=(plabel, plabels)
				 in (a::b, fx) end)
	| plabel		([plabel],false)
	| DOTDOTDOT		(nil, true)

pat_list: pat			([pat])
	| pat COMMA pat_list	(pat :: pat_list)

vbpe	: pat EQUALOP exp	(MarkVb(Vb{exp=exp,pat=pat},(patleft,expright)))

vb	: vbpe			(([vbpe],nil))
	| vbpe AND vb		((vbpe :: #1 vb, #2 vb))
	| REC rvb		((nil, rvb))

constraint :	 		(NONE)
	   | COLON ty	 	(SOME ty)

vbm	: pat EQUALOP FN match	(MarkVb(Vb{exp=FnExp match,pat=pat},(patleft,matchright)))


rvb	: vbm			([vbm])
	| vbm AND rvb		(vbm :: rvb)
	| REC rvb		(rvb)

fb'	: clause		([clause])
	| clause BAR fb'	(clause :: fb')

fb	: fb'			([MarkFb(Fb fb', (fb'left,fb'right))])
	| fb' AND fb		(MarkFb(Fb fb', (fb'left,fb'right)) :: fb)

apats	: apat			([apat])
	| apat apats		(apat :: apats)

clause	: apats constraint EQUALOP exp
		(Clause{pats=apats,
			resultty=constraint,
			exp=markexp(exp,expleft,expright)})


tb	: tyvars ID EQUALOP ty	([MarkTb(
				   Tb{tyvars=tyvars,tyc=tycSymbol ID,def=ty},
				   (tyleft,tyright))])
	| tb AND tb		(tb1 @ tb2)

tyvars	: TYVAR			([MarkTyv(Tyv(tyvSymbol TYVAR),
					 (TYVARleft,TYVARright))])
	| LPAREN tyvar_pc RPAREN  (tyvar_pc)
	|			  (nil)

tyvarseq: TYVAR			([MarkTyv(Tyv(tyvSymbol TYVAR),
					 (TYVARleft,TYVARright))])
	| LPAREN tyvar_pc RPAREN  (tyvar_pc)

tyvar_pc: TYVAR	([MarkTyv(Tyv(tyvSymbol TYVAR), (TYVARleft,TYVARright))])
	| TYVAR COMMA tyvar_pc
		(MarkTyv(Tyv(tyvSymbol TYVAR),(TYVARleft,TYVARright))
		 :: tyvar_pc)

db	: db AND db			(db1 @ db2)
	| ID EQUALOP dbrhs		([Db{tyc=tycSymbol ID,tyvars=[],rhs=dbrhs}])
	| tyvarseq ID EQUALOP dbrhs	([Db{tyc=tycSymbol ID,tyvars=tyvarseq,rhs=dbrhs}])

dbrhs   : constrs			(Constrs constrs)

constrs : constr		([constr])
	| constr BAR constrs	(constr :: constrs)

constr	: op_op ident		(varSymbol ident, NONE)
	| op_op ident OF ty	(varSymbol ident, SOME ty)

eb	: op_op ident		([EbGen{exn=(varSymbol ident),etype=NONE}])
	| op_op ident OF ty	([EbGen{exn=(varSymbol ident),etype=SOME ty}])
	| op_op ident EQUALOP qid	([EbDef{exn=varSymbol ident,
					edef=qid varSymbol}])
	| eb AND eb		(eb1 @ eb2)

qid_p	: qid			([qid strSymbol])
	| qid qid_p		(qid strSymbol :: qid_p)

ops	: ident			([fixSymbol ident])
	| ident ops		(fixSymbol ident :: ops)

fixity	: INFIX ops		({fixity=infixleft 0, ops=ops})
	| INFIX DIGIT ops	({fixity=infixleft DIGIT, ops=ops})
	| INFIXR ops		({fixity=infixright 0, ops=ops})
	| INFIXR DIGIT ops	({fixity=infixright DIGIT, ops=ops})
	| NONFIX ops		({fixity=NONfix,ops=ops})

ldec	: VAL vb		(ValDec(#1 vb, #2 vb,ref []))
        | VAL tyvarseq vb       (ValDec(#1 vb, #2 vb,ref tyvarseq))
	| FUN fb		(FunDec (fb,ref []))
        | FUN tyvarseq fb       (FunDec(fb,ref tyvarseq))
	| EXTERN ID COLON ty 	(ExternDec(varSymbol ID,ty))
	| TYPE tb		(TypeDec tb)
	| DATATYPE ID EQUALOP DATATYPE qid
				(DatatypeDec{datatycs=[Db{tyc=tycSymbol ID,tyvars=[],rhs=Repl (qid tycSymbol)}],
					     withtycs=[]})
	| DATATYPE db		(DatatypeDec{datatycs=db,withtycs=[]})
 	| DATATYPE db WITHTYPE tb  (DatatypeDec{datatycs=db,withtycs=tb})
	| ABSTYPE db WITH ldecs END (AbstypeDec{abstycs=db,withtycs=[],
						body=ldecs})
	| ABSTYPE db WITHTYPE tb WITH ldecs END  (AbstypeDec{abstycs=db,
							     withtycs=tb,
							     body=ldecs})
	| EXCEPTION eb		(ExceptionDec eb)
	| OPEN qid_p		(OpenDec qid_p)
	| fixity		(FixDec fixity)
	| OVERLOAD ident COLON ty AS exp_pa
				(OvldDec(varSymbol ident,ty,exp_pa))

exp_pa	: exp			([exp])
	| exp AND exp_pa	(exp :: exp_pa)

ldecs	: 			(SeqDec nil)
	| ldec ldecs  		(makeSEQdec
				 (markdec(ldec,ldecleft,ldecright), ldecs))
	| SEMICOLON ldecs	(ldecs)
	| LOCAL ldecs IN ldecs END ldecs
 		(makeSEQdec
 		   (markdec(LocalDec(markdec(ldecs1,ldecs1left,ldecs1right),
				     markdec(ldecs2,ldecs2left,ldecs2right)),
			    LOCALleft,ENDright),
 	            ldecs3))

spec_s	: 			([])
	| spec spec_s		(spec @ spec_s)
	| SEMICOLON spec_s	(spec_s)

spec	: STRUCTURE strspec	([StrSpec strspec])
        | FUNCTOR strspec       ([StrSpec strspec])
	| DATATYPE ID EQUALOP DATATYPE qid
				([DataSpec{datatycs=[Db{tyc=tycSymbol ID,tyvars=[],rhs=Repl (qid tycSymbol)}],
					     withtycs=[]}])
	| DATATYPE db		([DataSpec{datatycs=db,withtycs=nil}])
	| DATATYPE db WITHTYPE tb ([DataSpec{datatycs=db,withtycs=tb}])
	| TYPE tyspec		([TycSpec(tyspec,false)])
	| EQTYPE etyspec		([TycSpec(etyspec,true)])
	| VAL valspec		([ValSpec valspec])
	| EXCEPTION exnspec	([ExceSpec exnspec])
	| SHARING sharespec	(sharespec)
	| INCLUDE sign		([IncludeSpec sign])
	| INCLUDE ident idents	(IncludeSpec(VarSig(FastSymbol.sigSymbol ident))
				:: idents)

fsig	: fparamList COLON sign	(foldr (fn (x,s) => FunSig(x,s,Generative)) sign fparamList)

fctspec	: fctspec AND fctspec	(fctspec1 @ fctspec2)
	| ident fsig		([(strSymbol ident, fsig)])

topspec	: spec			(TopSpec spec)
	| FUNCTOR fctspec	(TopSpec [FctSpec fctspec])
	| SIGNATURE sigb	(SigSpec sigb)
	| OVERLOAD ident COLON ty AS exp_pa
				(OvldSpec (varSymbol ident,ty,exp_pa))
	| fixity		(FixSpec fixity)
	| EXTERN ID COLON ty 	(ExternSpec(varSymbol ID,ty))

topspec_s	: 		(SeqSpec[])
	| topspec topspec_s	(makeSEQtopspec (topspec,topspec_s))
	| SEMICOLON topspec_s	(topspec_s)

idents	: ident			([IncludeSpec(VarSig(FastSymbol.sigSymbol ident))])
	| ident idents		(IncludeSpec(VarSig(FastSymbol.sigSymbol ident))
				 :: idents)

strspec	: strspec AND strspec	(strspec1 @ strspec2)
	| ident COLON sign	([(strSymbol ident, sign, NONE)])
	| ident COLON sign EQUALOP qid
				([(strSymbol ident, sign, SOME(qid strSymbol))])

etyspec	: etyspec AND etyspec	(etyspec1 @ etyspec2)
	| tyvars ID		([(tycSymbol ID,tyvars,NONE)])

tyspec	: tyspec AND tyspec	(tyspec1 @ tyspec2)
	| tyvars ID		([(tycSymbol ID,tyvars,NONE)])
        | tyvars ID EQUALOP ty  ([(tycSymbol ID,tyvars,SOME ty)])

valspec	: valspec AND valspec	(valspec1 @ valspec2)
	| op_op ident COLON ty  ([(varSymbol ident,ty)])


exnspec : exnspec AND exnspec	(exnspec1 @ exnspec2)
	| ident			([(varSymbol ident,NONE)])
	| ident OF ty		([(varSymbol ident,SOME ty)])

sharespec: sharespec AND sharespec	(sharespec1 @ sharespec2)
	 | TYPE patheqn	([MarkSpec (ShareTycSpec(patheqn tycSymbol),
				    (patheqnleft,patheqnright))])
	 | patheqn	([MarkSpec (ShareStrSpec (patheqn strSymbol),
				    (patheqnleft,patheqnright))])

patheqn : qid EQUALOP qid	(fn kind => [qid1 kind, qid2 kind])
        | qid EQUALOP patheqn	(fn kind => qid kind :: patheqn kind)

whspec  : whspec AND whspec     (whspec1 @ whspec2)
        | TYPE tyvars qid EQUALOP ty
				([WhType(qid tycSymbol,tyvars,ty)])
        | qid EQUALOP qid	([WhStruct(qid1 strSymbol,qid2 strSymbol)])

functorarrow : 
          ARROW                 (Applicative)
        | ARROWG                (Generative)

sign	: ident			(MarkSig(VarSig (sigSymbol ident),
				         (identleft,identright)))
	| SIG spec_s END	(MarkSig(BaseSig(spec_s),(SIGleft,ENDright)))
        | SIG REC spec_s END    (MarkSig(RdsSig(spec_s),(SIGleft,ENDright)))
        | sign WHERE whspec     (MarkSig(AugSig(sign,whspec),(signleft,whspecright)))
        | LPAREN fparam RPAREN functorarrow sign 
                                (MarkSig(FunSig(fparam,sign,functorarrow),(LPARENleft,signright)))
        | LPAREN sign RPAREN    (sign)

sigconstraint_op :		(NoSig)
	| COLON sign		(Transparent(sign))
 	| STRONGSEAL sign	(StrongOpaque(sign))
        | WEAKSEAL sign		(WeakOpaque(sign))

sigb	: sigb AND sigb		(sigb1 @ sigb2)
	| ident EQUALOP sign	([Sigb{name=sigSymbol ident,def=sign}])

str	: qid                   (MarkStr(VarStr(qid strSymbol),(qidleft,qidright)))
        | qid arg_fcts          (MarkStr(AppStr(qid strSymbol, arg_fcts),(qidleft,arg_fctsright)))
	| STRUCT strdecs END
		(MarkStr(BaseStr strdecs,(STRUCTleft,ENDright)))
	| LET strdecs IN str END
		(MarkStr(LetStr(strdecs, str), (LETleft,ENDright)))
        | str COLON sign
	        (MarkStr(ConstrainedStr(str,Transparent sign),
		         (strleft,signright)))
        | str STRONGSEAL sign
	        (MarkStr(ConstrainedStr(str,StrongOpaque sign),
		         (strleft,signright)))
        | str WEAKSEAL sign
	        (MarkStr(ConstrainedStr(str,WeakOpaque sign),
		         (strleft,signright)))

arg_fcts : arg_fct               ([arg_fct])
        | arg_fct arg_fcts       (arg_fct::arg_fcts)

arg_fct : LPAREN str RPAREN 		((str, true))
	| LPAREN strdecs RPAREN		((MarkStr(BaseStr strdecs,
						   (strdecsleft,strdecsright)),
					   false))

strdecs	: strdec strdecs	(makeSEQdec (markdec(strdec,strdecleft,strdecright),
					     strdecs))
	| SEMICOLON strdecs	(strdecs)
	|			(SeqDec[])

sdecs	: sdec sdecs		(makeSEQdec (markdec(sdec,sdecleft,sdecright),
					     sdecs))
	| SEMICOLON sdecs	(sdecs)
	|			(SeqDec[])

strdec	: STRUCTURE strb	(StrDec strb)
	| LOCAL strdecs IN strdecs END (LocalDec(markdec(strdecs1,
				     strdecs1left,strdecs1right),
  			       markdec(strdecs2,strdecs2left,strdecs2right)))
        | FUNCTOR fctb          (StrDec fctb)
        | FUNCTOR strb          (StrDec strb)
	| ldec			(markdec(ldec,ldecleft,ldecright))
        | STRUCTURE REC ident COLON sign EQUALOP str
                                (markdec(StrRecDec{name=strSymbol ident, def=str,
						   constraint=sign},
					 STRUCTUREleft, strright))

sdec	: STRUCTURE strb	(StrDec strb)
	| SIGNATURE sigb	(SigDec sigb)
	| FUNCTOR fctb		(StrDec fctb)
        | FUNCTOR strb          (StrDec strb)
	| LOCAL sdecs IN sdecs END (LocalDec(markdec(sdecs1,
						     sdecs1left,sdecs1right),
				    markdec(sdecs2,sdecs2left,sdecs2right)))
	| ldec			(markdec(ldec,ldecleft,ldecright))
        | STRUCTURE REC ident COLON sign EQUALOP str
                                (markdec(StrRecDec{name=strSymbol ident, def=str,
						   constraint=sign},
					 STRUCTUREleft, strright))

strb	: ident sigconstraint_op EQUALOP str
	   		([MarkStrb(Strb{name = strSymbol ident,def = str,
					constraint=sigconstraint_op},
				   (identleft,strright))])
	| strb AND strb		(strb1 @ strb2)

fparam	: ID COLON sign		((SOME(strSymbol ID),sign))
	| spec_s		((NONE,MarkSig(BaseSig(spec_s),
					       (spec_sleft,spec_sright))))

fparamList
	: LPAREN fparam	RPAREN			([fparam])
        | LPAREN fparam RPAREN fparamList       (fparam::fparamList) 

fctb	: ident fparamList sigconstraint_op EQUALOP str
		([MarkStrb(Strb {name = strSymbol ident,
                                 def = BaseFct{params=fparamList, body=str,
				              constraint=sigconstraint_op},
				 constraint = NoSig},
			   (identleft,strright))])
	| fctb AND fctb		(fctb1 @ fctb2)

top : IMPL sdecs   (marktop(ImplTop(sdecs), sdecsleft, sdecsright))
    | INTER topspec_s (marktop(InterTop(topspec_s), topspec_sleft, topspec_sright))
